<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Haikyu Fly High - Team Builder by Devoy Aces</title>
<style>
    #menuBtn {
    width: 60px;
    height: 60px;
    font-size: 2.5em;
    padding: 0;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #28a745;
    color: white;
    border: none;
    cursor: pointer;
    z-index: 1000;
    position: fixed;
    top: 15px;
    left: 15px;
}

#menuBtn:hover {
    background-color: #218838;
}
    #rotateBtn,
    #saveTeamBtn,
    #clearTeamBtn {
        font-size: 2em;
        padding: 20px 38px;
        min-width: 180px;
        border-radius: 8px;
    }
    body {
        background-color: #222;
        color: #fff;
        font-family: Arial, sans-serif;
        text-align: center;
    }

    h1 {
        margin-top: 20px;
    }

    .team-grid {
        display: flex;
        flex-direction: column;
        gap: 20px;
        align-items: center;
        margin-top: 30px;
    }

    .row {
        display: flex;
        gap: 20px;
    }

    .top-row {
        transform: translateX(6px);
    }

    .player-slot {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .hex {
        position: relative;
        width: 150px;
        height: 210px;
        background-color: #444;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.3s;
        overflow: hidden;
    }

    .hex:hover {
        background-color: #555;
    }

    .hex img {
        width: 100%;
        height: 100%;
object-fit: Save;
    }

    .player-info {
        margin-top: 5px;
        font-size: 14px;
        color: #fff;
        text-align: center;
        max-width: 150px;
        word-wrap: break-word;
    }

    .bench-slot {
        width: 50px;
        height: 67px;
        background-color: #444;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        overflow: hidden;
    }

    .bench-slot img {
        width: 100%;
        height: 100%;
         object-fit: Save;
    }

    .add-slot-btn {
        background-color: #28a745;
        border: none;
        color: white;
        padding: 5px 10px;
        margin-left: 10px;
        cursor: pointer;
        border-radius: 5px;
    }

    .add-slot-btn:hover {
        background-color: #218838;
    }
.bench-quick{
  display:flex; gap:6px; margin:0 10px;
}
.bench-quick-btn{
  background:#222; color:#fff; border:1px solid #555;
  border-radius:6px; padding:4px 6px; font-size:12px; cursor:pointer;
}
.bench-quick-btn:hover{ background:#333; }
    #saveTeamBtn {
        background-color: #28a745;
        border: none;
        color: white;
        padding: 6px 10px;
        margin-right: 10px;
        cursor: pointer;
        border-radius: 5px;
        font-size: 16px;
        vertical-align: middle;
    }

    #saveTeamBtn:hover {
        background-color: #218838;
    } 



    #synergy-panel {
        margin-top: 50px;
        background-color: #333;
        padding: 15px;
        border-radius: 10px;
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
        text-align: left;
    }

    .scroll-menu {
        display: none;
        margin-top: 10px;
        max-height: 200px;
        overflow-y: auto;
        background-color: #333;
        padding: 10px;
        border-radius: 8px;
        flex-wrap: wrap;
    }

    .scroll-menu img {
        width: 80px;
        height: auto;
        cursor: grab;
        margin: 5px;
        border: 2px solid transparent;
    }

    .scroll-menu img:hover {
        border: 2px solid yellow;
    }

    /* Painel lateral */
    .sidebar {
        position: fixed;
        top: 0;
        left: 0;
        width: 300px;
        height: 100%;
        background-color: #333;
        overflow-x: hidden;
        transition: transform 0.3s ease, opacity 0.3s ease;
        transform: translateX(-100%);
        padding: 20px;
        box-shadow: 2px 0 5px rgba(0,0,0,0.5);
        z-index: 999;
        opacity: 0;
        pointer-events: none;
        display: flex;
        flex-direction: column;
    }

    .sidebar.open {
        transform: translateX(0);
        opacity: 1;
        pointer-events: auto;
    }

    .sidebar h2 {
        color: #fff;
        margin-bottom: 20px;
    }

    .sidebar button.close-btn {
        background: none;
        border: none;
        color: #fff;
        font-size: 20px;
        cursor: pointer;
        position: absolute;
        top: 15px;
        right: 15px;
    }

    #menuBtn {
        position: fixed;
        top: 15px;
        left: 15px;
        background-color: #28a745;
        color: white;
        border: none;
        padding: 10px 15px;
        font-size: 18px;
        cursor: pointer;
        border-radius: 5px;
        z-index: 1000;
    }

    #menuBtn:hover {
        background-color: #218838;
    }
    /* Aumenta o botão no mobile / telas touch */
@media (max-width: 768px), (pointer: coarse) {
  #menuBtn {
    /* alvo de toque grande (recomendado 48–64px) */
    width: 64px;
    height: 64px;

    /* centraliza o ícone ☰ dentro do quadrado */
    display: inline-flex;
    align-items: center;
    justify-content: center;

    /* o ícone fica Mayr */
    font-size: 32px;

    /* remove o padding para não “esticar” além do width/height */
    padding: 0;

    /* arredondamento um pouco Mayr (opcional) */
    border-radius: 12px;
  }
}

    /* Lista de characters no menu */
    .char-list {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
    }

    .char-card {
        width: 80px;
        text-align: center;
        cursor: pointer;
    }

    .char-card img {
        width: 100%;
        border-radius: 5px;
    }

    /* Conteúdo do menu com rolagem */
    #sidebar {
    scroll-behavior: smooth;    
    position: fixed;
    right: 0;
    top: 0;
    width: 300px; /* ajuste conforme seu layout */
    height: 100vh; /* ocupa a tela inteira */
    background-color: #222;
    color: white;
    overflow-y: auto; /* ativa rolagem vertical */
    padding: 10px;
    box-sizing: border-box;


    /* Oculta a barra no Chrome, Edge, Safari */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE e Edge antigos */
}
    #sidebar::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Edge */
}

    .filtros {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 10px;
    }

    .filtros label {
        font-size: 14px;
        font-weight: bold;
        margin-bottom: 3px;
        display:block;
        text-align:left;
    }

    .filtros select {
        width: 100%;
        padding: 5px;
        font-size: 14px;
        border-radius: 5px;
        border: none;
    }

    #limparFiltros {
        background-color: #ff4d4d;
        color: white;
        border: none;
        padding: 6px;
        font-size: 14px;
        border-radius: 5px;
        cursor: pointer;
        width:100%;
    }

    #limparFiltros:hover {
        background-color: #e60000;
    }

    .saved-list button {
        margin-left: 8px;
        padding: 4px 8px;
        font-size: 13px;
        border-radius: 4px;
        cursor: pointer;
        border: none;
    }
    .saved-list .load-btn { background:#28a745; color:#fff; }
    .saved-list .del-btn { background:#ff4d4d; color:#fff; }

    .bond-btn {
    background-color: #444;
    color: white;
    border: 1px solid #666;
    border-radius: 6px;
    padding: 4px 8px;
    font-size: 14px;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.2s;
}

.bond-btn:hover {
    background-color: #666;
    transform: scale(1.05);
}

.bond-btn:active {
    background-color: #888;
    transform: scale(0.98);
}
    .skill-btn {
    background-color: #555;
    color: white;
    border: 1px solid #777;
    border-radius: 6px;
    padding: 4px 8px;
    font-size: 14px;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.2s;
}

.skill-btn:hover {
    background-color: #777;
    transform: scale(1.05);
}

.skill-btn:active {
    background-color: #999;
    transform: scale(0.98);
}
    .char-info {
    text-align: center;
    margin-top: 4px;
}

.char-name {
    font-weight: bold;
    font-size: 14px;
    color: #fff;
    margin: 0;
}

.char-Stats {
    font-size: 12px;
    color: #ccc;
    margin: 0;
}

.char-Stats span {
    font-weight: bold;
    color: #ffcc00; /* cor destaque do valor */
}
    #scrollMenu {
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE e Edge antigos */
}

#scrollMenu::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Edge */
}
    #scrollMenu {
    overflow-y: auto; /* já está, mas reforçando */
}
   /* header de filtros dentro do scrollMenu (bench) */
#scrollMenu .bench-quick-inside{
  display:flex; gap:6px; padding:6px 6px 8px; flex-wrap:wrap;
}
#scrollMenu .bench-quick-inside button{
  background:#222; color:#fff; border:1px solid #555;
  border-radius:6px; padding:4px 6px; font-size:12px; cursor:pointer;
}
#scrollMenu .bench-quick-inside button.active{ outline:2px solid #999; }
    
#sidebar-content ul {
    list-style: none;       /* remove bullets */
    padding-left: 0;        /* remove recuo padrão */
    margin-left: 0;         /* evita deslocamento */
    text-align: center;     /* centraliza texto */
}

#sidebar-content li {
    margin-bottom: 4px;     /* espaço entre linhas */
}
    .filtros {
    background-color: #333;
    padding: 12px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.filtros label {
    font-size: 13px;
    font-weight: bold;
    margin-bottom: 4px;
}

.filtros select {
    width: 100%;
    padding: 6px;
    border: 1px solid #555;
    border-radius: 6px;
    background-color: #222;
    color: white;
}

#limparFiltros {
    background-color: #ff4d4d;
    border: none;
    padding: 8px;
    border-radius: 6px;
    font-weight: bold;
    cursor: pointer;
}

#limparFiltros:hover {
    background-color: #e60000;
}
    /* Remove bolinhas e aplica espaçamento no Side Menu */
#sidebar-content ul,
#sidebar-content li {
    list-style: none !important;  /* força remover bullets */
    padding-left: 0 !important;
    margin-left: 0 !important;
}

#sidebar-content ul {
    display: flex;
    flex-direction: column;
    gap: 10px; /* mesmo espaçamento da aba Info */
}
    .sidebar > ul {
    list-style: none;      /* remove bullets */
    padding: 0;            /* elimina recuo padrão */
    margin: 0 0 16px 0;    /* margem inferior opcional */
    display: flex;         /* empilha verticalmente */
    flex-direction: column;
    gap: 10px;             /* espaçamento entre os itens */
}

.sidebar > ul > li {
    margin: 0;             /* garante que não tenha margens extras */
}
    .person-symbols {
    display: flex;
    justify-content: center;
    gap: 6px;
    margin-top: 6px;
}

.symbol-icon {
    width: 40px;
    height: 40px;
    object-fit: contain;
}
    .card-sub{
  font-size: 12px;
  opacity: 0.85;
  margin-top: 2px;
}

/* === LISTA NO Side Menu === */
#charList{
  display: grid;
  grid-template-columns: repeat(2, minmax(50px, 1fr)); /* 2 colunas no menu */
  gap: 10px;
  padding: 0;
  margin: 0;
  list-style: none;
}
/* nova classe para esconder */
#charList.is-hidden { display: none !important; }

/* escalar a imagem ao tamanho da coluna */
#charList .person-card img{
  width: 100%;
  height: auto;          /* mantém proporção */
  display: block;
  border-radius: 8px;
}

/* texto */
#charList .card-name{ margin-top:6px; font-weight:600; text-align:center; }
#charList .card-sub{  font-size:12px; opacity:.85; margin-top:2px; text-align:center; }

/* quando houver mais espaço, aumente o nº de colunas */
@media (min-width: 420px){
  #charList{ grid-template-columns: repeat(3, minmax(50px, 1fr)); }
}
@media (min-width: 560px){
  #charList{ grid-template-columns: repeat(4, minmax(50px, 1fr)); }
}
    #bench-row-wrapper{
  display: flex;
  flex-direction: column;   /* empilha título, slots e toolbar */
  gap: 8px;
}
#bench-row{ order: 1; }
#bench-toolbar{
  order: 2;
  display: flex;
  gap: 10px;
  justify-content: flex-end; /* ou center/space-between */
  margin-top: 45px;
}
/* === ITEMS (Memory + Potential Sets) === */
.item-badge {
  position:absolute; bottom:4px; right:6px;
  background:#111; border:1px solid #666; color:#fff;
  font-size:11px; padding:2px 6px; border-radius:6px; opacity:.9;
  max-width: 90%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
}
.item-modal-backdrop{
  position:fixed; inset:0; background:rgba(0,0,0,.6);
  display:flex; align-items:center; justify-content:center; z-index:5000;
}
.item-modal{
  background:#2b2b2b; color:#fff; width:min(640px,92vw);
  border-radius:12px; padding:14px; box-shadow:0 12px 32px rgba(0,0,0,.5);
}
.item-row{ display:grid; grid-template-columns: 140px 1fr; gap:10px; align-items:center; margin:10px 0; }
.item-modal select{
  width:100%; background:#1f1f1f; color:#fff; border:1px solid #555; border-radius:8px; padding:8px;
}
.item-actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }
.item-btn{
  background:#444; border:1px solid #666; color:#fff;
  padding:8px 10px; border-radius:8px; cursor:pointer;
}
.item-btn:hover{ background:#555; }
.item-stats{
  background:#1e1e1e; border:1px solid #444; border-radius:10px; padding:8px; font-size:13px;
}
.item-stats code{ font-family: ui-monospace, Menlo, Consolas, monospace; }
.item-desc{ opacity:.85; font-size:12px; margin-top:6px; line-height:1.35; }
.hex, .bench-slot { position: relative; } /* ancora do badge/engrenagem */
.item-gear{
  position:absolute; top:4px; right:4px; z-index:5;
  width:22px; height:22px; display:flex; align-items:center; justify-content:center;
  border-radius:999px; background:rgba(20,20,20,.85); border:1px solid #666;
  font-size:14px; cursor:pointer; color:#fff;
}
.item-gear:hover{ background:rgba(40,40,40,.95); }
.item-badge img { width:14px; height:14px; vertical-align:-2px; margin-right:4px; border-radius:3px; }
.item-choice img {
  width:28px; height:28px; border-radius:6px; object-fit:cover;
}
.item-choice.empty { opacity:.6; }
/* Linha no formato: [label] [IMG] [select]  */
.item-row-inline{
  display: grid;
  grid-template-columns: 140px 52px 1fr; /* label | img | select */
  gap: 10px;
  align-items: center;
  margin: 10px 0;
}

/* thumb quadrada */
.item-thumb{
  width: 48px; height: 48px;
  border-radius: 8px;
  background: #2a2a2a;
  object-fit: cover;
  box-shadow: inset 0 0 0 1px #444;
}

/* select estilo “pill” (opcional) */
.item-select{
  width: 100%;
  background:#1f1f1f; color:#fff;
  border:1px solid #555; border-radius:999px;
  padding: 8px 12px;
}

/* descrição fica alinhada sob IMG+select (colunas 2..3) */
.item-subdesc{
  grid-column: 2 / span 2;
  font-size: 12px; opacity: .85; margin-top: 6px;
}
/* --- mais espaço no modal de Items --- */
.item-row-inline{
  display: grid;
  grid-template-columns: 170px 56px 1fr; /* label | IMG | select  (era 140px 52px 1fr) */
  column-gap: 16px;                      /* era 10px */
  row-gap: 8px;
  align-items: start;                    /* evita que label fique baixo */
  margin: 14px 0;                        /* era 10px */
}

/* o texto do rótulo alinhado ao topo da linha (Memory / Potential...) */
.item-row-inline > div:first-child{
  align-self: start;
  padding-top: 4px;
}

/* a miniatura um pouco Mayr */
.item-thumb{
  width: 150px; height: 150px;             /* se quiser mais: 56x56 */
  border-radius: 8px;
  background: #2a2a2a;
  object-fit: cover;
  box-shadow: inset 0 0 0 1px #444;
}

/* select mais “fofo” e com respiro */
.item-select{
  width: 100%;
  background:#1f1f1f; color:#fff;
  border:1px solid #555; border-radius:999px;
  padding: 10px 14px;                    /* era 8px 12px */
}

/* descrição com mais espaço e alinhada sob IMG+select */
.item-subdesc{
  grid-column: 2 / span 2;               /* ocupa coluna da IMG + select */
  margin-top: 8px;                        /* era 6px */
  font-size: 12px; opacity: .85;
}

/* dá um espaço extra entre os blocos */
.item-modal .item-row-inline + .item-row-inline{
  margin-top: 120px;
}
/* === Grid de 2 colunas no modal === */
.item-modal .items-grid{
  display:grid;
  grid-template-columns: 1fr 1fr;           /* coluna esquerda | direita */
  column-gap: 28px;                          /* espaço entre colunas */
  row-gap: 18px;
  align-items:start;
  margin-top: 6px;
}

/* coluna direita ganha um divisor sutil à esquerda */
.item-modal .items-col + .items-col{ position:relative; }
.item-modal .items-col + .items-col::before{
  content:"";
  position:absolute; left:-14px; top:0; bottom:0; width:1px;
  background: rgba(255,255,255,.08);
}

/* linhas internas no formato: label | IMG | select */
.item-row-inline{
  display:grid;
  grid-template-columns: 150px 56px 1fr;     /* label | img | select */
  column-gap: 16px; row-gap: 8px;
  align-items:center;
  margin: 6px 0;
}
.item-row-inline > div:first-child{          /* o rótulo (Memory / Potential...) */
  align-self:start; padding-top: 6px;
}
.item-thumb{
  width: 75px; height: 75px; border-radius: 10px;
  background:#2a2a2a; object-fit:cover;
  box-shadow: inset 0 0 0 1px #444;
}
.item-select{
  width:100%; background:#1f1f1f; color:#fff;
  border:1px solid #555; border-radius:999px;
  padding:10px 14px;
}
.item-subdesc{
  grid-column: 2 / span 2;                   /* fica alinhado sob IMG+select */
  font-size:12px; opacity:.85; margin-top:8px;
}

/* linha “Stats preview” continua em 2 colunas padrão (label | conteúdo) */
.item-row{
  display:grid; grid-template-columns: 150px 1fr;
  column-gap: 16px; align-items:start; margin: 6px 0;
}
/* --- Badge só com ícones --- */
/* === Badge com ícones que se ajustam ao tamanho === */
.item-badge{
  --icon: 37px;                 /* ajuste aqui o tamanho do ícone (18–28px) */
  display:flex; gap:6px; align-items:center;
  position:absolute; bottom:4px; right:6px;
  background:rgba(0,0,0,.60);
  border:1px solid rgba(255,255,255,.25);
  border-radius:8px; padding:3px 6px; z-index:4;
}

/* cada “slot” de ícone */
.item-badge .ico{
  position:relative;
  width:var(--icon); height:var(--icon);
  border-radius:4px; overflow:hidden;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.35);
  background:#222;
}

/* a imagem cobre 100% do slot, sem distorcer */
.item-badge .ico img{
  position:absolute; inset:0;
  width:100% !important;
  height:100% !important;
  object-fit:cover;
  display:block;
}

/* etiqueta “M/4/2” (opcional) escala com o tamanho do ícone */
.item-badge .tag{
  position:absolute; right:-2px; bottom:-2px;
  padding:0 2px;
  font-size:calc(var(--icon) * 0.42);
  line-height:1.05;
  background:rgba(0,0,0,.85); color:#fff;
  border:1px solid rgba(255,255,255,.35); border-radius:3px;
}
/* --- Layout 3 colunas: label | IMG | select --- */
.items-3col{ display:grid; row-gap:18px; }

.row-3col{
  display:grid;
  grid-template-columns: 120px 120px 1fr; /* label | img | select */
  column-gap:18px; align-items:center;
}

.row-3col .label{ align-self:center; padding-top:4px; }

.big-thumb{
  width:120px; height:80px;           /* ajuste como preferir */
  border-radius:10px;
  background:#2a2a2a;
  box-shadow:inset 0 0 0 1px #444;
  object-fit:cover;
}

.select-wide{
  width:100%; background:#1f1f1f; color:#fff;
  border:1px solid #555; border-radius:10px;
  padding:10px 12px;
}

.subdesc{ font-size:12px; opacity:.85; margin-top:8px; }

/* Stats em lista vertical */
.stats-list{ list-style:none; margin:0; padding:0; }
.stats-list li{
  margin:6px 0;
  font-family:ui-monospace, Menlo, Consolas, monospace;
  background:#1e1e1e; border:1px solid #444; border-radius:10px;
  padding:6px 10px;
}
.stats-list li b{ margin-right:6px; }
.hex.drop-ok, .bench-slot.drop-ok { outline: 2px dashed #9cf; }
.hex.drop-bad, .bench-slot.drop-bad { outline: 2px dashed #f66; }
/* título + badge lado a lado */
.synergy-header{ display:flex; align-items:baseline; gap:12px; margin-bottom:8px; }
.team-type-badge{ font-size:.95rem; font-weight:600; opacity:.9; }
.multi-teams{ display:flex; align-items:center; gap:10px; margin:10px 0 16px; }
.team-tabs{ display:flex; gap:8px; flex-wrap:wrap; }
.team-tab{
  padding:6px 12px; border-radius:9999px; border:1px solid #444;
  background:#2a2a2a; color:#ddd; cursor:pointer; font-weight:600;
}
.team-tab.active{ background:#3a3a3a; border-color:#666; }
.add-team{
  padding:6px 10px; border-radius:8px; border:1px solid #444;
  background:#2f6; color:#000; font-weight:700; cursor:pointer;
}
.team-tab.editing{ pointer-events:auto; }
.team-tab-edit{
  width:120px; max-width:160px;
  background:transparent; color:inherit;
  border:1px dashed #777; border-radius:9999px;
  padding:4px 8px; outline:none; font:inherit; font-weight:600;
}
.multi-teams, #teamBar {
  display: flex;
  justify-content: center;   /* <— centraliza horizontalmente */
  align-items: center;
  gap: 10px;
  margin: 10px 0 16px;
}
    /* impede scroll no fundo quando o modal está aberto */
body.modal-open {
  overflow: hidden;
}

/* backdrop já é fixed e centraliza; só adiciono padding e contenção de overscroll */
.item-modal-backdrop{
  position:fixed; inset:0;
  background:rgba(0,0,0,.6);           /* alpha válido (antes estava 6) */
  display:flex; align-items:center; justify-content:center;
  padding:16px;                         /* respiro nas bordas em zoom alto */
  overscroll-behavior: contain;         /* evita “vazar” scroll para o body */
  z-index:5000;
}

/* painel do modal com limite de altura e rolagem própria */
.item-modal{
  background:#2b2b2b; color:#fff;
  width:min(640px,92vw);
  border-radius:12px; padding:14px;
  box-shadow:0 12px 32px rgba(0,0,0,.5);

  max-height: calc(100dvh - 32px);      /* cabe na tela */
  overflow: auto;                        /* rola por dentro */
}
/* fallback para navegadores sem dvh */
@supports not (height: 100dvh){
  .item-modal{ max-height: calc(100vh - 32px); }
}

/* barra de botões sempre visível no rodapé do modal */
.item-actions{
  position: sticky;
  bottom: 0;
  background: rgba(43,43,43,.95);
  border-top: 1px solid #444;
  margin-top:12px;
  padding:8px 0;
  display:flex; gap:8px; justify-content:flex-end;
}
.recommend-panel{
  display:flex; flex-direction:column; gap:8px; 
  align-items:center; margin:10px 0 16px;
}
.recommend-panel .row{ display:flex; flex-wrap:wrap; gap:12px; align-items:center; justify-content:center; }
.recommend-panel label{ color:#ddd; font-weight:600; display:flex; gap:6px; align-items:center; }
.recommend-panel input[type="range"]{ width:120px; }
.recommend-panel button{
  padding:6px 12px; border-radius:10px; border:1px solid #444;
  background:#40f06a; color:#000; font-weight:800; cursor:pointer;
}
.recommend-bar{ display:flex; justify-content:center; margin:6px 0 10px; }

.recommend-panel{
  display:none;                     /* oculto por padrão */
  flex-direction:column; gap:8px;
  align-items:center; margin:6px 0 16px;
  padding:10px; border:1px solid #444; border-radius:10px; background:#2a2a2a;
}
.recommend-panel.open{ display:flex; }  /* abre quando adicionamos .open */

.recommend-panel .row{ display:flex; flex-wrap:wrap; gap:12px; align-items:center; justify-content:center; }
.recommend-panel label{ color:#ddd; font-weight:600; display:flex; gap:6px; align-items:center; }
.recommend-panel input[type="range"]{ width:120px; }

.recommend-bar button,
.recommend-panel button{
  padding:6px 12px; border-radius:10px; border:1px solid #444;
  background:#40f06a; color:#000; font-weight:800; cursor:pointer;
}
.type-prefs{ border:1px solid #444; border-radius:8px; padding:6px 10px; }
.type-prefs legend{ padding:0 6px; font-size:.9rem; color:#bbb; }
.type-prefs label{ font-weight:500; }
.banner-img{
  width: 40px; height: 40px; object-fit: contain;
  background:#0003; border-radius:8px; border:1px solid #3a3a3a; display:block;
}
/* collapse da coluna esquerda */
body.planner-collapsed .panel.sources { display:none !important; }
body.planner-collapsed .planner-wrap { grid-template-columns: 1fr !important; }

/* botão compacto */
.btn.mini{ padding:4px 8px; font-size:.85rem; border-radius:7px; }
/* reserva largura para a coluna System */
#tblFree td.col-System, #tblFree th.col-System { width: 260px; }
#tblCash td.col-System, #tblCash th.col-System { width: 260px; }

/* inputs de texto com largura mínima e sem cortar texto */
.grid-table input[type="text"]{
  min-width: 240px;      /* garante leitura */
  white-space: nowrap;   /* não quebra no meio */
  text-overflow: clip;   /* sem "..." cortando */
  overflow: visible;
}
/* container por mês */
.month-group{ margin:14px 0 18px; }
.month-title{ font-weight:800; margin:0 0 8px; opacity:.9; }


/* cartão */
.banner-card{
  background:#1e1e1e; border:1px solid #3a3a3a; border-radius:12px; padding:10px;
}
.banner-card h5{ margin:0 0 6px; font-size:.95rem; opacity:.9; }
.banner-card img{ width:160px; height:210px; object-fit:cover; display:block; border-radius:10px; border:1px solid #3a3a3a; }
.banner-fields label{ display:block; font-size:.95rem; margin-top:6px; }
.banner-fields input{ width:100%; background:#1d1d1d; color:#fff; border:1px solid #555; border-radius:8px; padding:6px 8px; }

.rebanner-col{ grid-column: 1 / -1; display:flex; justify-content:center; }
/* Reabrir fontes quando colapsado */
#reopenSources {
  position: fixed; left: 14px; bottom: 18px; z-index: 10000;
  background:#ffd54f; color:#222; border:0; font-weight:800;
  padding:8px 12px; border-radius:10px; cursor:pointer;
  box-shadow:0 3px 0 rgba(0,0,0,.25); display:none;
}
body.planner-collapsed #reopenSources { display:block; }

/* Coluna central de rebanners pode ter 1..N cartões empilhados */
.rebanner-col { grid-column: 1 / -1; display:flex; flex-direction:column; gap:18px; align-items:center; }

/* Linhas informativas (Tickets/Memórias/Cashback) no cartão */
.banner-lines { margin-top:10px; font-weight:700; line-height:1.6; }
.banner-lines span { display:block; }

.banner-card img{ display:block; margin:0 auto; }
body.planner-collapsed .panel.sources{ display:none !important; }
body.planner-collapsed .planner-wrap{ grid-template-columns: 1fr  }

.rebanners-row{ display:flex; gap:18px; justify-content:center; }
/* Alinha o botão à direita no cabeçalho do painel */
#synergy-panel .synergy-header{ justify-content: space-between; }

/* Lista dentro do modal (apresentação dos bonds) */
.stats-bond-list{ background:#2a2a2a; border:1px solid #444; border-radius:10px; padding:10px; }
.stats-bond-item{ margin:10px 0; }
.stats-bond-item h4{ margin:0 0 6px; font-size:1rem; }
.stats-bond-item ul{ margin:0; padding-left:16px; }
.stats-bond-item li{ margin:4px 0; font-family: ui-monospace, Menlo, Consolas, monospace; }
/* --- Stats bonds (modal) --- */
.stats-bond-item ul li{display:flex;align-items:center;gap:8px;margin:6px 0;}
.stats-char-thumb{width:28px;height:28px;border-radius:50%;object-fit:cover;border:1px solid #444}

/* ações no rodapé do modal */
.item-actions{display:flex;gap:8px;justify-content:flex-end;align-items:center}

/* picker de “personagens da conta” */
.owned-picker{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:8px;
  max-height:50vh;overflow:auto;margin-top:8px}
.owned-card{display:flex;gap:8px;align-items:center;padding:6px;border:1px solid #555;border-radius:10px}
.owned-card input{margin-left:auto}

/* pills de Stat Bonds no painel lateral */
.pill{display:inline-block;padding:4px 10px;border-radius:14px;border:1px solid #666;
  cursor:pointer;margin:3px 4px;font-size:.95em;background:#222}
.pill:hover{background:#2a2a2a}
.subdesc{opacity:.9;margin-top:8px}
/* Cabeçalho de cada bond + botão See details */
.stats-bond-head{display:flex;justify-content:space-between;align-items:center;gap:8px}
.see-details-btn{font-size:.85em;padding:3px 8px;border:1px solid #666;border-radius:8px;background:#222;cursor:pointer}
.see-details-btn:hover{background:#2a2a2a}

/* Lista de personagens "faltando" (fora do time) */
.missing-char{color:#ff5c5c;font-style:italic}
/* Deixa o planner idêntico aos outros botões do menu */
#sidebar #openPlannerBtn,
#openPlannerBtn.menu-link.bond-btn{
  background-color:#444;
  color:#fff;
  border:1px solid #666;
  border-radius:6px;
  padding:4px 8px;
  font-size:14px;
  cursor:pointer;
  transition:background-color .2s, transform .2s;
  box-shadow:none;
  font-weight:normal;
}
#sidebar #openPlannerBtn:hover{ background-color:#666; transform:scale(1.05); }
#sidebar #openPlannerBtn:active{ background-color:#888; transform:scale(.98); }
/* === Planner em tela cheia === */
#pagePlanner{
  position: fixed;      /* vira um overlay */
  inset: 0;             /* top/right/bottom/left = 0 */
  width: 100vw;
  height: 100vh;
  margin: 0;
  padding: 16px clamp(12px,2vw,24px) 24px;
  background: #121212;  /* usar a cor do seu tema, se tiver variável */
  z-index: 999;         /* acima do restante da UI */
  overflow: auto;       /* rolagem interna */
}

/* evita “caixa” estreita por max-width herdado */
#pagePlanner .container,
#pagePlanner .planner-box,
#pagePlanner .planner-wrap,
#pagePlanner .planner-grid{
  max-width: none !important;
  width: 100% !important;
}

/* mantém cabeçalho/toolbar visível enquanto rola o planner */
#pagePlanner .planner-header{
  position: sticky;
  top: 0;
  z-index: 1;
  background: inherit;
  padding-bottom: 8px;
}

/* quando o planner está aberto, trava o scroll do body atrás */
body.planner-open{ overflow: hidden; }
/* ===== Planner: layout em duas colunas ===== */
#pagePlanner .planner-two-col{
  display: grid;
  grid-template-columns: minmax(640px, 1fr) minmax(360px, 30vw);
  gap: 16px;
  align-items: start;
}

/* permite o conteúdo da coluna esquerda encolher corretamente */
#pagePlanner .planner-main{ min-width: 0; }

/* Simulação fixa ao rolar (dentro do overlay fullscreen) */
#pagePlanner .planner-sim{
  position: sticky;
  top: 12px;                 /* ajuste se tiver header fixo Mayr */
  max-height: calc(100vh - 24px);
  overflow: auto;
  /* aparência opcional */
  background: #1a1a1a;
  border: 1px solid #333;
  border-radius: 12px;
  padding: 12px;
}

/* cards/linhas de mês ocupam toda a largura disponível */
#plannerMonths > *{ width: 100%; }

/* responsivo: empilha em telas menores */
@media (max-width: 1100px){
  #pagePlanner .planner-two-col{
    grid-template-columns: 1fr;
  }
  #pagePlanner .planner-sim{
    position: static;
    max-height: none;
  }
}
.banner-card{
  width: 320px;          /* mesma idea do .rebanner-card */
  margin: 0 auto;        /* centraliza dentro da coluna */
  flex: 0 0 320px;       /* evita “esticar” */
}
@media (max-width: 1200px){
  .banner-card{ width: 280px; } /* opcional, igual aos rebanners menores */
}
/* ===== Modal genérica ===== */
.modal-overlay{
  position: fixed; inset: 0; display: none;
  align-items: center; justify-content: center;
  z-index: 2000;  /* acima do planner */
}
.modal-overlay.open{ display: flex; }
.modal-backdrop{
  position: absolute; inset: 0; background: rgba(0,0,0,.55);
}
.modal-dialog{
  position: relative;
  width: clamp(780px, 80vw, 1100px);
  max-height: 90vh;
  background: #1b1b1b;
  border: 1px solid #333; border-radius: 14px;
  box-shadow: 0 20px 60px rgba(0,0,0,.6);
  overflow: hidden; display: flex; flex-direction: column;
}
.modal-header{
  display: flex; justify-content: space-between; align-items: center;
  padding: 10px 14px; background: #222; border-bottom: 1px solid #333;
  position: sticky; top: 0; z-index: 1;
}
.modal-body{
  padding: 12px; overflow: auto;
  max-height: calc(90vh - 56px);
}

/* trava scroll atrás da modal */
body.modal-open{ overflow: hidden; }

/* quando o painel está dentro da modal, deixe ele ocupar 100% */
.modal-body .panel.sources{ margin: 0; width: 100%; box-sizing: border-box; }
/* Alternador de servidor (JP / CN) */
.server-switch{
  display:flex; gap:8px; justify-content:center; margin:6px 0 12px;
}
.server-btn{
  background:#2a2a2a; color:#ddd; border:1px solid #444;
  padding:6px 12px; border-radius:10px; cursor:pointer; font-weight:700;
}
.server-btn:hover{ background:#333; border-color:#666; color:#fff; }
.server-btn.active{ background:#3a3a3a; border-color:#777; color:#fff; }
/* Grade fluida: cabe 1 ou 2 cards por linha conforme espaço disponible */
.month-row{
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(var(--card-w), 1fr));
  gap: 16px 24px;               /* gap menor ajuda a fechar com a Simulação */
  align-items: start;
}
.rebanner-card{ width: var(--card-w); }
/* Reduz larguras só nos campos do painel de Simulação */
#simPane #simInputs label { display: flex; align-items: center; gap: 10px; }

/* Garante que estes inputs não ocupem 100% da coluna */
#simPane #simInputs input { width: auto; }

/* Larguras finais: número e data */
#simPane #simInputs .planner-input[type="number"] { width: 140px; }   /* Saldo inicial */
#simPane #simInputs .planner-input[type="date"]   { width: 170px; }   /* Data de início */


/* WIN 999 DIAMONDS */
.win-diamonds-btn {
  position: fixed;       /* recalculo a posição perto do grid via JS */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 300px;
  height: 144px;
  padding: 0 18px;
  border-radius: 14px;
  background: linear-gradient(180deg, #1ee196 0%, #12b886 100%);
  color: #0b0b0b;
  font-weight: 800;
  font-size: 18px;
  letter-spacing: .3px;
  border: none;
  box-shadow: 0 10px 24px rgba(0,0,0,.35), inset 0 -2px 0 rgba(0,0,0,.25);
  cursor: pointer;
  z-index: 9999;
  transition: transform .08s ease, box-shadow .08s ease, opacity .2s ease;
}
.win-diamonds-btn:hover { transform: translateY(-1px); }
.win-diamonds-btn:active { transform: translateY(0); box-shadow: 0 6px 18px rgba(0,0,0,.35); }

@media (max-width: 900px){
  /* em telas menores, fixa no canto inferior direito */
  .win-diamonds-btn {
    right: 16px !important;
    bottom: 16px !important;
    left: auto !important;
    top: auto !important;
  }
}
.mini-line{ display:inline-flex; gap:4px; vertical-align:middle; margin-right:6px; }
.mini-char{ width:24px; height:32px; object-fit:cover; border-radius:4px; box-shadow:0 0 0 1px #444; }
.top-row-li{ display:flex; align-items:center; gap:6px; justify-content:center; }
.btn-more{ background:#2a2a2a; color:#ddd; border:1px solid #555; border-radius:8px; padding:2px 8px; cursor:pointer; }
.btn-imp,.btn-cmt{ margin-left:4px; }
.char-row { display:flex; align-items:center; justify-content:space-between; gap:.5rem; }
.char-row .mini-line { display:flex; align-items:center; gap:.5rem; }
.char-row .char-name { opacity:.9; }
</style>
</head>
<body>

<button id="menuBtn">☰</button>
<div class="sidebar" id="sidebar">
    <button class="close-btn" id="closeSidebar">×</button>
    <h2>Side Menu</h2>
    <ul>
      <div id="view-stats" style="display:flex;gap:16px;justify-content:center;align-items:center;margin-top:6px;opacity:.95">
  <span>Daily Views: <strong id="visits-today">—</strong></span>
  <span>Total: <strong id="visits-total">—</strong></span>
</div>
        <!-- substituí EStatísticas por Save/Load -->
        <li><button class="menu-link bond-btn" data-section="save">💾 Save & Load Teams</button></li>
        <li><button class="menu-link bond-btn" data-section="characters">🔍 Characters</button></li>
        <li><button class="menu-link bond-btn" data-section="schools">🏫 Schools</button></li>
        <li><button class="menu-link bond-btn" data-section="help">ℹ️ Info</button></li>
        <li><button id="openPlannerBtn" class="menu-link bond-btn">💎 Resource Planner</button></li>
        <li><button id="btnOpenRanking" type="button" data-sidebar-safe="true">🏆 Ranking</button></li>
      </ul>
    <div id="sidebar-content">
        <p>Select an option above.</p>
    </div>
</div>

<h1>Haikyu Fly High - Team Builder by Devoy Aces</h1>


<div id="multiTeams" class="multi-teams">
  <div id="teamTabs" class="team-tabs"></div>
  <button id="addTeamBtn" class="add-team" type="button">+ Team</button>
</div>

<div class="team-grid">
    <div class="row top-row">
        <div class="player-slot"><div class="hex" data-role="S"></div><div class="player-info">S</div></div>
        <div class="player-slot"><div class="hex" data-role="MB"></div><div class="player-info">MB</div></div>
        <div class="player-slot"><div class="hex" data-role="WS"></div><div class="player-info">WS</div></div>
    </div>
    <div class="row">
        <div class="player-slot"><div class="hex" data-role="L"></div><div class="player-info">L</div></div>
        <div class="player-slot"><div class="hex" data-role="WS"></div><div class="player-info">WS</div></div>
        <div class="player-slot"><div class="hex" data-role="MB"></div><div class="player-info">MB</div></div>
        <div class="player-slot"><div class="hex" data-role="OP"></div><div class="player-info">OP</div></div>
    </div>

    <!-- linha onde fica o botão SALVAR e os bench slots -->
    <div class="row" id="bench-row-wrapper" style="align-items:center;">

        <div class="row" id="bench-row" style="gap:10px;">
            <div class="player-slot bench"><div class="bench-slot" data-role="bench"></div><div class="player-info">Bench</div></div>
            <div class="player-slot bench"><div class="bench-slot" data-role="bench"></div><div class="player-info">Bench</div></div>
            <div class="player-slot bench"><div class="bench-slot" data-role="bench"></div><div class="player-info">Bench</div></div>
            <button class="add-slot-btn" onclick="addBenchSlot()">+</button>
        </div>
         <div id="bench-toolbar" style="display:flex; align-items:center; gap:10px; margin-top:8px;">
    <button id="rotateBtn" title="Rotate clockwise" style="background-color:#222222;color:white;padding:6px 10px; border:none; border-radius:5px; font-size:16px; cursor:pointer;margin-right:8px;">↻</button>
    <button id="saveTeamBtn" title="Save Team" style="background-color:#222222;margin-right:8px;">⬇️</button>
    <button id="clearTeamBtn" title="Clear Team" style="background-color:#222222; color:white; padding:6px 10px; border:none; border-radius:5px; font-size:16px; cursor:pointer;margin-right:55px;">🗑️</button>
    <button id="recommendBtn" title="Recommend based on highest synergies possible"style="background-color:#222222; color:white; padding:6px 10px; border:none; border-radius:5px; font-size:16px; cursor:pointer;margin-right:55px;">⭐</button>
</div>
    </div>
</div>

<!-- Painel de sliders (inicialmente oculto) -->
<div id="recoPanel" class="recommend-panel">
  <div class="row">
    <label>Sinergias
      <input id="wSynergy" type="range" min="0" max="5" step="0.5" value="3">
      <span id="wSynergyVal">3</span>
    </label>
    <label>Âncora
      <input id="wAnchor" type="range" min="0" max="5" step="0.5" value="1">
      <span id="wAnchorVal">1</span>
    </label>
    <label>Tipo do time
      <input id="wTeamType" type="range" min="0" max="5" step="0.5" value="1.5">
      <span id="wTeamTypeVal">1.5</span>
    </label>
    <label>Stats
      <input id="wStats" type="range" min="0" max="5" step="0.5" value="1">
      <span id="wStatsVal">1</span>
    </label>
  </div>
  <div class="row">
  <label><input id="allowCrossRole" type="checkbox" checked> Permitir cross-role (exceto L)</label>

  <fieldset class="type-prefs">
    <legend>Tipo do time</legend>
    <label><input type="checkbox" id="prefQuick"> Quick</label>
    <label><input type="checkbox" id="prefPower"> Power</label>
    <label><input type="checkbox" id="prefBlock"> Block</label>
    <label><input type="checkbox" id="prefReceive"> Reception</label>
  </fieldset>

  <button id="runRecommendBtn" type="button">Aplicar</button>
  <button id="closeRecoBtn" type="button">Fechar</button>
</div>
</div>

<div class="scroll-menu" id="scrollMenu"></div>

<div id="synergy-panel">
  <div class="synergy-header" style="justify-content:space-between;">
    <h2>Synergies</h2>
    <button id="statsBondBtn" class="btn mini" type="button" title="Mostrar vínculos de stats">
      Stats bonds
    </button>
  </div>
  <ul id="synergy-list">
    <li>Only Deployment Synergies are displayed.Synergies will only work when players are in court inside the game.</li>
  </ul>
</div>
<script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script> <script> kofiWidgetOverlay.draw('gondif', { 'type': 'floating-chat', 'floating-chat.donateButton.text': 'Support Us', 'floating-chat.donateButton.background-color': '#794bc4', 'floating-chat.donateButton.text-color': '#fff' });
</script>
<script>
/* ====== DADOS (mantidos) ====== */
const characters = [
{ nome: "Kageyama UR",data: "01/12/26", funcao: "S", img: "img/kageyamaUR.png", School: "Karasuno", vinculo: ["Eccentric Duo", "Karasuno Geniusars","King and Great King"], Stats:{Serve:1782,Spike:1948,Set:1911,Receive:1625,Block:1709,Save:1539}, habilidades:[{nome:"Genius Setter",descricao:"Kageyama Tobio sets with a power of [Set] x 120/135/150%. When he sets, the [Quick Attack] of the member who spikes is increased by his [Set] x 15%. This effect lasts until the ball goes over the net."},{nome:"Murder Serve",descricao:"Kageyama Tobio performs a powerful jump serve with a power of 130/145/160% of his [Serve]. If this play is a perfect serve, his teammates’ [Attack Technique] is increased by 10%. This effect lasts until the ball has crossed the net 6 times."},{nome:"Silent King",descricao:"Increases Kageyama Tobio’s [Attack Technique] by 8/10/12%. When he is on the court and the opponent’s Serve, Quick Attack, or Spike is a nice play, he gains 1 stack of the [Competitive Spirit] effect. Up to 5 stacks. When he is on the court and an ally Serves, Quick Attacks, or Spikes, 1 stack of [Competitive Spirit] effect is consumed, and the [Awareness] of the member performing the Serve, Quick Attack, or Spike is increased by 20/25/30%. This effect lasts until the ball goes over the net twice. At the start of a rally, he will gain one stack of the [Competitive Spirit] effect."},{nome:"Dominate the Game",descricao:"Kageyama Tobio performs a Quick Attack with a power equal to 240/255/270/285/300% of the set. The Quick Attack cannot be blocked. The cooldown of the opponent’s frontline block skill during the cooldown increases by 4 times the number of times the ball goes over the net."}], symbols: [ "img/quicksymbol.png", "img/servesymbol.png", "img/settersymbol.png" ] },
{ nome: "Kageyama SSR", funcao: "S", img: "img/kageyamaSR.png", School: "Karasuno", vinculo: [],Stats:{Serve:1314,Spike:1246,Set:1378,Receive:1115,Block:1246,Save:1047},habilidades:[{nome:"Manipulate the Moment",descricao:"When Hinata Shoyo (Flower Viewing) is on the court, the [Defensive Technique] of all front line players is increased by 10/13/16%. When Hinata Shoyo makes a nice play, his [Offensive Technique] is increased by 3/3.5/4%. Up to 4 stacks."},{nome:"Stepping Stone",descricao:"Hinata Shoyo (Flower Viewing) receives a ball with 140/160/180% of his receive Stat, and allies’ base Stats increase by 12%. This effect for 6 net crossings."},{nome:"Counterattack",descricao:"When Hinata Shoyo (Flower Viewing) is in the back row, the [Defensive Technique] of allied back row players is increased by 10/13/16%. When Hinata Shoyo (Flower Viewing) is on the court and the team’s receive result is not BAD, his [Quick Attack] Stat is increased by 12/16/20% for the next two net crossings. If the teammate’s receive is a PERFECT play, Hinata Shoyo’s (Flower Viewing) quick attack after this play occurs is increased by 100%."},{nome:"Jump High",descricao:"Hinata Shoyo (Flower Viewing) performs a quick attack with 260/275/290% of [Quick Attack] as power. If this play is a nice play, the power increases by an additional [Quick Attack] x 40/45/50%."}], symbols: [ "img/quicksymbol.png", "img/servesymbol.png", "img/settersymbol.png" ] },
{ nome: "Hinata SP",data: "01/27/26", funcao: "MB", img: "img/hinataSP.png", School: "Karasuno", vinculo: ["Eccentric Duo", "Cherry Blossom Viewing" , "Sun vs Moon"],Stats:{Serve:1673,Spike:1950,Set:1656,Receive:1913,Block:1774,Save:1656},habilidades:[{nome:"Manipulate the Moment",descricao:"When Hinata Shoyo (Hanami) is on the court, the [Defensive Technique] of all front line players is increased by 10/13/16%. When Hinata Shoyo's play result is Perfect, his [Offensive Technique] is increased by 3/3.5/4% with a maximum of 4 stacks."},{nome:"A Foot Hold (such a sick reference to his receive)",descricao:"Hinata Shoyo (Hanami) receives a ball with 140/160/180% of [Receive] as power, and your team's base Stats increase by 12%. This effect for 6 net crossings."},{nome:"Counterattack",descricao:"When Hinata Shoyo (Hanami) is in the back row, the [Defensive Technique] of allied back row players is increased by 10/13/16%. When Hinata Shoyo (Hanami) is on the court and the team's receive result is not BAD, his [Quick Attack] Stat is increased by 12/16/20% for the next two net crossings. If the teammate's receive is a PERFECT play, Hinata Shoyo's (Hanami) quick attack after this play occurs is increased by 100%."},{nome:"High Jump",descricao:"Hinata Shoyo (Hanami) performs a quick attack with 260/275/290% of [Quick Attack] as power. If this play is Perfect, the power increases by an additional 40/45/50% of [Quick Attack]."}], symbols: [ "img/quicksymbol.png", "img/receivesymbol.png" ] },
{ nome: "Hinata SSR", funcao: "MB", img: "img/hinataSR.png", School: "Karasuno", vinculo: ["Eccentric Duo"],Stats:{Serve:1173,Spike:1383,Set:1118,Receive:1195,Block:1250,Save:1253},habilidades:[{nome: "THE GREATEST DECOY", descricao:"While SHOYO HINATA is present, increases Power/Quick Attack Stat of players on your side by 7%"}, {nome: "QUICK DUO", descricao:"When SHOYO HINATA performs a Quick Attack and the setter is a Quick Attack-type player, increases this spike's power by 15% of that setter's Quick Attack Stat."}, {nome: "ON THE BALL", descricao:"Increases SHOYO HINATA's Awareness by 6%. When HINATA lands a Critical hit, additionally increases Awareness by 4%, stacking up to 1 times."}, {nome: "SOARING TEEN", descricao:"SHOYO HINATA performs a Quick Attack with 235% of his Quick Attack Stat as power. If this spike is a Critical hit, increases its power by an additional 20% of his Quick Attack Stat."}], symbols: [ "img/quicksymbol.png" ] },
{ nome: "Nishinoya SP",data: "03/13/26", funcao: "L", img: "img/nishinoyaSP.png", School: "Karasuno", vinculo: ["Karasuno Geniusars", "After School"],Stats:{Serve:1615,Spike:1615,Set:1851,Receive:1969,Block:1577,Save:1854},habilidades:[{nome:"World-Class Acceleration",descricao:"Nishinoya Yu (After School)'s [Reflex] is increased by 10%/13%/16%. When an opposing team member makes a Perfect play, Nishinoya Yu (After School)'s [Reflex] is increased by 1.5%. Stacks up to 10 times. This effect lasts until the ball goes over the net 6 times."},{nome:"A-Pass",descricao:"Nishinoya Yu (After School) sets the ball with 140%/160%/180% of [Set] as power. Nishinoya Yu (After School)'s [Attention] increases by 100% of [Reflex] as power. This effect lasts for two net crossings."},{nome:"Save the Team in Crisis",descricao:"Nishinoya Yu (After School)'s [Spirit] is increased by 20%/25%/30%. When an ally makes a perfect play, the cooldown of Foot Receive is reduced by one time the ball goes over the net."},{nome:"Foot Receive",descricao:"Nishinoya Yu (After School) performs a receive with 260%/275%/290% of [Receive] as power. Nishinoya Yu (After School)'s [Receive] is increased by 20%. This effect lasts for two net crossings."}], symbols: [ "img/receivesymbol.png", "img/settersymbol.png" ] },
{ nome: "Nishinoya SSR", funcao: "L", img: "img/nishinoyaSR.png", School: "Karasuno", vinculo: ["Guardian God and Wing Spiker" , "Kiyoko Squad"],Stats: { Serve:1131, Spike:1131, Set:1254, Receive:1389, Block:1098, Save:1327 },habilidades:[{nome: "GUARDIAN DEITY", descricao:"When YU NISHINOYA's Save result is not BAD, increases the power of the next Power Spike skill usard by your Power-type player by 15% of his Power Attack Stat"}, {nome: "LIBERO SUPREME", descricao:"YU NISHINOYA performs a Save with 120% of Save Stat as power"}, {nome: "INSPIRE MORALE", descricao:"When YU NISHINOYA enters the court, increases your Team Morale by 18"}, {nome: "ROLLING THUNDER", descricao:"YU NISHINOYA consumes 20 additional Stamina to perform a Receive with 220% of Receive Stat power; if the Receive result is not BAD, reduces the cooldown of your side's next Power Spike skill by 6 net crossings"}], symbols: [ "img/receivesymbol.png" ] },
{ nome: "Tanaka SSR", funcao: "WS", img: "img/tanakaSR.png", School: "Karasuno", vinculo: ["Kiyoko Squad"],Stats: { Serve:1190, Spike:1385, Set:1120, Receive:1316, Block:1248, Save:1129 }, habilidades:[{nome: "THE ACE ARRIVES", descricao:"Increases the power of RYUNOSUKE TANAKA's 1st Power Spike in each match by 25% of Power Attack Stat"}, {nome: "TENACIOUS SPIRIT", descricao:"RYUNOSUKE TANAKA performs a Receive with 115% of Receive Stat as power; for this Receive, TANAKA's Reflex increases by 10%"}, {nome: "BURNING PASSION", descricao:"Increases RYUNOSUKE TANAKA's Power Spike power by 10% of Power Attack Stat; his Power Spike reduces opponent's blocking and receiving players' Stamina by 5"}, {nome: "SUPER INNER CROSS", descricao:"RYUNOSUKE TANAKA consumes 5 extra Stamina to perform a Short Diagonal Spike with 250% of Power Attack Stat as power; when this is TANAKA's first spike in this set, increases spike power by an additional 30% of TANAKA's Power Attack Stat"}], symbols: [ "img/powersymbol.png" ] },
{ nome: "Tsuki SP", funcao: "MB", img: "img/tsukiSP.png", School: "Karasuno", vinculo: ["Sun vs Moon","Fireworks Festival","Teammates At Training Camp"],Stats:{Serve:1685,Spike:1968,Set:1669,Receive:1759,Block:1789,Save:1774}, habilidades:[{nome:"Great Brain",descricao:"When a member on the opponent's court is under an unfavorable effect, Tsukishima Kei (Fireworks Festival)'s [Awareness] and [Reflex] are increased by 15%/20%/25%, and allied members' [Offensive Technique] and [Defensive Technique] are increased by 10%. This effect lasts for 1 rally. When an ally activates a block skill, Tsukishima Kei's (Fireworks Festival) [Quick Attack] is increased by 3%. Up to 10 stacks. When an ally's quick attack skill is activated, Tsukishima Kei's (Fireworks Festival) [Block] is increased by 3%. Up to 10 stacks."},{nome:"Block is a System",descricao:"Tsukishima Kei (Fireworks Festival) Blocks with the power of [Lock] x 300%/325%/350%. Increases the [Reflex] of allied rear guards by 10% and [Spirit] by 20%. This effect lasts until the ball crosses the net twice."},{nome:"Calmly Watch the Battle Situation",descricao:"At the start of the match, if Tsukishima Kei (Fireworks Festival)'s [Attack Technique] is equal to or greater than [Defensive Technique], he gains the [Attack I/II/III] effect. If [Defensive Technique] is greater than [Attack Technique], he gains the [Defensive I/II/III] effect. If you have the [Attack I/II/III] effect, the cooldown of 'Block is a System' is reduced by 4 times the number of times the ball has gone over the net. The power of 'Block is a System' is reduced by [Block] x 100%/80%/60%. [Quick Attack] is reduced by 20/30/40."},{nome:"Spikes that make usar of his height",descricao:"Tsukishima Kei (Fireworks Festival) performs a quick attack with a power of [Quick Attack] x 260%/280%/300%/320%/340%. If a member on the opponent's court has an adverse effect, the power of this quick attack increases by [Quick Attack] x 60%."}], symbols: [ "img/quicksymbol.png", "img/blocksymbol.png" ] },
{ nome: "Tsuki SSR", funcao: "MB", img: "img/tsukiSR.png", School: "Karasuno", vinculo: [],Stats: { Serve:1210, Spike:1314, Set:1153, Receive:1173, Block:1389, Save:1102 }, habilidades:[{nome: "KARASUNO'S COMPOSURE", descricao:"While KEI TSUKISHIMA is on the court, increases the Strength of your Quick Attack-type players by 10%"}, {nome: "TACTICAL QUICK ATTACK", descricao:"KEI TSUKISHIMA performs a Quick Attack with 115% of his Quick Attack Stat. The next time a teammate casts a Spike skill, their Awareness is increased by 5%"}, {nome: "MOONRISE", descricao:"While KEI TSUKISHIMA is present, increases Block power of your side's front row players by 8% of their Block Stat"}, {nome: "KEI'S RETORT", descricao:"KEI TSUKISHIMA performs a Block with 195% of his Block Stat as power. Applies the \"Enrage\" debuff to the opposing spiker (reducing their Power/Quick Attack Stats by 10%)"}], symbols: [ "img/quicksymbol.png", "img/blocksymbol.png" ] },
{ nome: "Daichi SSR", funcao: "OP", img: "img/daichiSR.png", School: "Karasuno", vinculo: [],Stats: { Serve:1182, Spike:1250, Set:1123, Receive:1385, Block:1248, Save:1191 }, habilidades:[{nome: "STEADY RECEPTION", descricao:"When DAICHI SAWAMURA performs a Receive, restores 3 Stamina to the teammate with the lowest Stamina."}, {nome: "SLEDGEHAMMER SPIKE", descricao:"DAICHI SAWAMURA performs a Power Spike with 120% of his Power Attack Stat."}, {nome: "TEAM BACKBONE", descricao:"While DAICHI SAWAMURA is present, increases receive power of your side's back row players by 10% of their Receive Stat"}, {nome: "RELIABLE DEFENSE", descricao:"DAICHI SAWAMURA performs a Receive with 220% of his Receive Stat. If your side's next Spike is a Power Spike, increases that spike's power by 15% of the spiker's Power Attack Stat."}], symbols: [ "img/receivesymbol.png" ] },
{ nome: "Azumane SSR", funcao: "WS", img: "img/azumaneSR.png", School: "Karasuno", vinculo: ["Guardian God and Wing Spiker"],Stats: { Serve:1322, Spike:1387, Set:1118, Receive:1254, Block:1190, Save:1122 }, habilidades:[{nome: "PROFICIENT DEFENSE", descricao:"ASAHI AZUMANE performs a Receive with 120% of Receive Stat as power"}, {nome: "BULLET SERVE", descricao:"ASAHI AZUMANE performs a Jump Serve with 120% of Serve Stat as power"}, {nome: "ACE'S AURA", descricao:"When ASAHI AZUMANE's Stamina is above 70, increases his Power Spike's power by 15% of Power Attack Stat"}, {nome: "CHARGED SPIKE", descricao:"ASAHI AZUMANE consumes 30 additional Stamina to perform a Power Spike with 235% of Power Attack Stat as power, receives 1 stacks of \"Power Charge\"; when casting [CHARGED SPIKE] skill, each stack of \"Power Charge\" increases Power Spike power by 50% of Power Attack Stat"}], symbols: [ "img/powersymbol.png", "img/servesymbol.png" ] },
{ nome: "Sugawara SP",data: "04/12/26", funcao: "S", img: "img/sugawaraSP.png", School: "Karasuno", vinculo: ["After School"],Stats:{Serve:1849,Spike:1758,Set:1950,Receive:1667,Block:1774,Save:1605},habilidades:[{nome:"Support the Attack",descricao:"When Sugawara Koshi (After School) is on the court and a frontline ally activates a block skill, the blocking member's [Block] is increased by 5%/6.25%/7.5% × the total value of the other frontline ally's [Block]. A maximum increase of 1000/1250/1500 is possible. This effect lasts until the ball goes over the net twice. When Sugawara Koshi (After School) is on the court and a backline ally receives the ball, the receiving member's [Receive] is increased by 5%/6.25%/7.5% × the total value of the other backline ally's [Receive]. A maximum increase of 1000/1250/1500 is possible. This effect lasts until the ball goes over the net twice."},{nome:"A skillful serve that exploit weaknesses",descricao:"Sugawara Koushi (After School) Serves with power equal to [Serve] × 140%/160%/180%. Increases team morale by 10. Increases Basic stats of allied members by 12%/14%/16%. This effect lasts for 1 rally."},{nome:"Careful setup",descricao:"Sugawara Koushi (After School) Increases stamina by 13%/16%/20%. When Sugawara Koushi (After School) first participates, allied members will consume 50% of their current stamina, and for every 6 stamina consumed, allied members' Basic stats will increase by 1%/1.3%/1.6%. After Sugawara Koushi (After School)'s first participation, allied members' stamina will reSave 15 at the end of each rally. This effect lasts for 4 rallies."},{nome:"Sign Play",descricao:"Sugawara Koushi (After School) consumes an additional 15 stamina and performs a set with 60% ([Set] × 2) / 80% ([Set] × 2) / 300% / 20% ([Set] × 3) / 40% power ([Set] × 3). The first member to spike (Power Attack/Quick Attack) after this play increases the [Attack Technique] by 2.0%. This effect lasts until the ball goes over the net twice."}] , symbols: [ "img/blocksymbol.png", "img/servesymbol.png", "img/settersymbol.png" ] },
{ nome: "Kenma SP",data: "02/26/26", funcao: "S", img: "img/kenmaSP.png", School: "Nekoma", vinculo: ["Cherry Blossom Viewing","Brain and Commander SP"],Stats:{Serve:1580,Spike:1700,Set:1990,Receive:1710,Block:1600,Save:1590}, habilidades:[{nome:"Leadership",descricao:"When Kozume Kenma (Hanami) is on the court, allied members' [Reflex] is increased by 10/13/16%. When he is on the court and an allied member receives or Saves, he gains one stack of the [Defense that Eliminates Openings] effect, allied members' [Reflex] is increased by 1.5%. Up to 10 stacks. If the results of an allied member's receive or Save is not BAD, he gains one more stack of the [Defense that Eliminates Openings] effect."},{nome:"Set With No Wasted Movement",descricao:"Kozume Kenma (Hanami) performs a set with 140/160/180% of [Set] as power. If the player who attacks (Power Attack/Quick Attack) after this play occurs is in the back row, the power of the attack will be increased by 20%."},{nome:"Look For Flaws",descricao:"When Kozume Kenma (Hanami) performs a Set or Setter Dump, his [Awareness] increases by 40/60/80% of [Reflex] as power. If he is on the court and his teammate's block result is not BAD, the power of the opponent's current spike (Power Attack/Quick Attack) is increased by the corresponding member's [Power Attack/Quick Attack] by 10/13/16%."},{nome:"Play That Confusars The Opponent",descricao:"Kozume Kenma (Hanami) performs a Setter Dump with 255/270/285/300/315% of [Set] as power. Setter Dump cannot be blocked. After this play occurs, the first time an opposing player spikes (Power Attack/Quick Attack), the [Power] of that player is reduced by 40%. This effect lasts for 2 net crossings."}], symbols: [ "img/receivesymbol.png", "img/settersymbol.png" ] },
{ nome: "Kenma SSR", funcao: "S", img: "img/kenmaSR.png", School: "Nekoma", vinculo: ["Brain and Commander"],Stats:{Serve:1182,Spike:1387,Set:1387,Receive:1122,Block:1303,Save:1060}, habilidades:[{nome:"DIVINE VISION", descricao:"While KENMA KOZUME is on the court, increases your side's players' Receive power by 8% of their Receive Stat. When Kozume's Set or your side's Receive results in PERFECT, gain 1 stack(s) of 'Keep It Alive'. Each stack increases Receive power of your side's players by 3%, up to 6 stacks."}, {nome:"STEADY SETTING", descricao:"KENMA KOZUME performs a Set with 120% of his Set Stat."}, {nome:"THE BRAIN", descricao:"While KENMA KOZUME is on the court, increases your side's players' Receive power by 6% of their Receive Stat. If 'Keep It Alive' exceeds 5 stacks, additionally increases their Receive power by 150% and Save power by 150%. When your side's Receive or Save fails, consumes 6 stacks of 'Keep It Alive' to convert the result to PERFECT."}, {nome:"DECEPTIVE DUMP", descricao:"KENMA KOZUME performs an unblockable Setter Dump with 220% of his Set Stat."}], symbols: [ "img/receivesymbol.png", "img/settersymbol.png" ] },
{ nome: "Yaku SSR", funcao: "L", img: "img/yakuSR.png", School: "Nekoma", vinculo: ["Educational Guidance"],Stats:{Serve:1131,Spike:1131,Set:1253,Receive:1391,Block:1098,Save:1323}, habilidades:[{nome:"Key To Defense",descricao:"When Morisuke Yaku is on the court and a teammate's receiving result is not BAD, Morisuke Yaku's [Receive] and [Save] are increased by 3/4/5% with a maximum of 5 stacks."},{nome:"Reliable Defense",descricao:"When Morisuke Yaku is on the court, the Quick Attack of your Quick Attack Specialist on the court is increased by 8/10/12% of that player's [Quick Attack] Stat as power."},{nome:"Super Libero",descricao:"Morisuke Yaku's [Receive] is increased by 11/13/15%. If the result is NORMAL, it changes to PERFECT."},{nome:"Perfect Receive",descricao:"Morisuke Yaku performs a Receive with 240/255/270/285/300% of [Receive] as power."}], symbols: [ "img/receivesymbol.png" ] },
{ nome: "Kuro SSR", funcao: "MB", img: "img/kuroSR.png", School: "Nekoma", vinculo: [],Stats:{Serve:1221,Spike:1318,Set:1149,Receive:1186,Block:1389,Save:1123}, habilidades:[{nome:"EXPERT'S AURA", descricao:"While TETSURO KUROO (Practice) is present, increases Strength of Quick Attack-type players on your side by 16%"}, {nome:"STEADY OFFENSE", descricao:"TETSURO KUROO (Practice) performs a Quick Attack with 125% of Quick Attack Stat as power, receives 1 stacks of 'Power Charge'; when casting [Steady Offense] skill, each stack of 'Power Charge' increases spike power by 15% of Quick Attack Stat, up to 2 stacks"}, {nome:"BLOCK CONTROL TOWER", descricao:"While TETSURO KUROO (Practice) is present, increases Block Stat of players on your side by 8%"}, {nome:"LOCKDOWN", descricao:"TETSURO KUROO (Practice) performs a Block with 170% of Block Stat as power; when other front row Block-type players are present, increases this block's power by 15% of Block Stat"}], symbols: [ "img/blocksymbol.png", "img/quicksymbol.png" ] },
{ nome: "Kuro UR", funcao: "MB", img: "img/kuroUR.png", School: "Nekoma", vinculo: ["Brain and Commander"],Stats:{Serve:1558,Spike:1673,Set:1551,Receive:1581,Block:1740,Save:1533}, habilidades:[{nome:"All Rounder",descricao:"Increases Tetsuro Kuroo's [Quick Attack] by 10/12/14%. When he is on the court, his [Block] and [Quick Attack] increase by 5% each time the ball goes over the net. Stacks up to 5 times."},{nome:"A Quick",descricao:"Tetsuro Kuroo performs a quick attack with a power of [Quick Attack] × 125% and gains 1 stack of the [Charge] effect. When A Quick is activated, the power of the quick attack increases by [Quick Attack] × 5% for each [Charge] stack. Up to 3 stacks."},{nome:"Leadership",descricao:"Increases Tetsuro Kuroo's [Block] by 14/16/18%. If his block result is PERFECT, the opposing team member who performs a spike (Power Attack/Quick Attack) will be inflicted with the [Rage] disadvantage ([Power Attack/Quick Attack] will be reduced by 10%)."},{nome:"Lead Block",descricao:"Tetsuro Kuroo blocks with a power of [Block] × 235/250/265/280/295%. If the opposing member who performed the spike (Power Attack/Quick Attack) has a disadvantageous effect, the power of this block increases by an additional [Block] × 20%."}], symbols: [ "img/quicksymbol.png", "img/blocksymbol.png" ] },
{ nome: "Lev SSR", funcao: "MB", img: "img/levSR.png", School: "Nekoma", vinculo: ["Educational Guidance"],Stats:{Serve:1206,Spike:1318,Set:1138,Receive:1166,Block:1378,Save:1100}, habilidades:[{nome:"TRIGGERED BURST", descricao:"While LEV HAIBA is on the court, when your side achieves a PERFECT Receive, his next Quick Attack gains 15% of his Quick Attack Stat as additional power."}, {nome:"MOMENTUM BLOCK", descricao:"LEV HAIBA performs a Block with 105% of his Block Stat."}, {nome:"GIFTED ATHLETE", descricao:"When LEV HAIBA performs a Quick Attack and the opponent's blocker is affected by a debuff, reduces that blocker's Block power by 10% of their Block Stat."}, {nome:"TALENTED SPIKE", descricao:"LEV HAIBA performs a Quick Attack with 245% of his Quick Attack Stat."}], symbols: [ "img/quicksymbol.png", "img/blocksymbol.png" ] },
{ nome: "Aone SP",data: "06/18/26", funcao: "MB", img: "img/aoneSP.png", School: "Dateko", vinculo: ["Swimming","Iron Wall"],Stats:{Serve:1848,Spike:1788,Set:1754,Receive:1667,Block:1904,Save:1605}, habilidades:[{nome:"Mighty Wall",descricao:"Aone Takanobu (Beach Boys)'s [Reflex] is increased by 10/13/16%. If Aone Takanobu (Beach Boys)'s Stamina is less than 80, his [Block] and [Serve] are increased by 10%. When Aone Takanobu (Beach Boys) blocks, if this play results in a 2-person or 3-person block, for each member with a block skill among the blocking members, the block power of this play is increased with 20% of Aone Takanobu (Beach Boys)'s [Block] Stat as power."},{nome:"Team Motivating Jump Serve",descricao:"Takanobu Aone (Beach Boys) performs a Jump Serve with 140/160/180% of [Serve] as power. The cooldown of the opposing setter's skill is increased by 4 times the number of times the ball has crossed the net (Example, 2 net crossings × 4 = +8 cooldown). When Takanobu Aone (Beach Boys) leaves the court, if Takanobu Aone (Beach Boys) has activated [Team Motivating Jump Serve] during this match, the [Offensive Technique] and [Defensive Technique] of your players are increased by 5%, and if the number of stacks of the [Tough Block] effect is 3 or more, the [Offensive Technique] and [Defensive Technique] of your players are increased by 5% more. This effect lasts until Takanobu Aone (Beach Boys)'s next match. (Each stack of [Tough Block] increases [Reflex] by 10%, with a maximum of 20 stacks)."}, {nome:"Strong and High Walls",descricao:"When Takanobu Aone (Beach Boys) is on the court, each time an opposing player performs an attack (Power Attack/Quick Attack), the attacker gains 1 stack of [Locked On]. At the start of the match, all opposing players gain 1 stack of [Locked On]. If Takanobu Aone (Beach Boys) is on the court and an opposing player has two stacks of [Locked On], that player will consume all of their stacks of [Locked On], and Aone Takanobu (Beach Boys) will gain [Tough Block]. If Aone Takanobu (Beach Boys) has more than 2 stacks of [Tough Block], his Block is increased by 10% of [Block] as power. If Takanobu Aone (Beach Boys) has more than 4 stacks of [Tough Block], the cooldown of [Sharp, Leading Block] decreases to 8 net crossings (12 net crossings → 8 net crossings). If Takanobu Aone (Beach Boys) has more than 6 stacks of [Tough Block], his [Spirit] increases by 10%. If Takanobu Aone (Beach Boys) has more than 8 stacks of [Tough Block], the cooldown of [Sharp, Leading Block] further decreases to 4 net crossings (8 net crossings → 4 net crossings)."}, {nome:"Sharp, Leading Block",descricao:"Takanobu Aone (Beach Boys) blocks with 260/275/290/305/320% of [Block] Stat as power. Increases team morale by 15."}], symbols: [ "img/blocksymbol.png", "img/servesymbol.png" ] },
{ nome: "Aone SSR", funcao: "MB", img: "img/aoneSR.png", School: "Dateko", vinculo: ["The Silent and the Sarcastic"],Stats:{Serve:1219,Spike:1316,Set:1146,Receive:1173,Block:1389,Save:1102}, habilidades:[{nome:"LOCK DOWN ACE", descricao:"When TAKANOBU AONE achieves a PERFECT Block result, marks the opponent spiker, reducing their next spike's power by 10% of Power/Quick Attack Stat and increasing their Stamina consumption by 30%"}, {nome:"HEAVY STRIKE", descricao:"TAKANOBU AONE performs a Quick Attack with 120% of Quick Attack Stat as power"}, {nome:"TRI-WALL FORMATION", descricao:"When TAKANOBU AONE blocks, for each Block-type player on your side (1), increases Block power by 1% of Block Stat; when all 3 front row players are of Block-type, increases Block power by an additional 4% of Block Stat"}, {nome:"IRON PILLAR", descricao:"TAKANOBU AONE performs a Block with 195% of Block Stat as power; when blocking an opponent's Power Spike, increases this block's power by an additional 9% of Block Stat"}], symbols: [ "img/quicksymbol.png", "img/blocksymbol.png" ] },
{ nome: "Futakuchi SSR", funcao: "WS", img: "img/futakuchiSR.png", School: "Dateko", vinculo: ["The Silent and the Sarcastic" , "The New Captain and the Tall Rookie","Iron Wall"],Stats:{Serve:1217,Spike:1316,Set:1147,Receive:1184,Block:1385,Save:1122}, habilidades:[{nome:"CAPTAIN'S AUTHORITY", descricao:"While KENJI FUTAKUCHI is present, increases your side's Block power by 8% of each player's Block Stat"}, {nome:"INITIATE ATTACK", descricao:"KENJI FUTAKUCHI performs a Jump Serve with 120% of Serve Stat as power"}, {nome:"RAISING DEFENSE", descricao:"While KENJI FUTAKUCHI is present, for each Block-type player on your side (1), increases Block power by 0.5% of Block Stat"}, {nome:"UNBREAKABLE IRON WALL", descricao:"KENJI FUTAKUCHI performs a Block with 195% of Block Stat as power; when the opponent's spiking player is affected by a debuff, increases this block's power by an additional 10% of Block Stat"}], symbols: [ "img/blocksymbol.png", "img/servesymbol.png" ] },
{ nome: "Sasaya SSR", funcao: "OP", img: "img/sasayaSR.png", School: "Dateko", vinculo: [],Stats:{Serve:1184,Spike:1378,Set:1120,Receive:1314,Block:1255,Save:1127}, habilidades:[{nome:"CALM RESPONSE", descricao:"Increases TAKEHITO SASAYA's Awareness by 5%; while Sasaya is present, increases Reflex of players on your side by 5%"}, {nome:"IMPENETRABLE DEFENSE", descricao:"TAKEHITO SASAYA performs a Block with 105% of Block Stat as power"}, {nome:"FORTIFIED IRON WALL", descricao:"While TAKEHITO SASAYA is present, when your side is behind, increases your side's Block skill power by an additional 3% of each blocking player's Block Stat and increases blocking players' Reflex by 5%"}, {nome:"AGGRESSIVE PLAY", descricao:"TAKEHITO SASAYA performs a Power Spike with 240% of Power Attack Stat as power"}], symbols: [ "img/powersymbol.png" ] },
{ nome: "Koganegawa SSR", funcao: "S", img: "img/koganegawaSR.png", School: "Dateko", vinculo: ["The New Captain and the Tall Rookie"],Stats:{Serve:1166,Spike:1302,Set:1365,Receive:1100,Block:1306,Save:1031}, habilidades:[{nome: "Rookie Setter", descricao: "KANJI KOGANEGAWA performs a Set with 120% of his Set Stat."}, {nome: "Block Spark", descricao: "KANJI KOGANEGAWA performs a Block with 105% of his Block Stat. While he is on the court, when the opponent performs a Power Spike, your side's blocking players gain 3% additional Block power based on their own Block Stat."}, {nome: "Iron Wall III", descricao: "While KANJI KOGANEGAWA is on the court, increases Block power of your other players' Block skills by 2% of their Block Stat."}, {nome: "Flash Dump", descricao: "KANJI KOGANEGAWA performs an unblockable Setter Dump with 210% of his Set Stat."}], symbols: [ "img/blocksymbol.png", "img/settersymbol.png" ] }, 
{ nome: "Oikawa UR",data: "09/14/25", funcao: "S", img: "img/oikawaUR.png", School: "Aoba Johsai", vinculo: ["Perfect Harmony"],Stats:{Serve:1705,Spike:1533,Set:1627,Receive:1378,Block:1530,Save:1290}, habilidades:[{nome:"The King's Set",descricao:"Oikawa Tooru Sets with 120/135/150% of [Set] as power. If a teammate on the court performs a play, and the result is Perfect, he gains 1 stack of [Offensive Rhythm]. For each stack of [Offensive Rhythm], the [Awareness] of your deployed players increases by 1%, with a maximum of 10 stacks."},{nome:"Unparalleled Talent",descricao:"Oikawa Tooru performs a setter dump with 115% of [Set] as power. The setter dump cannot be blocked. If Oikawa Tooru is on the court, a Power Attack on an allied court member's [Power] is increased by 20%."},{nome:"Conductor",descricao:"When Oikawa Tooru is on the court, the [Awareness] of your players on the court is increased by 10/14/18%. (If Oikawa has 6+ stacks of [Offensive Rhythm]). When one of your players performs a Power Attack skill, consumes 6 stacks of [Offensive Rhythm], and a Perfect result is guaranteed."},{nome:"The Great King's Jump Serve",descricao:"Oikawa Tooru performs a Jump Serve with 260/275/290/305/320% with [Serve] as power. This play increases his [Awareness] by 20% and his [Power] by 20%."}], symbols: [ "img/powersymbol.png", "img/servesymbol.png", "img/settersymbol.png" ] },
{ nome: "Oikawa SSR", funcao: "S", img: "img/oikawaSR.png", School: "Aoba Johsai", vinculo: [],Stats:{Serve:1391,Spike:1327,Set:1327,Receive:1125,Block:1248,Save:1054}, habilidades:[{nome:"COURT VISION",descricao:"Increases TORU OIKAWA (Practice)'s Set Stat by 10%. When your players cast a Spike skill, they gain 1 stack(s) of 'Attack Tempo'. Each stack increases your players' Awareness by 1%, up to 10 stacks."},{nome:"GAME CHANGER",descricao:"While TORU OIKAWA (Practice) is on the court, at the start of each turn, if your side is behind, increases all basic Stats of your players by 6%, lasting for 8 net crossings."},{nome:"CONTROL TOWER",descricao:"While TORU OIKAWA (Practice) is on the court, increases your players’ Awareness by 6%. Each stack of 'Attack Tempo' provides an additional 1% Awareness."},{nome:"DOUBLE-EDGED SERVE",descricao:"TORU OIKAWA (Practice) performs a Power Jump Serve with 240% of his Serve Stat. For this Serve, his Awareness increases by 15%. This Serve has a 5% chance to fail."}], symbols: [ "img/powersymbol.png", "img/servesymbol.png", "img/settersymbol.png" ] },
{ nome: "Iwazumi SSR", funcao: "WS", img: "img/iwazumiSR.png", School: "Aoba Johsai", vinculo: ["Perfect Harmony", "The Pack"],Stats:{Serve:1190,Spike:1385,Set:1118,Receive:1314,Block:1248,Save:1129}, habilidades:[{nome:"Ace's Strength",descricao:"Increases HAJIME IWAIZUMI's Awareness by 5% and Strength by 10%"},{nome:"Focusard Defense",descricao:"HAJIME IWAIZUMI performs a Receive with 120% of Receive Stat as power"},{nome:"Vice-Captain's Rally",descricao:"While HAJIME IWAIZUMI is present, increases Strength of players on your side by 6%"},{nome:"Head-to-Head",descricao:"HAJIME IWAIZUMI performs a Power Spike with 240% of Power Attack Stat as power; when this spike achieves Critical result, increases its power by 15% of Power Attack Stat"}], symbols: [ "img/powersymbol.png" ] },
{ nome: "Kentaro MAD DOG SSR", funcao: "OP", img: "img/kentaroSR.png", School: "Aoba Johsai", vinculo: ["The Pack"],Stats:{Serve:1320,Spike:1383,Set:1106,Receive:1235,Block:1179,Save:1109}, habilidades:[{nome:"FIERCE ATTACK", descricao:"Increases KENTARO KYOTANI's Awareness by 8% and Power Attack Stat by 5%"}, {nome:"MAD DOG SERVE", descricao:"KENTARO KYOTANI performs a Serve with 130% of his Serve Stat. For this Serve, his Awareness increases by 15%, with a fixed 10% chance to fail"}, {nome:"STRENGTH BURST", descricao:"Increases KENTARO KYOTANI's Strength by 18%"}, {nome:"MAD DOG'S FANG", descricao:"KENTARO KYOTANI performs a Power Spike with 210% of his Power Attack Stat, reducing the Stamina of the opponent's blocking and receiving players by 10"}], symbols: [ "img/powersymbol.png", "img/servesymbol.png" ] },
{ nome: "Ushijima UR", funcao: "OP", img: "img/ushijimaUR.png", School: "Shiratorizawa", vinculo: ["Besties for Life", "Absolute Champion and Steady Setter"],Stats:{Serve:1499,Spike:1574,Set:1261,Receive:1417,Block:1345,Save:1261}, habilidades:[{nome:"IN THE GROOVE",descricao:"Increases WAKATOSHI USHIJIMA's Awareness by 8%. While he is on the court, his Awareness increases by an additional 3% at the end of each turn."},{nome:"DOMINATING SERVE",descricao:"WAKATOSHI USHIJIMA performs a Jump Serve with 125% of his Serve Stat. If this Serve is a Critical Serve, the receiving players cannot cast skills. When this Serve scores, reduces DOMINATING SERVE's cooldown by 4 net crossings."},{nome:"STRENGTH BURST",descricao:"Increases WAKATOSHI USHIJIMA's Strength by 18%."},{nome:"CRUSHING SPIKE",descricao:"WAKATOSHI USHIJIMA performs a Power Spike with 220% of his Power Attack Stat. This Spike deals an additional 30% damage to the opponent's Libero."},{nome:"Ace Style",descricao:"When your players land Critical Spikes, WAKATOSHI USHIJIMA gains 1.5% to all Basic Stats, stacking up to 8 times. When he scores, removes all debuffs from himself."},{nome:"Undisputed Ace",descricao:"WAKATOSHI USHIJIMA performs a Power Spike with 250% of his Power Attack Stat. If this Spike is a Critical, reduces [UNDISPUTED ACE]'s cooldown by 1 net crossings."}], symbols: [ "img/powersymbol.png", "img/servesymbol.png" ] },
{ nome: "Tendo SSR", funcao: "MB", img: "img/tendoSR.png", School: "Shiratorizawa", vinculo: ["Besties for Life"],Stats:{Serve:1214,Spike:1314,Set:1140,Receive:1177,Block:1387,Save:1100}, habilidades:[{nome:"My own pace",descricao:"Tendo Satoru's [Reflex] increases by 12/17/22%."},{nome:"A surprise attack",descricao:"Tendo Satoru makes a Quick Attack with 120/135/150% of [Quick Attack] Stat as power."},{nome:"Block Psychological Warfare",descricao:"If Satoru Tendo's block results in a good play, the cooldown of Sharp Reading is reduced by 1/2/3 for the number of times the ball goes over the net."},{nome:"Sharp “reading”",descricao:"Satoru Tendo blocks with a power of 220/235/250/265/280% of his [Block]. If the opponent's spike (Powerful or Quick Attack) is a nice play, Satoru Tendo's [Reflex] is increased by 15%."}], symbols: [ "img/blocksymbol.png" ] },
{ nome: "Goshiki SSR", funcao: "WS", img: "img/goshikiSR.png", School: "Shiratorizawa", vinculo: ["Shiratorizawa’s WS"],Stats:{Serve:1188,Spike:1383,Set:1115,Receive:1314,Block:1240,Save:1122}, habilidades:[{nome:"Meet Expectations",descricao:"When Tsutomu Goshiki scores, team morale is increased by 8/10/12."},{nome:"Pure Receive",descricao:"Tsutomu Goshiki receives with 120/135/150% of [Receive] as power."},{nome:"Next Ace",descricao:"At the end of each rally, Tsutomu Goshiki gains one stack of [Sharpness] effect. Each stack of [Sharpness] increases [Power Attack] by 2.5/3.3/5%. Up to 5 stacks."},{nome:"Make a Miracle",descricao:"Tsutomu Goshiki performs a Power Attack with 225/240/255/270/285% of [Power Attack] as power. This move increases [Awareness] by 10%."}], symbols: [ "img/powersymbol.png", "img/servesymbol.png" ] },
{ nome: "Shirabu SSR", funcao: "S", img: "img/shirabuSR.png", School: "Shiratorizawa", vinculo: ["Absolute Champion and Steady Setter"],Stats:{Serve:1303,Spike:1382,Set:1242,Receive:1118,Block:1239,Save:1041}, habilidades:[{nome:"As Usual",descricao:"Increases Kenjiro Shirabu's [Set] by 10/13/16%. If the member who spikes [Power Attack/Quick Attack] is a power hitter, the power of this spike increases by 8% of that member's [Power Attack]."},{nome:"Simple Setter Dump",descricao:"Kenjiro Shirabu performs a setter dump with 120/135/150% of [Set] as power. This cannot be blocked."},{nome:"Correction Ability",descricao:"Kenjiro Shirabu's [Awareness] increases by 9/12/15%."},{nome:"Set That Makes the Most of the Spiker",descricao:"Kenjiro Shirabu sets with 210/225/240/250/270% of [Set] as power. This move increases [Awareness] by 10%."}], symbols: [ "img/powersymbol.png", "img/settersymbol.png" ] },
{ nome: "Semi SSR", funcao: "S", img: "img/semiSR.png", School: "Shiratorizawa", vinculo: [],Stats:{Serve:1476,Spike:1329,Set:1406,Receive:1184,Block:1329,Save:1111}, habilidades:[{nome:"Control",descricao:"When Eita Semi performs a serve, the opposing receiver's Receive is reduced by 13/15.5/18% of that player's [Receive] as power. This effect lasts for 4 net crossings."},{nome:"Prototype Assembly",descricao:"Semi Eita performs a Set with 120/135/150% of [Set] as power."},{nome:"Demonstration of Ability",descricao:"When Eita Semi serves, [Awareness] increases by 5/5/8% and [Power] increases by 10/15/15%."},{nome:"This Much is Free",descricao:"Eita Semi performs a Jump Serve with a power of 220/235/250/265/280% of his [Serve]. If he scores an ace with this serve, his teammates' [Awareness] will increase by 3% and [Reflex] by 6%."}], symbols: [ "img/powersymbol.png", "img/servesymbol.png", "img/settersymbol.png" ] },
{ nome: "Ohira SSR", funcao: "WS", img: "img/ohiraSR.png", School: "Shiratorizawa", vinculo: ["Shiratorizawa’s WS"],Stats:{Serve:1272,Spike:1477,Set:1188,Receive:1399,Block:1332,Save:1197}, habilidades:[{nome:"Strong Defense",descricao:"When Ohira Reon receives, if the opponent's quick attack is a NICE play, the power of this receive is 40/55/70% of [Receive] as power."},{nome:"Defense That Changes The Flow",descricao:"Ohira Reon receives with 120/135/150% of [Receive] as power."},{nome:"The Gentle “Benkei”",descricao:"Ohira Reon's [Awareness] is increased by 5/5/8%, and his [Reflex] is increased by 10/15/15%."},{nome:"Power Spikes",descricao:"Ohira Reon makes a powerful spike with 240/255/270/285/300% of [Power Attack] as power."}], symbols: [ "img/receivesymbol.png" ] },
/* ==missing Stats== */{ nome: "Yamagata SSR", funcao: "L", img: "img/yamagataSR.png", School: "Shiratorizawa", vinculo: [],Stats:{Serve:1,Spike:1,Set:1,Receive:2,Block:1,Save:1}, habilidades:[{nome:"Stable Ability",descricao:"Yamagata Hayato's [Reflex] is increased by 13/20/15%."},{nome:"Wide Range of Defense",descricao:"Yamagata Hayato performs a save with [Save] × 120/135/150% as their power."},{nome:"Reflexes",descricao:"If the opponent's block result is PERFECT, Yamagata Hayato's save increases by [Save] × 40/50/60%."},{nome:"Solid receiving",descricao:"Yamagata Hayato receives with [Receive] × 235/250/265/280/295% as his power."}], symbols: [ "img/receivesymbol.png" ] },
{ nome: "Bokuto UR",data: "08/30/25", funcao: "WS", img: "img/bokutoUR.png", School: "Fukurodani", vinculo: ["Miracle Ace and Caring Setter"],Stats:{Serve:1495,Spike:1572,Set:1262,Receive:1417,Block:1347,Save:1268}, habilidades:[{nome:"Influence of Enthusiasm",descricao:"When Bokuto Kotaro plays, team morale of allies increases by 20%/25%/30%. When Bokuto Kotaro is on the court, team morale of allies increases by 4 when an allied member touches the ball. Effect of team morale awakening for allies changed: Basic stats of all members on the court increase by 32%/36%/40%. Lasts until allies touch the ball four times."},{nome:"Big Server",descricao:"Kotaro Bokuto performs a jump serve with [Serve] × 125%/140%/155% power."},{nome:"Ups and Downs in Mood",descricao:"While under the effect of [Excellent Condition], Kotaro Bokuto's [Power Attack] is increased by 12%/15%/18% and his [Power] is increased by 18%/22.5%/27%. While under the effect of [Depressed Mode], Kotaro Bokuto cannot activate Power Attack skills. When an ally activates Team Morale Awakening, Kotaro Bokuto gains the [Excellent Condition] effect. When the team morale awakening of an ally ends, Kotaro Bokuto will gain the [Depressed Mode] effect. At the end of each rally, Kotaro Bokuto loses the [Sad Mode] effect."},{nome:"Ace Thanks to Everyone",descricao:"Kotaro Bokuto performs a Power Attack with the power of [Power Attack] × 260%/275%/290%/305%/320%. If this hit is a nice play, Kotaro Bokuto's [Power] increases by 12%/14%/16%/18%/20% and his team's morale increases by 16."}], symbols: [ "img/powersymbol.png", "img/servesymbol.png" ] },
{ nome: "Bokuto SP",data: "05/12/26", funcao: "WS", img: "img/bokutoSP.png", School: "Fukurodani", vinculo: ["Swimming", "Ace Miraculous and Caring Setter"],Stats:{Serve:1673, Spike:1950, Set:1574, Receive:1856, Block:1760, Save:1572}, habilidades:[{nome:"Enliven",descricao:"Kotaro Bokuro (Beach Boys)’s [Power Attack] increases by 13%/16%/19%. When Kotaro Bokuto (Beach Boys) is on the court, the effects of team morale boosts for allies other than 'Encourage' are reduced by 100%, and for every 10 morale boost reduced, the player gains 1 stack of the 'United' effect. For each stack of the 'United' effect, the Basic stats of allied members increase by 0.16%. Up to 199 stacks. When Kotaro Bokuto (Swimming) is on the court, his teammates will..."},{nome:"Defensive Participation",descricao:"Kotaro Bokuto (Sea Bathing) receives with [Receive] × 140%/160%/180% as power. Gain 3 stacks of the [Unity] effect."},{nome:"Always Cheerful!",descricao:"If you have the [Best Condition] effect, when Kotaro Bokuto (Beach Boys) activates his Ultimate, his [Power Attack] is increased by 1% for each stack of [United] effect. Up to a maximum of 70% increase is possible. This effect lasts until the ball goes over the net twice. Also, for each stack of [United] effect, the power of his Power Attack is increased by [Power Attack] × 1.5%. Up to a maximum of 120% increase is possible. This effect lasts until the ball goes over the net twice. After Kotaro Bokuto (Swimming in the Sea) activates his Ultimate, Kotaro Bokuto (Swimming in the Sea) will gain [Ups and Downs]."},{nome:"Miracle Spike",descricao:"Kotaro Bokuto (Beach Boys) will perform a spike with power equal to 260%/280%/300%/320%/340% of his [Power Attack]. For each stack of [United] effect, Kotaro Bokuto (Beach Boys)’s [Attack Technique] will increase by 0.75%. Up to a maximum of 30% increase is possible. This effect lasts until the ball goes over the net twice."}], symbols: [ "img/powersymbol.png", "img/receivesymbol.png" ] },
{ nome: "Akaashi SP",data: "06/11/26", funcao: "S", img: "img/akaashiSP.png", School: "Fukurodani", vinculo: ["Swimming", "Ace Miraculous and Caring Setter"],Stats:{Serve:1848, Spike:1754, Set:1949, Receive:1581, Block:1758, Save:1489}, habilidades:[ {nome: "Team Organizer", descricao:"Akaashi Kyoji (Beach Boy)’s [S] increases by 13/15/18%. When an ally's team morale increases, Akaashi Kyoji (Beach Boy) gains 1 stack of the [Calm Mind] effect for every 10 increase in team morale. Each stack of [Calm Mind] increases [Set] by 1.5%. Up to 10 stacks. While Team Morale Awakening is not active, all [Calm Mind] stacks are consumed when Akaashi Kyoji (Beach Boy) touches the ball. Each time one stack of [Calm Mind] is consumed, Akaashi Kyoji (Beach Boy)’s [Spirit] increases by 3%. This effect can be increased by up to 30%. This effect lasts for 2 net crossings."}, {nome: "Bring out 100% of your training", descricao:"Keiji Akaashi (Beach Boy) performs a Set with 140/155/170% of [Set] as power. After this play occurs, the next time Keiji Akaashi (Beach Boy) activates his Ultimate, his [Set] is increased by 15%. This effect lasts for 2 net crossings."},{nome: "Attacking Set", descricao:"While an ally has activated Team Morale Awakening, when Keiji Akaashi (Beach Boy) touches the ball, 5 stacks of [Calm Mind] are consumed, and Keiji Akaashi (Beach Boy)'s [Spirit] is increased by 70%. This effect lasts for 2 net crossings. If Keiji Akaashi (Beach Boy)'s set is a Critical Hit, the [Awareness] of the first player to spike (Power Attack/Quick Attack) after this play is increased by 50% of Keiji Akaashi (Beach Boy)'s [Awareness] Stat, up to a maximum of 60%. If this spike is a Power Attack, the [Awareness] of the team member who performed the spike will be increased by an additional 50% of Keiji Akaashi (Beach Boys)’s [Awareness]. Up to a maximum of 60%. When [Bring out 100% of Your Training] is activated, for each stack of [Calm Mind] he has, the [Power Attack] of the member performing the spike will increase by 3/3.5/4%, up to a maximum of 24/28/32%"},{nome: "Decisive Blow", descricao:"Akaashi Kyoji (Beach Boy) performs a Setter Dump with a power of 260/280/300/320/340% of [Set]. The Setter Dump cannot be blocked. If this Dump is a Critical Hit, the cooldown of [Bring Out 100% of Your Practice] is reduced by 4 net crossings. Gain 1 stack of [Calm Mind]."}], symbols: [ "img/powersymbol.png", "img/settersymbol.png" ] },
{ nome: "Akaashi SSR", funcao: "S", img: "img/akaashiSR.png", School: "Fukurodani", vinculo: ["Miracle Ace and Caring Setter"],Stats:{Serve:1396,Spike:1331,Set:1476,Receive:1191,Block:1334,Save:1123}, habilidades:[{nome:"Instant Insight",descricao:"When Keiji Akaashi is on the court and an ally achieves a PERFECT block or receive, all of that ally’s adverse effects are reset. Keiji Akaashi’s [Awareness] increases by 8/10/12% and allies’ team morale increases by 3."},{nome:"The Brain of Fukurodani",descricao:"Keiji Akaashi performs a setter dump with 120/135/150% of [Set] as power. This attack cannot be blocked. If a point is scored with this setter dump, the power of the first teammate’s serve after this play is increased by 10% of that teammate’s [Serve] as power."},{nome:"Devoted Set",descricao:"Increases Keiji Akaashi’s [Set] by 8/10/12%. While Team Morale Awakening is active, for every 4 increase in team morale, Keiji Akaashi’s [Awareness] increases by 1.2/1.7/2.3%. If his set results in a nice play, the first spike [Power Attack/Quick Attack] by an ally after this play is guaranteed to be a NICE play."},{nome:"The Usual Set",descricao:"Keiji Akaashi sets with 240/255/270/285/300% of [Set] as power."}], symbols: [ "img/powersymbol.png", "img/settersymbol.png" ] },
{ nome: "Konoha SSR", funcao: "OP", img: "img/konohaSR.png", School: "Fukurodani", vinculo: [],Stats:{Serve:1256,Spike:1462,Set:1196,Receive:1274,Block:1333,Save:1335}, habilidades:[{nome:"Excellent Receive",descricao:"Akinori Konoha [Receive] is increased by 8/10/12%. While Team Morale Awakening is activated, his [Receive] and [Save] are increased by 10%."},{nome:"An Exquisite Combination",descricao:"Akinori Konoha performs a save with 120/135/150% of [Cover] as power."},{nome:"All-Rounder's Block",descricao:"When Akinori Konoha is in the front row, the [Block] and [Power Attack/Quick Attack] of all allies in the front row is increased by 8/10/12%. If he is in the back row, the [Receive] and [Save] of all allies in the back row is increased by 8/10/12%."},{nome:"Mr. Skillful Poor",descricao:"Akinori Konoha receives with 225/240/255/270/285% of [Receive] as power. If the result of this play is not BAD, team morale is increased by 20."}], symbols: [ "img/receivesymbol.png" ] },
/* ==missing Stats== */{ nome: "Haruki SSR", funcao: "L", img: "img/harukiSR.png", School: "Fukurodani", vinculo: [],Stats:{Serve:1,Spike:1,Set:1,Receive:2,Block:1,Save:1}, habilidades:[{nome:"Master of Defense",descricao:"Haruki Komi’s [Receive] is increased by 8/10/12%. If his receive result is not BAD, the opponent’s team morale decreases by 12."},{nome:"Team Lubricant (0_0)",descricao:"Haruki Komi performs a save that usars 110/125/140% of [Save] as power. If the result of this play is not BAD, the main stats of allies increase by 5/6.5/8% for 1 rally."},{nome:"Proven Receiving",descricao:"When Haruki Komi receives a ball and the opponent hits a powerful one, the power of the receive increases by 30/40/50% of [Receive] as power."},{nome:"Center of Defense",descricao:"Haruki Komi performs a receive that usars 235/250/265/280/295% of [Receive] as power."}], symbols: [ "img/receivesymbol.png" ] },
/* ==missing Stats== */{ nome: "Tatsuo SSR", funcao: "MB", img: "img/tatsuoSR.png", School: "Fukurodani", vinculo: [],Stats:{Serve:1,Spike:1,Set:1,Receive:1,Block:2,Save:1}, habilidades:[
{nome:"An Intimidating Block",descricao:"Tatsuki Washio’s [Block] is increased by 8/10/12%. When he blocks, the power of the first teammate’s receive after this play is increased by 20% of [Receive] as power. If his block result is not BAD, the next time he blocks, it is increased by 20% of [Block] as power."},
{nome:"High Scoring Attack",descricao:"Tatsuki Washio performs a quick attack with 120/135/150% of [Quick Attack] as power."},
{nome:"A Worker With Hidden Talent",descricao:"When an opposing team member makes a NICE play, Tatsuki Washio’s [Block] and [Quick Attack] are increased by 2/2.5/3%. Up to 5 stacks."},
{nome:"A Block That Takes Advantage Of Its Tall Body (?lol)",descricao:"Tatsuki Washio blocks with 220/235/250/265/280% of [Block] as power."}], symbols: [ "img/quicksymbol.png", "img/blocksymbol.png" ] },
{ nome: "Terushima SSR", funcao: "WS", img: "img/terushimaSR.png", School: "Jozenji", vinculo: [],Stats:{Serve:1401,Spike:1470,Set:1196,Receive:1335,Block:1263,Save:1196}, habilidades:[{nome:"Free Spirit",descricao:"Increases Terushima Yuji's [Power Attack] by 8%/10%/12%. When he is on the court and the result of a receive, save, or set by an ally is not a BAD result, Terushima Yuji gains 1 stack of the [Play More, Play More] effect. Each stack increases [Power Attack/Quick Attack] by 2.5%. Up to 4 stacks."},{nome:"Fun Serve",descricao:"Terushima Yuji performs a jump serve with 120%/135%/150% of [Serve] as power."},{nome:"Asoviva",descricao:"For each receiving team member on the team's court, Terushima Yuji's [Receive] increases by 4%/5%/6%. If he misses a receive, no points are lost. The cooldown for this effect lasts until the ball has crossed the net 10 times."},{nome:"Exciting Spike",descricao:"Terushima Yuji hits a powerful spike with 235%/250%/265%/280%/295% of [Power Attack] as power. If this scores a point, the [Receive] of allies will increase by 10%. This effect will last until the ball has crossed the net 3 times."}], symbols: [ "img/powersymbol.png", "img/servesymbol.png" ] },
{ nome: "Atsumu UR",data: "10/14/25", funcao: "S", img: "img/atsumuUR.png", School: "Inarizaki", vinculo: ["Twin Power", "Twin Heads"],Stats:{Serve:1705,Spike:1539,Set:1629,Receive:1376,Block:1530,Save:1290}, habilidades:[{nome:"Unpredictable Play",descricao:"When Miya Atsumu performs a serve, if the serve is aimed at a weak spot in the opposing team's defense, the power of that serve is increased by 30%/40%/50% of [Serve] Stat as power. When the serve is not aimed at a weak spot in the opposing team's defense, the [Receive] of your back row players increases by 10%/12%/14%. This effect lasts for one rally (one full point)."}, {nome:"Delicate Set",descricao:"Miya Atsumu will set with 125%/140%/155% of [Set] as power. This set resets all debuffs of the player who spikes (Power Attack/Quick Attack)."}, {nome:"Devoted and Sincere Set",descricao:"Increases Miya Atsumu's [Set] by 8%/11%/14%. When one of your players performs an action, and the result is not Perfect, Miya Atsumu gains two stacks of [Perfect Timing]. Each stack of [Perfect Timing] increases [Set] by 2%, with a maximum of 10 stacks. When Miya Atsumu sets, he consumes one stack of [Perfect Timing], increasing the [Attack Technique] and [Quick Attack] Stats of the player who spikes (Power Attack/Quick Attack) by 2.5. This effect lasts for 10 net crossings."}, {nome:"Twin Swords Serve",descricao:"Miya Atsumu alternates between a Jump Serve and a Jump Float Serve. Jump Float Serve: Miya Atsumu performs a Jump Float Serve with 230%/245%/275%/290% of [Serve] as power. Opposing players cannot usar [Power Attack] or [Quick Attack] ultimates. This effect lasts for 2 net crossings. Jump Serve: Miya Atsumu performs a Jump Serve with 260%/275%/290%/305%/320% of [Serve] as power. For every 3 Team Morale, Miya Atsumu's [Awareness] will increase by 1%. This effect lasts for 2 net crossings."}], symbols: [ "img/quicksymbol.png", "img/servesymbol.png", "img/settersymbol.png" ] },
{ nome: "Osamu UR",data: "10/29/25", funcao: "OP", img: "img/osamuUR.png", School: "Inarizaki", vinculo: ["Twin Power", "Twin Heads"],Stats:{Serve:1621, Spike:1685, Set:1426, Receive:1459, Block:1428, Save:1373}, habilidades:[{nome:"Flexible Offense",descricao:"Increases Miya Osamu's [Quick Attack] by 10%/12%/14%. Beginning of match: Miya Osamu's [Awareness] decreases to 0%, and for every 1% decrease, Miya Osamu's [Attack Technique] increases by 1%. Note: Stacking Osamu's Awareness should be priority for this skill alone."}, {nome:"Cool Jump Serve",descricao:"Miya Osamu performs a Jump Serve with 120%/135%/150% of [Serve] Stat as power. If the opponent's receiver has the debuff [Suppression], Miya Osamu's [Attack Technique] is increased by 10%. This effect lasts for 8 net crossings."}, {nome:"Multi-talented",descricao:"Increases Miya Osamu's [Attack Technique] by 10%/13%/16%. When Miya Osamu performs an attack or serve, he inflicts one stack of the debuff [Suppression] on the opponent's back row players. (Players with the debuff [Suppression] have their [Receive] Stat reduced by 10%, per stack). This effect lasts for 10 net crossings."}, {nome:"Flexible Counter Attack",descricao:"Miya Osamu performs a quick attack with 260%/275%/290%/305%/320% of [Quick Attack] as power. Miya Osamu's [Quick Attack] Stat is increased by 40% of [Attack Technique]. This effect lasts for 2 net crossings. Note: This is influenced by the [Attack Technique] gained by Flexible Offense. Skill Resonance 2: When Miya Osamu performs a quick attack, if the opponent's receiver has the debuff [Suppression], the attack's power will increase by 60% of [Quick Attack] Stat. Skill Resonance 4: When Miya Osamu performs a quick attack, the next two time one of your side's players activates their ultimate, [Attack Technique] and [Defensive Technique] of that player will increase by 20%."}], symbols: [ "img/quicksymbol.png", "img/servesymbol.png" ] },
{ nome: "Kita SSR", funcao: "WS", img: "img/kitaSR.png", School: "Inarizaki", vinculo: ["Twin Heads"],Stats:{Serve:1238, Spike:1219, Set:1333, Receive:1476, Block:1198, Save:1409}, habilidades:[{nome:"Repetition, continuity, and caution",descricao:"Increases Kita Shinsuke's Basic Stats by 6%/8%/10%. If Kita's [Receive] result is BAD, Kita's [Defensive Technique] is increased by 80% of [Reflex] as power. Note: This is an increase of [Defensive Technique] by the value of [Reflex]."}, {nome:"Calm Play",descricao:"Kita Shinsuke performs a [Save] with 120%/135%/150% of [Save] Stat as power."}, {nome:"I'll Do It Properly",descricao:"Kita Shinsuke's [Receive] Stat is increased by 8%/10%/12%. Kita Shinsuke performs a [Receive]. If the [Receive] result is not Perfect, he gains 1 stack of [Reliable Action]. Each stack of [Reliable Action] increases Kita Shinsuke's [Receive] Stat by 3%, up to a maximum of 3 stacks. If Kita Shinsuke possesses 3 or stacks of [Reliable Action], consume 3 stacks of [Reliable Action] increase [Attack Technique] of your side's front row players by 10%. This effect lasts for 8 net crossings."}, {nome:"Solid Play",descricao:"Kita Shinsuke performs a [Receive] with 235%/250%/265%/280%/295% of [Receive] Stat power."}], symbols: [ "img/receivesymbol.png" ] },
{ nome: "Rintaro SSR", funcao: "MB", img: "img/rintaroSR.png", School: "Inarizaki", vinculo: [],Stats:{Serve:1266, Spike:1476, Set:1186, Receive:1258, Block:1324, Save:1318}, habilidades:[{nome:"Close The Course",descricao:"Increases Rintaro Suna's [Block] by 10%/12%/14%. When he is on the court and an opposing team member who spikes has the disadvantage effect of [Confusion], the power of the team's block increases by 15%/20%/25% of the blocking team member's [Block]."}, {nome:"Skilled Block",descricao:"Rintaro Suna blocks with 20%/35%/50% of the attack's power."}, {nome:"A Play that Catches the Opponent Off Guard",descricao:"Increases Rintaro Suna's [Quick Attack] by 10%/12%/14%. When he is on a quick attack, he inflicts 1 stack of the [Confusion] effect on the opponent's front line. For each stack of [Confusion], their [Block] is reduced by 10%. This effect lasts until the ball has crossed the net 8 times."}, {nome:"Spikes With a Wide Impact Point",descricao:"Rintaro Suna performs a quick attack with 240%/255%/270%/285%/300% of [Quick Attack] as power."}], symbols: [ "img/quicksymbol.png", "img/blocksymbol.png" ] },
/* ==missing Stats== */{ nome: "Oshiro SSR", funcao: "WS", img: "img/oshiroSR.png", School: "Inarizaki", vinculo: [],Stats:{Serve:1,Spike:2,Set:1,Receive:1,Block:1,Save:1}, habilidades:[{nome:"Rhythm Control",descricao:"Every time Oshiro Alan consumes 10 stamina, he gains 1 stack of [Quick Breather]. Each stack of [Quick Breather] effects increases [Attack Technique] by 3%/3.5%/4%. At the end of a rally, all [Quick Breather] effects are consumed. For every stack of [Breathing Time] that is consumed, Oshiro Alan reSaves 4 stamina."}, {nome:"Highly Skilled Serve",descricao:"Ojiro Alan performs a Jump Serve with 110%/125%/140% of [Serve] Stat as power. The opponent receiver will have their [Receive] reduced by 10%. This effect lasts for six net crossings."}, {nome:"Aggressive Assault",descricao:"Increases Oshiro Alan's [Power Attack] by 6%/8%/10% and [Serve] by 6%/8%/10%. When Oshiro Alan performs a Power Attack, 60% of his current stamina is consumed, and this power attack increases by 30%/40%/50% of [Power Attack] as power."}, {nome:"Thunderous Spike",descricao:"Ojiro Alan performs a power attack with 240%/255%/270%/285%/300% of [Power Attack] as power."}], symbols: [ "img/powersymbol.png", "img/servesymbol.png" ] },
/* ==missing Stats== */{ nome: "Akagi SSR", funcao: "L", img: "img/akagiSR.png", School: "Inarizaki", vinculo: [],Stats:{Serve:1,Spike:1,Set:1,Receive:2,Block:1,Save:1}, habilidades:[{nome:"Seriousness boosting save",descricao:"Increases Akagi Michinari's [Receive] and [Save] by 8%/10%/12%. Increases team morale by 10 when Akagi Michinari receives or Saves."}, {nome:"A reliable libero",descricao:"Akagi Michinari will Save with a power equal to 120%/135%/150% of [Save]. Increases the [Defensive Technique] of allies by 4%/6%/8%. This effect lasts until the ball has crossed the net 6 times."}, {nome:"Chase the ball with your hand",descricao:"Akagi Michinari's [Receive] is increased by 10%/12%/14%. When Akagi Michinari is on the court, an opposing member who hits a powerful shot will be inflicted with one stack of the [Approaching] disadvantage. For each stack of the [Approaching] disadvantage, [Approaching] will decrease [Power Attack] by 8%/10%/12%. This effect lasts until the ball goes over the net three times. When Akagi Michinari is on the court and an opposing member who hits a powerful shot already has the [Approaching] disadvantage, allied members' [Defensive Technique] will be increased by 4%/6%/8%. This effect lasts until the ball goes over the net three times."}, {nome:"Gutsy Receive",descricao:"Akagi Michinari receives with 240%/255%/270%/285%/300% of [Receive] as power."}], symbols: [ "img/receivesymbol.png" ] },
/* ==missing Stats== */{ nome: "Yui SSR", funcao: "WS", img: "img/yuiSR.png", School: "Inarizaki", vinculo: [],Stats:{Serve:1,Spike:2,Set:1,Receive:1,Block:1,Save:1}, habilidades:[{nome:"Stable Offense and Defense",descricao:"Increases Ginjima Yui's [Power Attack] by 6%/8%/10% and [Receive] by 6%/8%/10%. When Ginjima Yui receives, if the opponent performs a Power Attack, the power of this receive increases by [Receive] × 15%/25%/35%."}, {nome:"Powerful Receive",descricao:"Ginjima Yui receives with a power of [Receive] × 120%/135%/150%."}, {nome:"An Enthusiastic Attack",descricao:"Whenever there is one receiving member on the team, Ginjima Yui's [Attack Technique] increases by 2%/2.5%/3%. If the receiving result of the team member is not BAD, Ginjima Yui's [Power Attack] increases by 15%. This effect lasts until the ball goes over the net four times."}, {nome:"A Powerful Blow",descricao:"Ginjima Yui will perform a powerful attack with a power of [Power Attack] × 225%/240%/255%/270%/285%. If Ginjima Yui is in the rear guard, the power of this powerful attack will increase by [Power Attack] × 30%."}], symbols: [ "img/powersymbol.png", "img/receivesymbol.png" ] },
{ nome: "Hoshiumi UR",data: "12/13/25", funcao: "WS", img: "img/hoshiumiUR.png", School: "Kamomedai", vinculo: ["Longtime Friends"],Stats:{Serve:1621,Spike:1704,Set:1341,Receive:1541,Block:1581,Save:1305}, habilidades:[{nome:"Break The Chain",descricao:"When Hoshiumi Korai is on the court and an ally blocks, for every 50 of the blocking team members [Block], the power of the opponent's spike (Power Attack/Quick Attack) is reduced by the spiking team members [Power Attack/Quick Attack] × 0.3%/0.4%/0.5% (maximum 30%). For every 1% decrease in the opponent's spike power, the power of Hoshiumi Korai's next skill is increased by 1%."}, {nome:"Great Performance In All Areas",descricao:"Hoshiumi Korai can activate multiple play skills. These skills share a cooldown.\nSpike Serve: Performs a spike serve with the power of [Serve] × 140%/160%/180%.\nReceive: Receives with the power of [Receive] × 140%/160%/180%.\nBlock: Blocks with the power of [Block] × 140%/160%/180%."}, {nome:"No 1 Point Getter",descricao:"Increases Hoshiumi Korai's [Power Attack] by 16%/20%/24%. When <All-Rounded Exploitation> is activated, gain one stack of [All-Rounder]. When Hoshiumi Korai's skill is activated, the [All-Rounder] effect is consumed, and different effects are activated depending on the play.\nPowerful Blow: Increases [Attention] by 14%/17%/20% until the ball goes over the net twice.\nServe: Reduces the opponent's back row player's [Receive] by 14%/17%/20% until the ball goes over the net twice."}, {nome:"Shining Spear",descricao:"Performs a powerful attack with a power of [Power Attack] × 265%/280%/295%/310%/325%. If in the front line, the power of this attack is increased by [Power Attack] × 40%/45%/50%/55%/60%."}], symbols: [ "img/powersymbol.png", "img/servesymbol.png", "img/blocksymbol.png", "img/receivesymbol.png" ] },
{ nome: "Hirugami UR",data: "12/28/25", funcao: "MB", img: "img/hirugamiUR.png", School: "Kamomedai", vinculo: ["Longtime Friends"],Stats:{Serve:1660,Spike:1630,Set:1629,Receive:1540,Block:1742,Save:1493}, habilidades:[{nome:"The Core Of The Kamomedai System",descricao:"When Hirugami Sachiro serves, his [Attention] increases by 12%/16%/20%. When he is on the court, allies gain one stack of the [System] effect when blocking. Each stack increases allies' Basic stats by 8%, up to 5 stacks. Lasts until the ally scores. Each stack also increases Hirugami Sachiro's base Stats by an additional 10%."}, {nome:"A Psychologically Pressing Serve",descricao:"Performs a jump floater serve with a power of 140%/160%/180% of his [Serve]. If this play is a nice play, the opponent's team morale awakening ends, preventing them from gaining team morale with one rally."}, {nome:"Defense Is The Best Attack",descricao:"When Hirugami Sachiro is on the court, gain one stack of the [Strong Block] effect each time the ball goes over the net. When an ally blocks, effects depend on the number of [Strong Block] stacks.\n2 stacks: Block power increases by 15%/20%/25% of the blocking members' [Block] until the ball goes over the net twice.\n3 stacks: Receive power increases by 15%/20%/25% of the receiving members' [Receive]."}, {nome:"The Immovable God of Day",descricao:"Blocks with a power of [Block] × 260%/275%/290%/305%/320%. If the opponent hits a powerful blow, the block's power increases by [Block] × 40%/45%/50%/55%/60%."}], symbols: [ "img/servesymbol.png", "img/blocksymbol.png" ] },
{ nome: "Sakusa UR",data: "08/10/26", funcao: "WS", img: "img/hayaseiomiUR.png", School: "Itachiyama", vinculo: ["Top Spiker and Top Libero"],Stats:{Serve:1774,Spike:2012,Set:1667,Receive:1928,Block:1699,Save:1656}, habilidades:[{nome:"Persistent Attack",descricao:"Kiyoomi Sakusa's [Power Hit] increases by 10%/12.5%/15%, and his [Receive] increases by 20%/22%/25%. When he receives an attack, [Power Attack] increases by 6%, stacking up to 3 times, lasting until his next Power Attack. When he hits a Powerful Shot, [Receive] increases by 15% until his next receive."}, {nome:"Take All Precautions",descricao:"Performs a [Receive] ×1 receive with 50%/70%/90% power. If receiving exceeds [Receiving] × 170%, [Reflex] increases by 10% and <Preparedness> cooldown is reduced by 2× the ball crossings. If receiving exceeds [Receiving] × 200%, [Defensive Technique] increases by 15%. Lasts until the match ends."}, {nome:"Top Spiker",descricao:"When on the court, if allies perform a Nice Play (receive, Save, block), gain a stack of [Perfectionism]. Each stack increases [Receive] and [Power Hit] by 6%, up to 20 stacks. When hitting, [Awareness] increases by 10% per stack. Lasts until the ball crosses the net twice."}, {nome:"Spikes that change trajectory by rotating",descricao:"Performs a [Power Hit] with power × 260%/280%/300%/320%/340%. If in the back row, power increases by [Power Hit] × 40%. If a Nice Play occurs, the opponent's next receive is reduced by [Receive] × 15%."}], symbols: [ "img/receivesymbol.png", "img/powersymbol.png" ] },
{ nome: "Komori UR",data: "09/09/26", funcao: "L", img: "img/komoriUR.png", School: "Itachiyama", vinculo: ["Top Spiker and Top Libero"],Stats:{Serve:1580,Spike:1579,Set:1904,Receive:2012,Block:1580,Save:1866}, habilidades:[{nome:"Key Person Of The Team",descricao:"When on the court, all allied backcourt players' [Defensive Technique] increases by 10%/13%/16%. Gains 6 stacks of [Connect to Next] at rally start; each stack increases [Set] by 3% and [Reflex] by 5%, up to 10 stacks."}, {nome:"Skillful Set",descricao:"Sets with power × 140%/160%/180% of [Set], increasing teammates' morale by 10. The first spike (Power Attack/Quick Attack) by an ally after this increases the spiker's [Attention] by 15% until the ball crosses the net twice."}, {nome:"Create The Flow Of The Game",descricao:"[Receive] increases by 12%/16%/20%. When an ally activates a non-special receive or Komori activates a receive special, consumes 2 stacks of [Connect to Next] to increase receive power by [Receive] × 30% and the first ally spike after this increases that spike's (Power Attack/Quick Attack) power by 20%."}, {nome:"Receive That Creates Momentum",descricao:"Receives with power × 260%/275%/290%/305%/320% of [Receive]. The first ally spike (Power Attack/Quick Attack) after this increases the spiker's [Attack Technique] by 20% until the ball crosses the net twice."}], symbols: [ "img/receivesymbol.png", "img/settersymbol.png" ] },
/* ==missing Stats== */{ nome: "Kuro SP", funcao: "MB", img: "img/kuroSP.png", School: "Nekoma", vinculo: ["Fireworks Festival","Brain and Commander SP"], Stats:{Serve:1,Spike:1,Set:1,Receive:1,Block:2,Save:1}, habilidades:[
  {nome:"The Command Tower That Cannot Be Beaten", descricao:"When Kuroo Tetsuro (Hanabi) is on the court, the [Spirit] of allied members in the same row as Kuroo Tetsuro (Hanabi) is increased by 20/25/30%. After he touches the ball, the power of the next play of the same type as Kuroo Tetsuro (Hanabi) is increased by 40% x the corresponding parameter of the member making the play. If Kuroo Tetsuro (Hanabi)’s play is a critical play, a random member on the opposing court will be given the [Rage] disadvantage (([Power Attack/Quick Attack] will be reduced by 10%)."},
  {nome:"Skillfull Receive", descricao:"Kuroo Tetsuro (Hanabi) performs a receive with power equal to [Receive] x 140/160/180%. If this play is a critical play, the power of this receive is increased by [Receive] x 20%."},
  {nome:"A Flawless, All-Around Player", descricao:"When Kuroo Tetsuro (Hanabi) is in the front/back row and touches the ball, his [Reflex] is increased by 50% x the [Reflex] of each other allied member in the front/back row (maximum 100%), and his [Spirit] is increased by 50% x the [Spirit] of each other allied member in the front/back row (maximum 100%). Furthermore, when Kuroo Tetsuro (Hanabi) is in the front line, the [Attack Technique] of allied members is increased by 14/17/20%, and his block power is increased by [Block] x 45%. Furthermore when Kuroo Tetsuro is in the back row, the [Defensive Technique] of allied members increases by 14/17/20%, and his receiving power increases by [Receive] x 45%."},
  {nome:"Unpleasant Block", descricao:"Kuroo Tetsuro (Hanabi) performs a block with the power of [Block] x 280/300/320/340/360%. If this block does not bounce the ball back into the opponents court, the first ally’s reception after this play will not result in a point. If this block bounces the ball back into the opponents court, the main stats of all allied members will increase by 15%. This effect lasts until the ball goes over the net 8 times."}
], symbols: [ "img/receivesymbol.png", "img/blocksymbol.png" ] },
    { nome: "Kunimi SP", funcao: "OP", img: "img/kunimiSP.png", School: "Aoba Johsai", vinculo: ["Sports Festival"], Stats:{Serve:1674,Spike:1950,Set:1573,Receive:1857,Block:1762,Save:1570}, habilidades:[
  {nome:"Conserve Energy", descricao:"Kunimi (Sports Festival) gains +10%/13%/16% [Power Attack].If Kunimi’s Stamina is below 80, his [Power Attack] gains an additional +12%.While Kunimi is on the court, at the end of each rally, if his Stamina cap exceeds 80, his Stamina cap is reduced by 10 and he recovers 120 Stamina.While Kunimi is on the court, each time an ally’s Stamina decreases by 10, Kunimi gains 1 stack of [Stamina Reserve].For each stack of [Stamina Reserve], his [Awareness] increases by 7%.Up to 30 stacks, up to 10 stacks per rally."},
  {nome:"Precise Defense", descricao:"Kunimi Akira (Sports Festival) performs a receive with power [Receive] × 140%/160%/180%, and allies’ main parameter is increased by 10%. This effect lasts until the ball crosses the net twice."},
  {nome:"Give It Your All", descricao:"Each time Kunimi (Sports Festival) recovers Stamina, his [Power Attack] increases by 0.8%/1.1%/1.4% (up to +16%/22%/28%).At the start of a rally, if Kunimi’s Stamina cap is 80 or lower, he gains [Clutch Moment].While [Clutch Moment] is active, the cooldown of <Fiery Fighting Spirit> becomes 6 net crossings.If Kunimi’s [Awareness] exceeds 100%, for every +1% over, his [Power] increases by 0.9% (up to +90%).After gaining [Clutch Moment], for the first two activations, each time <Fiery Fighting Spirit> is usard, its cooldown is reset."},
  {nome:"Fiery Fighting Spirit", descricao:"Kunimi Akira (Sports Festival) consumes +8 Stamina and performs a [Power Attack] with power [Power Attack] × 295%/315%/335%/355%/375%.If Kunimi’s Stamina exceeds 50, the power of this attack is increased by [Power Attack] × 50%."}
], symbols: [ "img/receivesymbol.png", "img/powersymbol.png" ] },
    { nome: "Koganegawa SP", funcao: "S", img: "img/koganegawaSP.png", School: "Dateko", vinculo: ["Sports Festival","Teammates At Training Camp","Iron Wall"], Stats:{Serve:1766,Spike:1661,Set:1882,Receive:1661,Block:1970,Save:1573}, habilidades:[
  {nome:"Support Block", descricao:"Koganegawa's Toss +10%/13%/16%. When he is on the court and an ally serves, the serving member's Awareness increases by +20% for 1 rally (max 1 stack). Also gains 1 stack of Create Iron Wall. If a serve skill is activated during this serve, gain an additional 1 stack of Create Iron Wall. When Koganegawa is on the court, if allies perform a 2- or 3-man block, then the next time Koganegawa makes a toss, Awareness increases by 30% and Toss increases by 10%."},
  {nome:"Shortest Distance Setup", descricao:"Koganegawa tosses with power Toss × 140%/160%/180%. During the first ally spike (Power Attack / Quick Attack) after this activates, the spiking member's Awareness +10% and Power Attack / Quick Attack +15% for 2 net crossings. Additionally, the team's morale +6."},
  {nome:"Corner of the Iron Wall", descricao:"While Koganegawa is on the court, at the start of a rally, ally members with Reflex ≥200% gain +10% Attack Technique and +10% Defense Technique. When allies perform a 2- or 3-man block, or when an ally's block skill activates, gain 1 stack of Create Iron Wall (max 12). If stacks ≥3: allies' Awareness and Reflex +20%, and Koganegawa's Awareness and Reflex +30%. If stacks ≥7: at the start of a rally, allies' front-row Block increases by Koganegawa's Block × 12% (cap 800/900/1000). If stacks ≥10: allies with Awareness >100% gain +15% Power, and allies with Reflex >100% gain +25% Mental for 1 set."},
  {nome:"High Wall", descricao:"Performs a block with power Block × 260%/275%/290%/305%/320%. If this is a 2- or 3-person block, Koganegawa's Reflex +40%. If High Wall is not on cooldown, when another ally block Special Move activates, that block's power increases by the blocking member's Block × 100%, then High Wall enters cooldown."}
], symbols: [ "img/blocksymbol.png","img/settersymbol.png"] },
    { nome: "Oikawa SP", funcao: "S", img: "img/oikawaSP.png", School: "Aoba Johsai", vinculo: ["King and Great King"], Stats:{Serve:1,Spike:1,Set:1,Receive:1,Block:1,Save:1}, habilidades:[
  {nome:"100% Performance", descricao:"Oikawa [Toss] is increased by 10/13/16%. At the start of the rally, the member positioned diagonally opposite Oikawa gains the [Brilliance] effect. This effect lasts until the diagonally opposite member leaves the court. While a member has the [Brilliance] effect, that member’s [Awareness] is increased by 30%, [Reaction] is increased by 30%, and their main parameters are increased by 30%. Each time the ball is touched, allies gain 1 stack of the [Attack Rhythm] effect. For each stack of [Attack Rhythm], allies on the court have their [Awareness] increased by 1%, up to a maximum of 10 stacks. If Oikawa is on the court, whenever an ally activates their special move, they gain 1 additional stack of the [Attack Rhythm] effect."},
  {nome:"Sniper serve", descricao:"Oikawa  performs a jump serve with power equal to [Serve] ×160/180/200%. If this serve results in a service ace, the cooldown of this skill is reset. When the number of [Guidance] effect stacks reaches 5, the power of this serve is further increased by [Serve] ×150%."},
  {nome:"Command tower", descricao:"When Oikawa is on the court, if an ally performs a spike (power attack or quick attack) and the number of [Attack Rhythm] stacks is 6 or more, all [Attack Rhythm] stacks are consumed and Oikawa gains 1 stack of the [Guidance] effect, up to a maximum of 5 stacks. For each [Attack Rhythm] stack consumed, the power of the current spike (power/quick attack) is increased, and the ally performing the spike receives +15/17.5/20% to their [Power Attack/Quick Attack]. For each stack of [Guidance], allies’ [Awareness] increases (1st stack +40%, 2nd stack +30%, 3rd stack +20%, 4th stack +10%), and Oikawa  [Power] increases by 15% (up to a maximum of 60%). When the number of [Guidance] stacks reaches 5, whenever a member with the [Brilliance] effect scores, the cooldown of Oikawa skill is reset."},
  {nome:"Perfect toss", descricao:"Oikawa performs a toss with power equal to [Toss] ×260/275/290/305/320%. The opponent’s back-row [Receive] is reduced by 20%, and this effect lasts until the ball has crossed the net twice. After Oikawa’s toss, if the first spike (power attack or quick attack) is performed by an ally who has the [Brilliance] effect, the opponent’s front-row [Block] is reduced by 20%, and this effect also lasts until the ball has crossed the net twice. At the start of each set, when activating for the first time, allies gain 5 stacks of the [Attack Rhythm] effect."}
], symbols: [ "img/powersymbol.png","img/settersymbol.png"] }
];
window.characters = characters;           // <- essencial para o Import
// (opcional) se quiser cobrir ambos os nomes:
window.charactersEN = window.characters;
window.allCharacters = window.characters;
const descricoesSinergia = {
"Karasuno": "Increases ALL players’ Power Attack and Quick Attack Stats by 10%",
"Nekoma": "Increases ALL players’ Receive Stat by 15%",
"Dateko": "Increases ALL players’ Block Stat by 15%",
"Aoba Johsai": "Increases ALL players’ Power Attack Stat by 15%",
"Shiratorizawa": "Increases ALL players’ Awareness and Strength Stats by 10%",
"Fukurodani": "Team Morale will increase by 20",
"Inarizaki": "Increases ALL players’ Strength and Defense Stats by 5%",
"Eccentric Duo": "Increases Hinata and Kageyama’s quick attack power and Awareness.",
"Karasuno Geniusars": "Increases Nishinoya SP’s reflex and Receive. When Nishinoya usars his special move, Kageyama UR gains one stack of Competitive Spirit*. If his special is a perfect play, the power of the first Spike (Power Attack or Quick Attack) after that play is increased by 20% of the attacker’s power",
"Cherry Blossom Viewing": "Increases Kenma SP’s Awareness. Increases Hinata SP’s Quick Attack if it is a perfect play",
"Sun vs Moon": "When a player performs a set, [Awareness] increases. If Hinata SP performs a Quick Attack, and the result is critical, the cooldown of High Jump is reduced, and Tsukishima SP’s [Awareness] is increased.",
"After School": "Increases Nishinoya SP’s reflex; when his stamina is low, increases it even more",
"Guardian God and Wing Spiker": "When Nishinoya SSR or Azumane SSR usar a skill, both increase their Attack Technique and Defense Technique",
"Kiyoko Squad": "When scoring, increases Team Morale",
"Brain and Commander": "When Kenma SSR makes a pass, Kuro UR performs a strengthened Quick Attack",
"Educational Guidance": "Increases Yaku SSR’s Receive and Lev SSR’s Quick Attack",
"Swimming": "(Activates with 3 players) Increases team morale. When team morale is active, increases allies’ reflex in double or triple blocks",
"The Silent and the Sarcastic": "Allows Aone SSR and Futakuchi SSR to usar the Double Block skill",
"The New Captain and the Tall Rookie": "Increases the Block of players in the front row",
"Perfect Harmony": "When Oikawa UR makes a pass, Iwaizumi SSR Spikes with increased Power Attack. Gains 2 stacks of Attack Rhythm*, each stack increases the team’s Awareness by 1%. Maximum of 10 stacks.",
"The Pack": "Increases Power Attack of Iwaizumi SSR and Kentaro SSR",
"Besties for Life": "Increases Ushijima UR’s Power Attack and Tendo SSR’s Defense Technique",
"Absolute Champion and Steady Setter": "When Shirabu SSR makes a pass, Ushijima UR Spikes with 10% more power",
"Shiratorizawa’s WS": "Increases Power Attack of ALL players present",
"Miracle Ace and Caring Setter": "Bokuto UR comes out of depression. When Akaashi SSR makes a pass and Bokuto UR Spikes, increases his Power Attack for that Spike by 20% and raises team morale by 15",
"Ace Miraculous and Caring Setter": "Increases Akaashi SP’s Passing. When team morale is active, increases Bokuto SP’s Power Attack by 18% and Akaashi SP’s Passing by 5%",
"Twin Power": "When Atsumu UR makes a pass and Osamu UR makes a Minus Tempo Quick Attack, increases the Quick Attack of that play. Increases Attack Technique by 15%. The attack cannot be blocked.",
"Twin Heads": "Increases Osamu UR’s Attack Technique. Increases Kita SSR’s Stats. At the start of the match Atsumu gains 3 stacks of Perfect Hit*, each increasing his Passing by 2%. Max 10 stacks. Kita SSR gains a similar buff that increases his Receive. Max 3 stacks. The twins’ first Quick Attack per set is increased by Quick Attack × 12%",
"Longtime Friends": "The [Block] of allied frontline is increased. At the start of the match, Hoshiumi Korai gains the [All-Rounder] effect, and Hirugami gains the [Strong Block] effect.",
"Top Spiker and Top Libero": "Sakusa UR increases his Power Attack. Komori UR increases his Receive. Increases allies’ Receive by 20%",
"Fireworks Festival": "Allies’ main stats increase by 6%.At the end of each rally, inflict [Angry] on the opponent’s front row (their [Power Spike]/[Quick Attack] –10%).This lasts until the ball has crossed the net 8 times.If a target already has [Angry], apply [Distracted] instead (their [Power Spike]/[Quick Attack] –20%).This also lasts until the ball has crossed the net 8 times.[Distracted] cannot be cleansed/removed.",
"Brain and Commander SP": "When Kenma SP and Kuro SP are on court, can activate the quick attack skill Brain and Commander*",
"Sports Festival": "When an ally member touches the ball, consume 1 Stamina and increase that member’s main parameters by 3%/3.5%/4%/4.5%/5% for 2 net crossings. If that ball touch is a block, that member’s Block increases by an additional 5% for 2 net crossings.",
"Teammates At Training Camp" : "Ally members on the court with a block skill gain +6%/7%/8%/9%/10% Block. The cooldown of <Block System> is reduced by 2 net crossings. When an ally member activates a serve skill, inflict Anger on the opponent’s back row (Power Attack / Quick Attack −10%) for 8 net crossings.",
"Iron Wall" : "When Koganegawa is on the court, if at least 2 members included in the Bond Skill are present, the Bond Skill becomes active. When allies perform a 2-person/3-person block, front-row allies’ Defense Technique increases by 3%/4%/5%/6%/7% for 1 rally. When an ally activates a serve skill, the serve will not fail. During rallies where an ally activates a serve skill, if allies perform a 2-person/3-person block, gain 1 stack each of Powerful Block and Create Iron Wall (only activates if the corresponding member is on the court).",
"King and Great King" : "Kageyama Tobio and Oikawa compete for the right to serve, with victory going to the one who activates their serve skill first. If Oikawa wins, Kageyama gains the [Brilliance] effect, which lasts for 1 set. If Kageyama wins, then each time Oikawa touches the ball, Kageyama gains 1 stack of the [Hates Losing] effect. Additionally, whenever Oikawa activates a skill, Kageyama gains another stack of the [Hates Losing] effect."
};
    
/** Catálogo de MEMÓRIAS (exemplos; ajuste/expanda à vontade) */
const memoryCatalog = [
  {
    id:"mem_op",
    name:"Memória de OP",
    positions:["OP"],
    bonus:{
      Serve:{flat:518}, Spike:{flat:663}, Set:{flat:461},
      Receive:{flat:663}, Block:{flat:605}, Save:{flat:490}
    },
    desc:"When a member with this memory plays for the first time in each set, their [Receive] increases by 24%. This effect lasts for 3 rallies.",
    img:"img/memories/MemoOP.png"
  },
  {
    id:"mem_l",
    name:"Memória de L",
    positions:["L"],
    bonus:{
      Serve:{flat:490}, Spike:{flat:518}, Set:{flat:605},
      Receive:{flat:663}, Block:{flat:461}, Save:{flat:663}
    },
    desc:"The main parameters of the member who has this memory set will increase by 6.4%.If the corresponding member's receive result is not BAD, the power of the next powerful hit of the ally will be increased by [Power Hit] x 24% of the member performing the powerful hit.",
    img:"img/memories/MemoL.png"
  },
  {
    id:"mem_ws",
    name:"Memória de WS",
    positions:["WS"],
    bonus:{
      Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461},
      Receive:{flat:663}, Block:{flat:518}, Save:{flat:490}
    },
    desc:"The member who has this memory set will have their [Power Hit] increased by 12%.When the affected member hits a powerful shot, the opposing member's [Block] will be reduced by 6.4%. This effect will last until the ball goes over the net once.If the opponent's block result for this play is BAD, the opposing team member who blocked will have their [Block] reduced by 6.4%. This effect lasts until the ball goes over the net twice.",
    img:"img/memories/MemoWS.png"
  },
  {
    id:"mem_s",
    name:"Memória de S",
    positions:["S"],
    bonus:{
      Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663},
      Receive:{flat:490}, Block:{flat:605}, Save:{flat:461}
    },
    desc:"When a member with this memory is on the court, the [Toss] of allied members will increase by 8%.Once per set, when a member's stamina drops below 30, that member's stamina will be restored by 24.",
    img:"img/memories/MemoS.png"
  },
  {
    id:"mem_mb",
    name:"Memória de MB",
    positions:["MB"],
    bonus:{
      Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461},
      Receive:{flat:518}, Block:{flat:663}, Save:{flat:490}
    },
    desc:"The [Quick Attack] of the member who has this memory set is increased by 12%.For each Block member in the opponent's front line, that member's [Quick Attack] increases by an additional 6.4%",
    img:"img/memories/MemoMB.png"
  },
  {
    id:"mem_up_consciencia_wakatoshi_ushijima",
    name:"Ushijima UR",
    positions:["OP"],
    bonus:{
      Serve:{flat:570}, Spike:{flat:729}, Set:{flat:507},
      Receive:{flat:729}, Block:{flat:665}, Save:{flat:539}
    },
    desc:"The [Awareness] of the member who sets this memory is increased by 20%. If the member's [Awareness] exceeds 20%, for every 1% increase in [Awareness], [Power] increases by 1% (up to 100%).",
    img:"img/memories/MemoUshijimaUR.png"
  },
  {
    id:"mem_ofensive_up_osamu_miya",
    name:"Osamu UR",
    positions:["OP"],
    bonus:{
      Serve:{flat:570}, Spike:{flat:729}, Set:{flat:507},
      Receive:{flat:729}, Block:{flat:665}, Save:{flat:539}
    },
    desc:"The [Quick Attack] of the member who has this memory set is increased by 24%. If the member's [Attack Technique] exceeds 40%, the [Quick Attack] increases × Quick Attack by 48%.",
    img:"img/memories/MemoOsamuUR.png"
  },
  {
    id:"mem_receba_reforco_hard_hit_daichi_sawamura",
    name:"Daichi SSR",
    positions:["OP"],
    bonus:{
      Serve:{flat:518}, Spike:{flat:663}, Set:{flat:461},
      Receive:{flat:663}, Block:{flat:605}, Save:{flat:490}
    },
    desc:"The [Receive] of the member who has this memory set is increased by 20%. If the member is on the court, gain 1 stack of [Guts] effect every time your Power-type member consumes 20 stamina. Each stack increases Power Spike power by 4% of Power Attack stat, up to 10 stacks",
    img:"img/memories/MemoDaichiSSR.png"
  },
  {
    id:"mem_reacao_para_cima_akinori_konoha",
    name:"Konoha SSR",
    positions:["OP"],
    bonus:{
      Serve:{flat:518}, Spike:{flat:663}, Set:{flat:461},
      Receive:{flat:663}, Block:{flat:605}, Save:{flat:490}
    },
    desc:"The main parameters of the members who set this memory have increased by 12%. The member's [Reflex] increases the morale of × allies' team by 10%. While an ally has activated Team Morale Awakening, that member's [Reflex] is increased by 8%.",
    img:"img/memories/MemoKonohaSSR.png"
  },
  {
    id:"mem_ofensive_up_kentaro_kyotani",
    name:"Kentaro MAD DOG SSR",
    positions:["OP"],
    bonus:{
      Serve:{flat:518}, Spike:{flat:663}, Set:{flat:461},
      Receive:{flat:663}, Block:{flat:605}, Save:{flat:490}
    },
    desc:"If the member with this memory is on the court, the [Power] of the friendly hitting member is increased by 12%. When the member is on the court and the opponent's Stamina is below 60, the opponent's [Block] is reduced by 16%. This effect lasts until the ball crosses the net 3 times, and can be activated once per set per member",
    img:"img/memories/MemoKentaroSSR.png"
  },
  {
    id:"mem_param_main_e_hard_hit_takehito_sasaya",
    name:"Sasaya SSR",
    positions:["OP"],
    bonus:{
      Serve:{flat:518}, Spike:{flat:663}, Set:{flat:461},
      Receive:{flat:663}, Block:{flat:605}, Save:{flat:490}
    },
    desc:"The [Power Attack] and [Block] of the members who set this memory are increased by 12%. If the score is led by the opponent, the member's spike power increases by 28% × [Power Attack].",
    img:"img/memories/MemoSasayaSSR.png"
  },
  {
    id:"mem_defense_up_yu_nishinoya_depois_da_escola",
    name:"Nishinoya SP",
    positions:["L"],
    bonus:{
      Serve:{flat:619}, Spike:{flat:656}, Set:{flat:765},
      Receive:{flat:838}, Block:{flat:583}, Save:{flat:838}
    },
    desc:"The member who has this memory set will have their [Receive] increased by 24%. When the corresponding member's special move is activated, [Reflex] increases by 1.2% and [Spirit] increases by 2.4%. Up to 5 stacks. If the member usars a special move more than twice during a rally, the member's stamina will be restored by 10, and the next time the member usars a special move, their [Defensive Technique] will increase by 16%. This effect will last until the ball goes over the net twice.",
    img:"img/memories/MemoNishinoyaSP.png"
  },
  {
    id:"mem_defense_offensive_up_motoya_komori",
    name:"Komori UR",
    positions:["L"],
    bonus:{
      Serve:{flat:619}, Spike:{flat:656}, Set:{flat:838},
      Receive:{flat:838}, Block:{flat:583}, Save:{flat:765}
    },
    desc:"The member who has this memory set will have their [Receive] increased by 24%. When the corresponding member receives, the [Defensive Technique] of the allied rear guard will increase by 2%. Up to 3 stacks. If the relevant member is on the court, when an ally member activates a receiving skill, the receiving member recovers 2 stamina and increases [Powerful Hit/Quick Attack] by 15%. This effect lasts until the ball goes over the net twice.",
    img:"img/memories/MemoKomoriUR.png"
  },
  {
    id:"mem_defense_up_yu_nishinoya",
    name:"Nishinoya SSR",
    positions:["L"],
    bonus:{
      Serve:{flat:490}, Spike:{flat:518}, Set:{flat:605},
      Receive:{flat:663}, Block:{flat:461}, Save:{flat:663}
    },
    desc:"If the member who has this memory set is on the court, increases your side's back row players' Save stat by 8%. If the equipper's stamina consumption is 8 or more when the receive skill is activated, the equipper's [Receiving] increases by 20% and recovers 2 stamina",
    img:"img/memories/MemoNishinoyaSSR.png"
  },
  {
    id:"mem_receba_morisuke_yaku",
    name:"Yaku SSR",
    positions:["L"],
    bonus:{
      Serve:{flat:490}, Spike:{flat:518}, Set:{flat:605},
      Receive:{flat:663}, Block:{flat:461}, Save:{flat:663}
    },
    desc:"When a member with this memory sets receives, [Receive] increases by 4%. Up to 5 stacks. If the member's receive result is PERFECT, the next quick attack power after an ally increases the [Quick Attack] × of the member who is fast attacking by 32%.",
    img:"img/memories/MemoYakuSSR.png"
  },
  {
    id:"mem_receba_haruki_komi",
    name:"Haruki SSR",
    positions:["L"],
    bonus:{
      Serve:{flat:490}, Spike:{flat:518}, Set:{flat:605},
      Receive:{flat:663}, Block:{flat:461}, Save:{flat:663}
    },
    desc:"The [Receive] and [Save] of the members who set this memory increased by 16%. If the member's receive or cover result is not BAD, the team's morale increases by 10. In addition, the power of the next Power Spike of an ally increases the [Power Spike] of the member × Power Spike' stat by 10%.",
    img:"img/memories/MemoHarukiSSR.png"
  },
  {
    id:"mem_receba_yamagata_hayato",
    name:"Memo Yamagata SSR",
    positions:["L"],
    bonus:{
      Serve:{flat:490}, Spike:{flat:518}, Set:{flat:605},
      Receive:{flat:663}, Block:{flat:461}, Save:{flat:663}
    },
    desc:"The [Receive] of the member who has this memory set is increased by 20%. When the member activates the receiving special move, [Reflex] is increased by 12%.",
    img:"img/memories/MemoYamagataSSR.png"
  },
  {
    id:"mem_defense_up_michinari_akagi",
    name:"Memo Akagi SSR",
    positions:["L"],
    bonus:{
      Serve:{flat:490}, Spike:{flat:518}, Set:{flat:605},
      Receive:{flat:663}, Block:{flat:461}, Save:{flat:663}
    },
    desc:"The [Receive] of the member who has this memory set is increased by 20%. If the member's receiving or save result is not BAD, the friendly member's [Defensive Technique] is increased by 16%. Up to 3 stacks. This effect lasts for 1 rally",
    img:"img/memories/MemoAkagiSSR.png"
  },
  {
    id:"mem_power_up_shouyou_hinata_hanami",
    name:"Hinata SP",
    positions:["MB"],
    bonus:{ Serve:{flat:619}, Spike:{flat:838}, Set:{flat:656}, Receive:{flat:838}, Block:{flat:765}, Save:{flat:583} },
    desc:"Increases the [Power] of the member who has this memory set by 24%. If the member's quick attack is a nice play, increase the [Power] of the member by 2%. Up to 5 stacks. If the team member's quick attack is a good play and the opponent's blocker does not touch the ball, the opponent's front line's [Reflex] and [Spirit] will be reduced by 8% and 8%, respectively. This effect will last until the ball goes over the net 10 times.",
    img:"img/memories/MemoHinataSP.png"
  },
  {
    id:"mem_hast_attack_block_up_tsukishima_firefly_display_de_fogos_de_artificio",
    name:"Tsuki SP",
    positions:["MB"],
    bonus:{ Serve:{flat:619}, Spike:{flat:838}, Set:{flat:656}, Receive:{flat:765}, Block:{flat:838}, Save:{flat:583} },
    desc:"The [Quick Attack] of the member who has this memory set is increased by 24%. If the member makes a nice play, [Block] is increased by 9%. Up to 3 stacks. Randomly inflicts the [Suppress] disadvantage effect on one member on the opponent's court (main stats are reduced by 5%). This effect lasts until the ball goes over the net 8 times.",
    img:"img/memories/MemoTsukiSP.png"
  },
  {
    id:"mem_kurosp",
    name:"Kuro SP",
    positions:["MB"],
    bonus:{ Serve:{flat:765}, Spike:{flat:656}, Set:{flat:619}, Receive:{flat:838}, Block:{flat:838}, Save:{flat:583} },
    desc:"The [Block] is increased by 12%. When the corresponding member blocks or receives, if the member on the opponent's court has a disadvantageous effect, the corresponding member's [Defensive Technique] is increased by 20%. This effect lasts until the ball goes over the net four times",
    img:"img/memories/MemoKuroSP.png"
  },
  {
    id:"mem_tecnica_de_defesa_bloqueio_takashi_aone_banho_de_mar",
    name:"Aone SP",
    positions:["MB"],
    bonus:{ Serve:{flat:838}, Spike:{flat:765}, Set:{flat:656}, Receive:{flat:619}, Block:{flat:838}, Save:{flat:583} },
    desc:"The [Defensive Technique] of the member who has this memory set increases by 12.8%. When this member participates in a 2- or 3-man block, the [Block] of the allied front line is increased by 12%. This effect lasts until the ball goes over the net twice. When the member blocks, if this play results in a 2/3 block, the member's [Block] will be increased by an additional 15%. This effect lasts until the ball goes over the net twice.",

    img:"img/memories/MemoAoneSP.png"
  },
  {
    id:"mem_hast_attack_blockup_tetsuro_kuroo",
    name:"Kuro UR",
    positions:["MB"],
    bonus:{ Serve:{flat:665}, Spike:{flat:729}, Set:{flat:507}, Receive:{flat:570}, Block:{flat:729}, Save:{flat:539} },
    desc:"The member who has this memory set will have their [Block] increased by 24%.Each time the member gains the [Quick Attack] boost from a member skill, they gain one stack of [Tighten]. Each stack of [Tighten] increases [Block] by 2.4%. Up to 10 stacks. When the corresponding member's Block Special Move is activated, 10 stacks of the [Constrict] effect are consumed, and the cooldown of the corresponding member's Block Special Move is reduced by 10 times the ball has gone over the net.",
    img:"img/memories/MemoKuroUR.png"
  },
  {
    id:"mem_block_up_hirugami_yukoro",
    name:"Hirugami UR",
    positions:["MB"],
    bonus:{ Serve:{flat:729}, Spike:{flat:665}, Set:{flat:507}, Receive:{flat:570}, Block:{flat:729}, Save:{flat:539} },
    desc:"The member who has this memory set will have their [Block] increased by 20%. When an ally scores, their [Block] is increased by 4.8%. Up to 3 stacks. If an ally has the [Strong Block] effect, when they block, their [Defensive Technique] increases by 2.4%. This effect lasts until the ball goes over the net four times. Up to 3 stacks.",
    img:"img/memories/MemoHirugamiUR.png"
  },
  {
    id:"mem_increase_consciousness_shoyo_hinata",
    name:"Hinata SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"The [Awareness] of the members who set this memory is increased by 16%. If the member's [Awareness] is 40% or higher, [Awareness] is increased by an additional 16% and Blocked is reduced by 8%.",
    img:"img/memories/MemoHinataSSR.png"
  },
  {
    id:"mem_block_up_tsukishima",
    name:"Tsuki SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"The [Block] of the member who has this memory set is increased by 20%. When the member activates the blocking special move, if the opponent member who has made a spike (power/quick attack) has a disadvantageous effect, the power of this block increases by 32% × that member's [Block]",
    img:"img/memories/MemoTsukiSSR.png"
  },
  {
    id:"mem_offensive_up_tetsuro_kuroo_pratica",
    name:"Kuro SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"The [Awareness] of the members who set this memory is increased by 16%. When the member is blocked, [Defensive Technique] increases by 24% of their Strength.",
    img:"img/memories/MemoKuroSSR.png"
  },
  {
    id:"mem_block_up_tatsuo",
    name:"Tatsuo SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"The [Block] of the member who has this memory set is increased by 24%. When the member blocks, if the opponent's spike (power/quick attack) becomes a nice play, this block will definitely be a nice play. If the result of this block is not BAD, the member's [Block] will be increased by 5%. Up to 3 stacks",
    img:"img/memories/MemoTatsuoSSR.png"
  },
  {
    id:"mem_receive_up_ataque_rapido_reforco_haiba_lev",
    name:"Lev SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"If the member who has this memory set is on the court, the [Receive] of the teammate defender is increased by 12%. If the member is on the court and the ally's receive result is PERFECT, the power of the member's next quick attack special move increases by 24% × [Quick Attack] ",
    img:"img/memories/MemoLevSSR.png"
  },
  {
    id:"mem_defense_up_takanobu_aone",
    name:"Aone SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"The [Defensive Technique] of the members who set this memory has increased by 16%. If the member's block result is not BAD, the opponent's stamina is reduced by 2 after the spike (slam/quick attack). If the opponent's member who made the spike is a Power spike member, they lose 1 more stamina.",
    img:"img/memories/MemoAoneSSR.png"
  },
  {
    id:"mem_block_up_tendo_satoru",
    name:"Tendo SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"The [block] of the member who has this memory set is increased by 28%. If the member's block becomes a nice play, the cooldown of the block's special move is reduced by 3 times the ball goes over the net",
    img:"img/memories/MemoTendoSSR.png"
  },
  {
    id:"mem_fast_attack_up_rintaro_suna",
    name:"Rintaro SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"The [Quick Attack] of the member who has this memory set is increased by 20%. If the opponent's blocking member has a disadvantage when the member attacks quickly, the power of this quick attack increases by 40% × that member's [Quick Attack].",
    img:"img/memories/MemoRintaroSSR.png"
  },
    {
id:"mem_akaashi_sp",
name:"Akaashi SP",
positions:["S"],
bonus:{ Serve:{flat:838}, Spike:{flat:656}, Set:{flat:838}, Receive:{flat:619}, Block:{flat:765}, Save:{flat:583} },
desc:"[Set] increases by 24% for the equipper. While an ally's Team Morale Awakening is active, the equipper's [Awareness] increases by 10%. Allies who have the [Excellent Condition] effect gain +15% to their Main Parameter. When an ally loses the [Excellent Condition] effect, all allies' [Reaction] increases by 10% until the ball crosses the net 8 times.",
img:"img/memories/MemoAkaashiSP.png"
},
  {
id:"mem_sugawara_sp",
name:"Sugawara SP",
positions:["S"],
bonus:{ Serve:{flat:838}, Spike:{flat:656}, Set:{flat:838}, Receive:{flat:619}, Block:{flat:765}, Save:{flat:583} },
desc:"The equipper's Main Parameter increases by 16%. When the equipper performs a Set, for every 6 current Stamina they have, the spiker's [Power/Quick Attack] increases by 2% (up to 30%). This effect lasts until the ball crosses the net twice. When the equipper activates a Skill and Stamina is consumed, restore 10 Stamina to the ally with the lowest Stamina.",
img:"img/memories/MemoSugawaraSP.png"
},
  {
id:"mem_kenma_sp",
name:"Kenma SP",
positions:["S"],
bonus:{ Serve:{flat:765}, Spike:{flat:656}, Set:{flat:838}, Receive:{flat:838}, Block:{flat:619}, Save:{flat:583} },
desc:"[Reaction] increases by 16%. When an opponent's Power/Quick Spike is a Nice Play, an ally who activates a Block or Receive skill gains 1 stack of [Stick]; for each stack, [Reaction] increases by 4% (max 3 stacks). If such an ally has 3 stacks, consume them to increase that ally's [Reaction] by 100% until the ball crosses the net once.",
img:"img/memories/MemoKenmaSP.png"
},
  {
id:"mem_oikawa_ur",
name:"Oikawa UR",
positions:["S"],
bonus:{ Serve:{flat:729}, Spike:{flat:570}, Set:{flat:729}, Receive:{flat:539}, Block:{flat:665}, Save:{flat:507} },
desc:"[Serve] increases by 24%. When this member's serve is a [Nice Play], gain 2 stacks of [Rhythm of Attack]. For each stack, allies on the court gain +1% [Awareness], up to 10 stacks. If this serve results in a service ace, gain 4 additional stacks. While this member is on the court, each time [Rhythm of Attack] reaches 6 stacks, allies' [Power] and [Mental] increase by 4%, up to 3 stacks.",
img:"img/memories/MemoOikawaUR.png"
},
  {
id:"mem_kageyama_ur",
name:"Kageyama UR",
positions:["S"],
bonus:{ Serve:{flat:729}, Spike:{flat:570}, Set:{flat:729}, Receive:{flat:539}, Block:{flat:665}, Save:{flat:507} },
desc:"[Set] increases by 24%. When this member activates a Two Attack skill, their [Power] increases by 40% of [Awareness], up to +100%. Also, when this member activates a Two Attack skill, the power of the next ally Spike (Power/Quick) increases by 28% of the spiking member's [Power/Quick Attack].",
img:"img/memories/MemoKageyamaUR.png"
},
  {
id:"mem_atsumu_ur",
name:"Atsumu UR",
positions:["S"],
bonus:{ Serve:{flat:729}, Spike:{flat:570}, Set:{flat:729}, Receive:{flat:539}, Block:{flat:665}, Save:{flat:507} },
desc:"[Set] increases by 24%. While the equipper is on the court, allies on the court whose [Awareness] and [Reaction] are below 20% gain +6.4% to [Attack Technique] and [Defense Technique]. If an ally's play is not a [Nice Play], the equipper's [Attack Technique] and [Defense Technique] increase by 2% per stack (max 5 stacks), lasting for 1 rally.",
img:"img/memories/MemoAtsumuUR.png"
},
  {
id:"mem_kageyama_ssr_serve",
name:"Kageyama SSR",
positions:["S"],
bonus:{ Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663}, Receive:{flat:490}, Block:{flat:605}, Save:{flat:461} },
desc:"[Serve] increases by 20%. When this member activates a Two Attack Ultimate, allies' [Awareness] increases by 20%, and this member's [Awareness] increases by an additional 15%.",
img:"img/memories/MemoKageyamaSSR.png"
},
  {
id:"mem_kenma_ssr",
name:"Kenma SSR",
positions:["S"],
bonus:{ Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663}, Receive:{flat:490}, Block:{flat:605}, Save:{flat:461} },
desc:"[Set] increases by 8%. While the equipper is on the court, back-row allies' [Receive] increases by 12%. While the equipper is on the court, when an ally's [Connect] stacks decrease, allies gain 1 stack of [Connect]; for each stack, allies on the court gain +1% [Receive], up to 6 stacks.",
img:"img/memories/MemoKenmaSSR.png"
},
  {
id:"mem_akaashi_ssr",
name:"Akaashi SSR",
positions:["S"],
bonus:{ Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663}, Receive:{flat:490}, Block:{flat:605}, Save:{flat:461} },
desc:"[Set] increases by 12%. While an ally's Team Morale Awakening is active, when this member performs a Set, the spiking ally (Power/Quick) recovers 4 Stamina and that Spike gains +16% [Attack Technique]. When this member dispels an ally's debuff, also remove that ally's [Slump Mode] effect.",
img:"img/memories/MemoAkaashiSSR.png"
},
  {
id:"mem_oikawa_ssr",
name:"Oikawa SSR",
positions:["S"],
bonus:{ Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663}, Receive:{flat:490}, Block:{flat:605}, Save:{flat:461} },
desc:"[Set] increases by 20%. The first time in each set that allies' [Rhythm of Attack] reaches 10 or more stacks, this member's [Set] increases by an additional 20% (lasts for 1 set). For each stack of [Rhythm of Attack], allies on the court gain +1% [Awareness], up to 10 stacks.",
img:"img/memories/MemoOikawaSSR.png"
},
  {
id:"mem_koganegawa_ssr",
name:"Koganegawa SSR",
positions:["S"],
bonus:{ Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663}, Receive:{flat:490}, Block:{flat:605}, Save:{flat:461} },
desc:"[Set] increases by 16%. While the equipper is on the court, if an ally's Block result is not [BAD], the opponent's next Power Spike power decreases by 20% of the spiking member's [Power Attack]. While the equipper is on the court, if an ally's Block result is [BAD], the power of the next ally Block increases by 32% of the blocking member's [Block].",
img:"img/memories/MemoKoganegawaSSR.png"
},
  {
id:"mem_shirabu_ssr",
name:"Shirabu SSR",
positions:["S"],
bonus:{ Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663}, Receive:{flat:490}, Block:{flat:605}, Save:{flat:461} },
desc:"[Set] increases by 16%. When this member's Set is a [Nice Play], the ally performing a Power Spike gains +32% [Power] until the ball crosses the net once.",
img:"img/memories/MemoShirabuSSR.png"
},
  {
id:"mem_semi_ssr",
name:"Semi SSR",
positions:["S"],
bonus:{ Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663}, Receive:{flat:490}, Block:{flat:605}, Save:{flat:461} },
desc:"When this member serves, [Awareness] increases by 16%. When this member activates a Serve Ultimate, [Serve] increases by 6.4%, up to 3 stacks.",
img:"img/memories/MemoSemiSSR.png"
},
    {
    id:"mem_bokuto_sp",
    name:"Bokuto SP",
    positions:["WS"],
    bonus:{ Serve:{flat:765}, Spike:{flat:838}, Set:{flat:583}, Receive:{flat:838}, Block:{flat:656}, Save:{flat:619} },
    desc:"The [Power] of the member who has this memory set is increased by 24%. When the corresponding member hits hard, [Attack Technique] increases by 5%. If the remaining duration of an ally's Team Morale Awakening is 6 or more ball touches, [Attack Technique] is increased by an additional 20%.",
    img:"img/memories/MemoBokutoSP.png"
},
  {
    id:"mem_offense_defense_up_hoshiumi_ur",
    name:"Hoshiumi UR",
    positions:["WS"],
    bonus:{ Serve:{flat:665}, Spike:{flat:729}, Set:{flat:507}, Receive:{flat:729}, Block:{flat:570}, Save:{flat:539} },
    desc:"[Attack Technique] and [Defense Technique] increase by 6.4%. When the member's Skill/Special is activated, their [Main Parameter] increases by 2% (max 10 stacks). If the play is a [Nice Play], gain 1 additional stack.",
    img:"img/memories/MemoHoshiumiUR.png"
},
  {
    id:"mem_bokuto_ur",
    name:"Bokuto UR",
    positions:["WS"],
    bonus:{ Serve:{flat:665}, Spike:{flat:729}, Set:{flat:507}, Receive:{flat:729}, Block:{flat:570}, Save:{flat:539} },
    desc:"The member who has this memory set will have their [Power Hit] increased by 24%. Each time an ally activates Team Morale Awakening, that member's [Power Attack] increases by 8%, up to 3 stacks. When the relevant member is on the court, the duration of the team morale boost for allies is increased by 2 ball touches.",
    img:"img/memories/MemoBokutoUR.png"
    },
  {
    id:"mem_Sakusa_ur",
    name:"Sakusa UR",
    positions:["WS"],
    bonus:{ Serve:{flat:765}, Spike:{flat:838}, Set:{flat:583}, Receive:{flat:838}, Block:{flat:656}, Save:{flat:619} },
    desc:"The member who has this memory set will have their [Power Hit] increased by 24%. When the corresponding member receives, [Attack Technique] increases by 15% until the ball goes over the net twice. After receiving, the corresponding member's [Mental] increases by 8%, up to 4 stacks.",
    img:"img/memories/MemoSakusaUR.png"
    },
   {
    id:"mem_yui_ssr",
    name:"Yui SSR",
    positions:["WS"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
    desc:"[Receive] increases by 20%. When this member receives, [Power Attack] increases by 16% and lasts until the ball has crossed the net six times. If this member's receive is a [Nice Play], their next Power Attack is guaranteed to be a [Nice Play].",
    img:"img/memories/MemoYuiSSR.png"
    },
   {
    id:"mem_oshiro_ssr",
    name:"Oshiro SSR",
    positions:["WS"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
    desc:"[Power Attack] increases by 20%. For every 6 Stamina recovered by this member, [Power Attack] increases by 6.3%. This effect lasts until the ball has crossed the net five times. If the Stamina recovered in a single instance exceeds 10, [Attack Technique] increases by 6.4%; this effect lasts until the ball has crossed the net five times.",
    img:"img/memories/MemoOshiroSSR.png"
},
    {
    id:"mem_kita_ssr",
    name:"Kita SSR",
    positions:["WS"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
    desc:"[Receive] increases by 20%. If this member's receive is not a [Nice Play], the power of the next ally's receive increases by 40% of the receiving member's [Receive] stat.",
    img:"img/memories/MemoKitaSSR.png"
},
    {
    id:"mem_tanaka_ssr",
    name:"Tanaka SSR",
    positions:["WS"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
    desc:"[Power Attack] increases by 20%. For this member, up to the second Power Spike in each set, the finishing power increases by 36% of [Power Attack].",
    img:"img/memories/MemoTanakaSSR.png"
},
    {
id:"mem_azumane_ssr",
name:"Azumane SSR",
positions:["WS"],
bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
desc:"If the member equipping this memory has 50 or more Stamina, [Power Attack] increases by 36%. When this member activates a Power Spike skill and the Stamina consumed is 20 or more, this Power Spike's power increases by 32% of [Power Attack].",
img:"img/memories/MemoAzumaneSSR.png"
},
    {
id:"mem_iwaizumi_ssr",
name:"Iwaizumi SSR",
positions:["WS"],
bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
desc:"[Wing Spiker] Exclusive: Increases [Receive] by 10%. When the equipper executes a Critical Power Spike Ultimate, increases [Power Attack] by 8% of [Receive] for 3 net crossings.",
img:"img/memories/MemoIwaizumiSSR.png"
},
    {
id:"mem_futakuchi_ssr",
name:"Futakuchi SSR",
positions:["WS"],
bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
desc:"[Block] increases by 20%. For each ally Block-type member on the court, this member's Special finishing power increases by 6.4% of the parameter corresponding to that Special.",
img:"img/memories/MemoFutakuchiSSR.png"
},
    {
id:"mem_goshiki_ssr",
name:"Goshiki SSR",
positions:["WS"],
bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
desc:"[Power Attack] increases by 20%. While an ally's Team Morale Awakening is active, this member's [Power Attack] increases by 32%.",
img:"img/memories/MemoGoshikiSSR.png"
},
   
    {
id:"mem_terushima_ssr",
name:"Terushima SSR",
positions:["WS"],
bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
desc:"[Power Attack] increases by 24%. When this member activates the [Choose More] effect, gain 2 stacks of [Choose More] and increase back-row allies' [Receive] by 12% for 1 rally. For each stack of [Choose More], [Power Attack]/[Quick Attack] increases by 2.5%, up to 4 stacks.",
img:"img/memories/MemoTerushimaSSR.png"
},
   
    {
id:"mem_OHIRA_ssr",
name:"Ohira SSR",
positions:["WS"],
bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
desc:"When a member with this memory activates a skill, [Awareness] and [Reflex] increase by 3.2%. Stacks up to 5 times.",
img:"img/memories/MemoOhiraSSR.png"
},
    {
    id:"mem_kunimi",
    name:"Kunimi SP",
    positions:["OP"],
    bonus:{
      Serve:{flat:765}, Spike:{flat:838}, Set:{flat:583},
      Receive:{flat:838}, Block:{flat:656}, Save:{flat:619}
    },
    desc:"While this Memory is equipped, the member’s [Power Attack] is increased by 24%.If that member’s Stamina is below 80, their [Attack Technique] is increased by 12%.Each time that member’s Stamina is restored, their [Power] increases by 6% (max 5 stacks).",
    img:"img/memories/MemoKunimiSP.png"
  },
{
    id:"mem_koganegawa",
    name:"Koganegawa SP",
    positions:["S"],
    bonus:{
      Serve:{flat:765}, Spike:{flat:656}, Set:{flat:838},
      Receive:{flat:619}, Block:{flat:838}, Save:{flat:583}
    },
    desc:"The Block of the member who has this memory set is increased by 24%. If the member is participating in a 2-piece/3-piece block, the Toss of the member is increased by 3%. Up to 5 stacks. When the member is on the Court, the Defensive Technique of the front line ally is increased by 16% when the ally serves. This effect lasts for 1 rally.",
    img:"img/memories/MemoKoganegawaSP.png"
  },
{
    id:"mem_oikawaSP",
    name:"Oikawa SP",
    positions:["S"],
    bonus:{
      Serve:{flat:838}, Spike:{flat:656}, Set:{flat:838},
      Receive:{flat:619}, Block:{flat:765}, Save:{flat:583}
    },
    desc:"The member equipped with this memory has their [Toss] increased by 24%. At the start of a rally, if the number of ally [Attack Rhythm] stacks exceeds 2, the member equipped with this memory has their attack parameters ([Power Attack], [Quick Attack], [Toss], [Serve], [Awareness], [Power], [Attack Technique]) increased by 10%. This effect lasts for 1 rally.",
    img:"img/memories/MemoOikawaSP.png"
  },
];

/** Catálogo de SETS (POTENTIAL)  * */
const setCatalog = [
  {
  id:"set_rapid_quick_attack",
  name:"Rapid Quick Attack",
  twoPiece:{ Spike:{ pct:15 } },
  fourPiece:{Spike:{ pct:15 }}, // condicional
  img:"img/sets/rapid_quick_attack.png",
  desc2:"2p: Increases Quick Attack stat by 15%.",
  desc4:"2p: Increases Quick Attack stat by 15%. 4p: Each time Quick Spike is usard, increases Quick Spike stat by 5%, up to 5 stacks."
},
{
  id:"set_sharp_sense",
  name:"Sharp Sense",
  twoPiece:{ Spike:{ pct:15 } },
  fourPiece:{Spike:{ pct:15 }}, // condicional
  img:"img/sets/sharp_sense.png",
  desc2:"2p: Increases Quick Attack stat by 15%.",
  desc4:"2p: Increases Quick Attack stat by 15%. 4p: Increases Awareness by 15%; when Quick Spike is Critical, increases Strength by 10%."
},
{
  id:"set_power_vibe",
  name:"Power Vibe",
  twoPiece:{ Spike:{ pct:15 } },
  fourPiece:{Spike:{ pct:15 }}, // condicional
  img:"img/sets/power_vibe.png",
  desc2:"2p: Increases Power Attack stat by 15%.",
  desc4:"2p: Increases Power Attack stat by 15%. 4p: Increases Awareness by 15%; when Power Spike is Critical, increases Strength by 10%."
},
{
  id:"set_power_rise",
  name:"Power Rise",
  twoPiece:{ Spike:{ pct:15 } },
  fourPiece:{Spike:{ pct:15 }}, // condicional
  img:"img/sets/power_rise.png",
  desc2:"2p: Increases Power Attack stat by 15%.",
  desc4:"2p: Increases Power Attack stat by 15%. 4p: Increases Attack Technique by 10% when using Power Spike; when scoring with Power Spike, recovers 5 Stamina."
},
{
  id:"set_precise_serve",
  name:"Precise Serve",
  twoPiece:{ Set:{ pct:15 } },
  fourPiece:{Set:{ pct:15 }}, // condicional
  img:"img/sets/precise_serve.png",
  desc2:"2p: Increases Set stat by 15%.",
  desc4:"2p: Increases Set stat by 15%. 4p: Serves never fail and increases Attack Technique by 15% when serving."
},
{
  id:"set_precise_set",
  name:"Precise Set",
  twoPiece:{ Set:{ pct:15 } },
  fourPiece:{Set:{ pct:15 } }, // condicional
  img:"img/sets/precise_set.png",
  desc2:"2p: Increases Set stat by 15%.",
  desc4:"2p: Increases Set stat by 15%. 4p: Increases setting power by 15% of the Set stat." 
},
{
  id:"set_precise_block",
  name:"Precise Block",
  twoPiece:{ Block:{ pct:15 } },
  fourPiece:{Block:{ pct:15 }}, // efeito condicional descrito abaixo
  img:"img/sets/precise_block.png",
  desc2:"2p: Increases Block stat by 15%.",
  desc4:"2p: Increases Block stat by 15%. 4p: When blocking a Power Spike, increases this block's power by 20% of the Block stat."
},
{
  id:"set_block_movement",
  name:"Block Movement",
  twoPiece:{ Block:{ pct:15 } },
  fourPiece:{Block:{ pct:15 }}, // efeito condicional descrito abaixo
  img:"img/sets/block_movement.png",
  desc2:"2p: Increases Block stat by 15%.",
  desc4:"2p: Increases Block stat by 15%. 4p: When blocking a spike with other Block-type players present in the front row, increases this block's power by 20% of the Block stat."
},
 {
    id:"set_assist_receive",
    name:"Assist Receive",
    twoPiece:{ Receive:{ pct:15 } },
    fourPiece:{Receive:{ pct:15 }}, // efeito condicional descrito abaixo
    img:"img/sets/assist_receive.png",
    desc2:"2p: Increases Receive stat by 15%.",
    desc4:"2p: Increases Receive stat by 15%. 4p: When achieving a PERFECT receive, increases your side's next spike power by 30% of the spiker's Power/Quick Attack stat."
  },
  {
    id:"set_supreme_receive",
    name:"Supreme Receive",
    twoPiece:{ Receive:{ pct:15 } },
    fourPiece:{Receive:{ pct:15 }}, // efeito condicional descrito abaixo
    img:"img/sets/supreme_receive.png",
    desc2:"2p: Increases Receive stat by 15%.",
    desc4:"2p: Increases Receive stat by 15%. 4p: When receiving a Quick Spike, increases this reception's power by 30% of the Receive stat."
  }
];
    window.STATS_BONDS = {
  "Aoba Johsai's Sophomore": { "Watari SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Yahaba SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Kentaro SSR": "No buff" },
  "Behind the Smile": { "Daichi SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Kuro UR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "Bench cheer": { "Hisashi R": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Kazuhito R": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Building Team Chemistry": { "Kageyama SSR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Tanaka SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "Cannon \\& Iron Wall": { "Azumane SSR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%", "Aone SSR": "No buff" },
  "Cannon and Iron Wall": { "Aone SP": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Azumane SSR": "" },
  "Classmates": { "Suna SSR": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Osamu UR": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Date Kogyo's Captains": { "Kaname SR": "No buff", "Kenji SSR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%" },
  "Date Kogyo's Junior": { "Jingo R": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Sakunami R": "Quick Attack +5/7/9/12/15, Quick Attack stat by 6/7/8/9/10%" },
  "Date Kogyo's Setter": { "Kaname SR": "No buff", "Kaji SSR": "Set +5/7/9/12/15, Set +1/2/3/4/5%" },
  "Fated Rivals": { "Oikawa UR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Ushijima UR": "" },
  "Flexible Aces": { "Hinata SSR": "Block +5/7/9/12/15, Block +1/2/3/4/5%", "Lev SSR": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%" },
  "Formidable Opponent": { "Nishinoya SR": "Save +5/7/9/12/15, Save +1/2/3/4/5%", "Yaku SR": "Set +5/7/9/12/15, Set +1/2/3/4/5%" },
  "Friends from Volleyball Class": { "Atsumu UR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Osamu UR": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Ojiro SSR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%" },
  "Fukurodani 3rd Years": { "Bokuto UR": "", "Komi SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Konoha": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Sarukui SSR": "Power +5/7/9/12/15, Power +1/2/3/4/5%", "Washio SSR": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Fukurodani MBs": { "Washio SSR": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Onaga R": "" },
  "Fukurodani WS": { "Bokuto UR": "", "Sarukui": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%" },
  "Grit and Competitive": { "Yamamoto SR": "No buff", "Kenma SSR": "Set +5/7/9/12/15, Set +1/2/3/4/5%" },
  "Hidden Fire": { "Kentaro SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Yahaba SR": "No buff" },
  "Inarizaki 2nd Years": { "Suna SSR": "Quick Spike +5/7/9/12/15, Quick Spike +1/2/3/4/5%", "Ginjima SSR": "Power Spike +5/7/9/12/15, Power Spike +1/2/3/4/5%", "Osamu UR": "Quick Spike +5/7/9/12/15, Quick Spike +1/2/3/4/5%", "Atsumu UR": "", "Kosaku R": "" },
  "Inarizaki WS Teammates": { "Kita SSR": "Cover +5/7/9/12/15, Cover +1/2/3/4/5%", "Ojiro SSR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Ginjima SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Kosaku R": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Riseki R": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%" },
  "Japan Youth Training Camp Teammates": { "Kageyama UR": "", "Atsumu UR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Sakusa UR": "Strong Spike +5/7/9/12/15, Strong Spike +1/2/3/4/5%", "Komori UR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Hoshiumi UR": "Strong Spike +5/7/9/12/15, Strong Spike +1/2/3/4/5%" },
  "Karasuno 3rd Years": { "Azumane SSR": "Power +5/7/9/12/15, Power +1/2/3/4/5%", "Daichi SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Sugawara SP": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Karasuno's Failing Grades Group": { "Hinata SSR": "", "Kageyama UR": "", "Nishinoya SSR": "", "Tanaka SSR": "Strong Attack +5/7/9/12/15, Strong Attack +1/2/3/4/5%" },
  "Karasuno's Red Mark Squad (Hanami ver.)": { "Hinata SP": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Nishinoya SP": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Tanaka SSR": "", "Kageyama UR": "" },
  "Karasuno's Setters": { "Sugawara SR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Kageyama UR": "" },
  "Karasuno's Wing Spiker": { "Tanaka SR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%", "Azumane SR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Chikara SR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%" },
  "Leaders Cut from the Same Cloth": { "Daichi SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Kuro SSR": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Master and Apprentice": { "Tsuki SSR": "Block +5/7/9/12/15, Block +1/2/3/4/5%", "Kuro UR": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Nekoma's Junior": { "Teshiro SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Inuoka SR": "No buff", "Lev SSR": "No Buff" },
  "Number One Disciple": { "Bokuto UR": "Spike +5/7/9/12/15, Spike +1/2/3/4/5%", "Hinata SSR": "" },
  "Number One Disciple SP": { "Hinata SP": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Bokuto SP": "Strong Attack +5/7/9/12/15, Strong Attack +1/2/3/4/5%" },
  "One-on-One Training": { "Lev SR": "Block +5/7/9/12/15, Block +1/2/3/4/5%", "Yaku SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "Perseverance and Tenacity": { "Kenma SP": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Yamamoto SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "Prediction VS System": { "Tsuki SSR": "No buff", "Tendo SSR": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Promising Senpai": { "Tendo SSR": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Goshiki SSR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%" },
  "Reliable Seniors": { "Kuro UR": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Yaku SSR": "", "Kai SR": "" },
  "Rival Friends": { "Hinata SSR": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Kenma SSR": "Set +5/7/9/12/15, Set +1/2/3/4/5%" },
  "Shiratorizawa 2nd Years": { "Shirabu SSR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Taichi SR": "Quick +5/7/9/12/15, Quick +1/2/3/4/5%" },
  "Shiratorizawa 3rd Years": { "Ushijima UR": "", "Yamagata SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Ohira SSR": "Spike +5/7/9/12/15, Spike +1/2/3/4/5%", "Semi SSR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Tendo SSR": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Silence and Sarcasm": { "Aone SP": "Block +5/7/9/12/15, Block +1/2/3/4/5%", "Futakuchi SSR": "" },
  "Simulated Junior Training Teamate": { "Kanji SR": "Set +5/7/9/12/15, Set +1/2/3/4/5%", "Tsuki SR": "No buff" },
  "Strange Friendship": { "Hinata SP": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Aone SP": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Team's Guardians": { "Nishinoya SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Yaku SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "Team's Guardians (After School)": { "Nishinoya SP": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Yaku SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "The \"Enigmatic\" Teammate": { "Lev SSR": "Block +5/7/9/12/15, Block +1/2/3/4/5%", "Kenma SSR": "No buff" },
  "The Absolute King VS the Freak Duo": { "Ushijima UR": "Spike +5/7/9/12/15, Spike +1/2/3/4/5%", "Hinata SSR": "", "Kageyama UR": "" },
  "The King and The Great King": { "Kageyama UR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Oikawa UR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%" },
  "The Moment They Fell for Volleyball": { "Bokuto SP": "Spikes +5/7/9/12/15, Spikes +1/2/3/4/5%", "Tsuki SP": "Quick +5/7/9/12/15, Quick +1/2/3/4/5%" },
  "Third Year from Inarizaki": { "Kita SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Ojiro SSR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%", "Akagi SSR": "Cover +5/7/9/12/15, Cover +1/2/3/4/5%", "Omimi SR": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "To Greater Heights": { "Kindaichi SR": "", "Oikawa UR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%" },
  "Tokyo Training Camp Buddies": { "Bokuto SP": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Akaashi SP": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Tsuki SP": "Block +5/7/9/12/15, Block +1/2/3/4/5%", "Kuro SP": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Tokyo Training Camp Self-Practice Buddies": { "Bokuto UR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Akaashi SSR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Kuro UR": "", "Tsuki SSR": "" },
  "Two High-Energy Guys": { "Bobata R": "", "Terushima SSR": "Attack +5/7/9/12/15, Attack +1/2/3/4/5%" },
  "Undisputed Aces": { "Goshiki SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Ushijima UR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%" },
  "Ushiwaka and Benkei": { "Ushijima UR": "Block +5/7/9/12/15, Block +1/2/3/4/5%", "Ohira SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "Worthy Rival": { "Hinata SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Inuoka SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "Youth Camp Setters": { "Kageyama UR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Atsumu UR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%" },
  "Youth Training Camp": { "Hoshiumi UR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Kageyama UR": "" },
  "Similar Builds": { "Hinata SP": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Hoshiumi UR": "Strong Attack +5/7/9/12/15, Strong Attack +1/2/3/4/5%" },
  "Similar Physique Teammates": { "Hinata SSR": "", "Hoshiumi UR": "Power Strike +5/7/9/12/15, Power Strike +1/2/3/4/5%" },
  "Kiyoko's Protection Group": {"Tanaka SSR":"Strong Attack +5/7/9/12/15, Strong Attack +1/2/3/4/5%", "Nishinoya SP":"Receive +5/7/9/12/15, Receive +1/2/3/4/5%"},
  "Date Tech’s Setters": {"Koganegawa SP":"Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Moniwa SR":"Toss +5/7/9/12/15, Toss +1/2/3/4/5%"},
  "New-type Rookie & the New Captain": {"Koganegawa SP":"Block +5/7/9/12/15, Block +1/2/3/4/5%","Futakuchi SSR":"Block +5/7/9/12/15, Block +1/2/3/4/5%"}
};
window.STATS_BOND_MEMBERS = {
  // Exemplo; substitua pelo seu conteúdo completo:
  "Aoba Johsai's Sophomore": ["Watari SR, Yahaba SR, Kentaro SSR"],
  "Behind the Smile": ["Daichi SSR, Kuro UR"],
  "Bench cheer": ["Hisashi R, Kazuhito R"],
  "Building Team Chemistry": ["Kageyama SSR, Tanaka SR"],
  "Cannon \\& Iron Wall": ["Azumane SSR, Aone SSR"],
  "Cannon and Iron Wall": ["Aone SP, Azumane SSR"],
  "Classmates": ["Suna SSR, Osamu UR"],
  "Date Kogyo's Captains": ["Kaname SR, Kenji SSR"],
  "Date Kogyo's Junior": ["Jingo R, Sakunami R"],
  "Date Kogyo's Setter": ["Kaname SR, Kaji SSR"],
  "Fated Rivals": ["Oikawa UR, Ushijima UR"],
  "Flexible Aces": ["Hinata SSR, Lev SSR"],
  "Formidable Opponent": ["Nishinoya SR, Yaku SR"],
  "Friends from Volleyball Class": ["Atsumu UR, Osamu UR, Ojiro SSR"],
  "Fukurodani 3rd Years": ["Bokuto UR, Komi SR, Konoha, Sarukui SSR, Washio SSR"],
  "Fukurodani MBs": ["Washio SSR, Onaga R"],
  "Fukurodani WS": ["Bokuto UR, Sarukui"],
  "Grit and Competitive": ["Yamamoto SR, Kenma SSR"],
  "Hidden Fire": ["Kentaro SSR, Yahaba SR"],
  "Inarizaki 2nd Years": ["Suna SSR, Ginjima SSR, Osamu UR, Atsumu UR, Kosaku R"],
  "Inarizaki WS Teammates": ["Kita SSR, Ojiro SSR, Ginjima SSR, Kosaku R, Riseki R"],
  "Japan Youth Training Camp Teammates": ["Kageyama UR, Atsumu UR, Sakusa UR, Komori UR, Hoshiumi UR"],
  "Karasuno 3rd Years": ["Azumane SSR, Daichi SSR, Sugawara SP"],
  "Karasuno's Failing Grades Group": ["Hinata SSR, Kageyama UR, Nishinoya SSR, Tanaka SSR"],
  "Karasuno's Red Mark Squad (Hanami ver.)": ["Hinata SP, Nishinoya SP, Tanaka SSR, Kageyama UR"],
  "Karasuno's Setters": ["Sugawara SP, Kageyama UR"],
  "Karasuno's Wing Spiker": ["Tanaka SR, Azumane SR, Chikara SR"],
  "Leaders Cut from the Same Cloth": ["Daichi SR, Kuro SSR"],
  "Master and Apprentice": ["Tsuki SSR, Kuro UR"],
  "Nekoma's Junior": ["Teshiro SR, Inuoka SR, Lev SSR"],
  "Number One Disciple": ["Bokuto UR, Hinata SSR"],
  "Number One Disciple SP": ["Hinata SP, Bokuto SP"],
  "One-on-One Training": ["Lev SR, Yaku SR"],
  "Perseverance and Tenacity": ["Kenma SP, Yamamoto SR"],
  "Prediction VS System": ["Tsuki SSR, Tendo SSR"],
  "Promising Senpai": ["Tendo SSR, Goshiki SSR"],
  "Reliable Seniors": ["Kuro UR, Yaku SSR, Kai SR"],
  "Rival Friends": ["Hinata SSR, Kenma SSR"],
  "Shiratorizawa 2nd Years": ["Shirabu SSR, Taichi SR"],
  "Shiratorizawa 3rd Years": ["Ushijima UR, Yamagata SSR, Ohira SSR, Semi SSR, Tendo SSR"],
  "Silence and Sarcasm": ["Aone SP, Futakuchi SSR"],
  "Simulated Junior Training Teamate": ["Kanji SR, Tsuki SR"],
  "Strange Friendship": ["Hinata SP, Aone SP"],
  "Team's Guardians": ["Nishinoya SSR, Yaku SSR"],
  "Team's Guardians (After School)": ["Nishinoya SP, Yaku SSR"],
  "The \"Enigmatic\" Teammate": ["Lev SSR, Kenma SSR"],
  "The Absolute King VS the Freak Duo": ["Ushijima UR, Hinata SSR, Kageyama UR"],
  "The King and The Great King": ["Kageyama UR, Oikawa UR"],
  "The Moment They Fell for Volleyball": ["Bokuto SP, Tsuki SP"],
  "Third Year from Inarizaki": ["Kita SSR, Ojiro SSR, Akagi SSR, Omimi SR"],
  "To Greater Heights": ["Kindaichi SR, Oikawa UR"],
  "Tokyo Training Camp Buddies": ["Bokuto SP, Akaashi SP, Tsuki SP, Kuro SP"],
  "Tokyo Training Camp Self-Practice Buddies": ["Bokuto UR, Akaashi SSR, Kuro UR, Tsuki SSR"],
  "Two High-Energy Guys": ["Bobata R, Terushima SSR"],
  "Undisputed Aces": ["Goshiki SSR, Ushijima UR"],
  "Ushiwaka and Benkei": ["Ushijima UR, Ohira SSR"],
  "Worthy Rival": ["Hinata SSR, Inuoka SR"],
  "Youth Camp Setters": ["Kageyama UR, Atsumu UR"],
  "Youth Training Camp": ["Hoshiumi UR, Kageyama UR"],
  "Similar Builds": ["Hinata SP, Hoshiumi UR"],
  "Similar Physique Teammates": ["Hinata SSR, Hoshiumi UR"],
  "Kiyoko's Protection Group": ["Tanaka SSR, Nishinoya SP"],
  "Date Tech’s Setters":["Koganegawa SP, Moniwa SR"],
  "New-type Rookie & the New Captain":["Koganegawa SP, Futakuchi SSR"]
};

let selecionados = [];

let teams = window.teams || [];            // se já existir, reutiliza
let currentTeamIndex = window.currentTeamIndex || 0;
let __mtAdding = false;                    // lock anti-duplo clique

// ===== Backend (Apps Script) =====
const API = 'https://script.google.com/macros/s/AKfycbxNmBqnW8mSeNUBdBCxlaXRgEajY_GrTXIJPo_2PrMm2v_ZhsRsvW50K9cZzaGOqyu5/exec'; // o mesmo usado no contador de views

// sesssion_id estável por navegador (para cooldown de comentários e analytics)
const SESSION_KEY = 'hqSessionIdV1';
const SESSION_ID = (() => {
  let id = localStorage.getItem(SESSION_KEY);
  if (!id) { id = 's_' + Math.random().toString(36).slice(2) + Date.now().toString(36); localStorage.setItem(SESSION_KEY, id); }
  return id;
})();

// idioma da página -> "ptbr" ou "en"
function currentLang(){
  const h = (document.documentElement.lang || '').toLowerCase();
  if (h.includes('pt')) return 'ptbr';
  return 'en';
}

async function apiGet(params){
  const url = API + (API.includes('?') ? '&' : '?') + params;
  const r = await fetch(url, {method:'GET', mode:'cors'});
  return r.json();
}
async function apiPost(action, payload){
  const url = API + (API.includes('?') ? '&' : '?') + 'action=' + encodeURIComponent(action);
  const body = new URLSearchParams({ payload: JSON.stringify(payload) });
  const r = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8' },
    body
  });
  const text = await r.text();
  try { return JSON.parse(text); } catch { return { ok:false, raw:text }; }
}



// considera “completo” quando os 6 titulares estão preenchidos
function isTeamComplete(team){
  const filled = (team.main || []).filter(Boolean).length;
  return filled === 7; // ajuste se quiser exigir bench também
}

// serialização dos itens (fallback caso não exista no arquivo)
function serializeTeamItemsSafe(){
  try { return (typeof serializeTeamItems === 'function') ? serializeTeamItems() : {}; }
  catch(e){ return {}; }
}

// evita spam: só envia se mudou
let __lastSentHash = null;
// === Debounce para enviar o time automaticamente ===
let sendTimer = null;

function scheduleSendTeam(delay = 300){
  if (sendTimer) clearTimeout(sendTimer);
  sendTimer = setTimeout(sendTeamIfComplete, delay);
}
// chame isto sempre que o grid mudar (adicionar/trocar/remover)
function onGridChanged(){
  scheduleSendTeam(300);
}


// substitua sua sendTeamIfComplete por esta
async function sendTeamIfComplete(){
  try{
    // nomes atuais do grid
    const mainNames = [...document.querySelectorAll('.hex')].map(s=>s.dataset.nome).filter(Boolean);
    const benchNames = [...document.querySelectorAll('.bench-slot')].map(s=>s.dataset.nome).filter(Boolean);

    const isComplete = mainNames.length === 7; // exatamente 7 titulares
    // mapeia posição pelo rótulo ao lado/abaixo do slot ou via fallback POS_ORDER
    const hexes = [...document.querySelectorAll('.hex')];
    const POS_ORDER = ['S','MB','WS','L','WS','MB','OP']; // já existe no seu arquivo

    const slots = hexes.slice(0, 7).map((el, i) => {
      const id = el.dataset.key || el.dataset.id || el.dataset.nome || '';
      // tenta ler o rótulo (S/MB/WS/L/OP)
      const parent = el.closest('.slot, .slot-wrap, .slot-container, .grid-cell, .hex-wrap') || el.parentElement;
      const label = parent && parent.querySelector('.pos, .role, .slot-role, .slot-label, .position, .label');
      const txt = (label?.textContent || el.nextElementSibling?.textContent || '').trim().toUpperCase();
      const pos = /^(S|MB|WS|L|OP)$/.test(txt) ? txt : (POS_ORDER[i] || 'WS');
      return { id, pos };
    }).filter(s => s.id); // só slots preenchidos

    if (isComplete && slots.length === 7){
      await apiPost('setteam', { session_id: SESSION_ID, team: { slots, bench: benchNames } });
    } else {
      await apiPost('clearteam', { session_id: SESSION_ID });
    }
  }catch(e){
    console.warn('sendTeamIfComplete error', e);
  }
}



// pluga nos hooks globais que você já expõe (sem mexer em setCharacter)
(function hookSends(){
  const oldAfterAssign = window.afterAssignCharacter;
  window.afterAssignCharacter = function(el, nome){
    if (typeof oldAfterAssign === 'function') oldAfterAssign(el, nome);
    sendTeamIfComplete();
  };
  const oldAfterRemove = window.afterRemoveCharacter;
  window.afterRemoveCharacter = function(el){
    if (typeof oldAfterRemove === 'function') oldAfterRemove(el);
    sendTeamIfComplete();
  };
})();
let RANK = { week:[], all:[], chars:[] };
let SHOWN = { week:5, all:5 };

function fmtTeamRow(t){
  // miniaturas no item (ver item 3 abaixo para CSS/lookup)
  const imgs = (t.team?.slots||[]).slice(0,7).map(s=>{
    const ch   = findCharPreferExact(s.id);
    const src = ch?.img || '';
    const title = s.id;
    return `<img class="mini-char" src="${src}" alt="${title}" title="${title}">`;
  }).join('');
  const cnt = t.count ?? t.hits ?? 0;
  return `
    <li class="top-row-li">
      <span class="mini-line">${imgs}</span>
      <small>x${cnt}</small>
      <button data-import="${t.team_id}" class="btn-imp">Import</button>
      <button data-comments="${t.team_id}" class="btn-cmt" title="Comments">💬</button>
    </li>`;
}
window.CHAR_BY_FULL = new Map(
  (window.CHAR_LIST || []).map(c => [`${c.name} ${c.rarity}`.toUpperCase(), c])
);

// preferir match EXATO com raridade; se não achar, usa seu fuzzy atual
function findCharPreferExact(q){
  const s = String(q || '').trim();
  if (!s) return null;
  const exact = window.CHAR_BY_FULL.get(s.toUpperCase());
  return exact || (typeof findCharByAnyName === 'function' ? findCharByAnyName(s) : null);
}
function fmtCharRow(c){
  // c pode vir como {id,name,count|hits|value|tester,...}
  const key   = c?.id || c?.name || '';
  const count = c?.tester ?? c?.value ?? c?.count ?? c?.hits ?? c?.total ?? 0;

  // tenta achar os metadados/imagem do personagem por nome
  // (usa o mesmo helper que você já usa nos times)
  const meta = findCharPreferExact(key);
  const src   = meta?.img || meta?.icon || ''; // fallback se houver outro campo
  const title = key;

  return `
    <li class="top-row-li char-row">
      <span class="mini-line">
        <img class="mini-char" src="${src}" alt="${title}" title="${title}">
        <span class="char-name">${title}</span>
      </span>
      <small>x${count}</small>
    </li>
  `;
}
function aggregateCharRankingFromTeams(list){
  // list: array de objetos de ranking de times (RANK.all ou RANK.week)
  // soma aparições do personagem em cada envio (ponderado pelo hits/count/tester)
  const counts = new Map();
  for (const t of (list || [])){
    const weight = t?.tester ?? t?.value ?? t?.count ?? t?.hits ?? t?.total ?? 1;
    const ids = [
      ...((t?.team?.slots || []).map(s => s?.id).filter(Boolean)),
      ...((t?.team?.bench || []).filter(Boolean)) // se bench vier como array simples de nomes
    ];
    for (const id of ids){
      // trata nomes de forma estável, sem mesclar UR/SP
      const key = String(id).trim();
      counts.set(key, (counts.get(key) || 0) + Number(weight || 1));
    }
  }
  // ordena e retorna no formato esperado pelo render
  return [...counts.entries()]
    .sort((a,b)=> b[1]-a[1])
    .map(([name, tester]) => ({ name, tester }));
}

function renderRankTeams7d(){
  const el = document.getElementById('panelRank7d');
  if(!el) return;
  el.innerHTML = `
    <h3 class="top-title">Top Teams (7d)</h3>
    <ul class="top-list">${ (RANK.week||[]).slice(0, SHOWN.week).map(fmtTeamRow).join('') || '<li>—</li>' }</ul>
    <div class="center"><button id="wkMore" class="menu-btn">Show More</button></div>
  `;
  el.querySelector('#wkMore')?.addEventListener('click', (ev)=>{
    ev.stopPropagation?.();
    SHOWN.week += 5;
    renderRankTeams7d();
  });
}

function renderRankTeamsAll(){
  const el = document.getElementById('panelRankAll');
  if(!el) return;
  el.innerHTML = `
    <h3 class="top-title">Top Teams (All)</h3>
    <ul class="top-list">${ (RANK.all||[]).slice(0, SHOWN.all).map(fmtTeamRow).join('') || '<li>—</li>' }</ul>
    <div class="center"><button id="allMore" class="menu-btn">Show More</button></div>
  `;
  el.querySelector('#allMore')?.addEventListener('click', (ev)=>{
    ev.stopPropagation?.();
    SHOWN.all += 5;
    renderRankTeamsAll();
  });
}

function renderRankCharacters(){
  const el = document.getElementById('panelRankChar');
  if(!el) return;
  el.innerHTML = `
    <h3 class="top-title">Top Characters</h3>
    <ul class="top-list">${
  Array.isArray(RANK?.chars) && RANK.chars.length
    ? RANK.chars.map(fmtCharRow).join('')
    : '<li>—</li>'
}</ul>
  `;
}
function buildCharRankingFromTeams(teamRows){
  const map = new Map();
  const add = (name, weight) => {
    if (!name) return;
    map.set(name, (map.get(name) || 0) + (weight || 1));
  };

  (teamRows || []).forEach(t => {
    const weight = t.tester ?? t.value ?? t.count ?? t.hits ?? t.total ?? 1; // vezes que o time apareceu
    const slots  = t?.team?.slots || [];   // [{id, pos}]
    const bench  = t?.team?.bench || [];   // ["nome1","nome2",...]

    // titulares
    for (const s of slots) add(s?.id || s?.name, weight);
    // banco
    for (const b of bench) add(b, weight);
  });

  // transforma em array ordenado
  const arr = [...map.entries()]
    .map(([name, tester]) => ({ name, tester }))   // {name, tester} compatível com fmtCharRow
    .sort((a,b) => b.tester - a.tester);

  return arr;
}
// peso (hits/count/tester/total)
const weightOfTeam = (t)=>(t?.tester ?? t?.value ?? t?.count ?? t?.hits ?? t?.total ?? 0);
const weightOfChar = (c)=>(c?.tester ?? c?.value ?? c?.count ?? c?.hits ?? c?.total ?? 0);

// totais (serão preenchidos em loadRankings)
let TOTALS = { week:0, all:0, chars:0 };
async function loadRankings(){
  await ensureCharacterList(); // garante lista p/ thumbs
  const week = await apiGet('action=top_week&days=7');
  const allT = await apiGet('action=top_alltime');
  const topC = await apiGet('action=top_chars&topN=50');
  RANK.week = week?.top || [];
  RANK.all  = allT?.top || [];
  if (!Array.isArray(RANK.chars) || RANK.chars.length === 0){
  // usa o ALL por padrão para ranking de personagens (pode trocar para week se quiser)
  RANK.chars = buildCharRankingFromTeams(RANK.all);
}
  SHOWN.week = 5; SHOWN.all = 5;
  TOTALS.week  = (RANK.week  || []).reduce((s,t)=> s + weightOfTeam(t), 0);
  TOTALS.all   = (RANK.all   || []).reduce((s,t)=> s + weightOfTeam(t), 0);
TOTALS.chars = (RANK.chars || []).reduce((s,c)=> s + weightOfChar(c), 0);
  renderRankTeams7d();
renderRankTeamsAll();
renderRankCharacters();
}

// eventos dos botões “ver mais”
document.addEventListener('click', (ev)=>{
  if (ev.target?.id === 'wkMore'){ 
    ev.stopPropagation();
    SHOWN.week += 5; 
    renderRankTeams7d();
    renderRankTeamsAll();
    renderRankCharacters();
  }
  if (ev.target?.id === 'allMore'){ 
    ev.stopPropagation();
    SHOWN.all  += 5; 
    renderRankTeams7d();
    renderRankTeamsAll();
    renderRankCharacters();
  }
});

async function ensureCharacterList(){
  if (getCharList().length) return;
}
// --------- delegação de eventos (Import / Comments) ----------
document.addEventListener('click', async (ev)=>{
  const btn = ev.target.closest('[data-import],[data-comments]');
  if (!btn) return;

  // evita fechar a lateral/propagar para listeners globais
  ev.stopPropagation();

  // IMPORTAR TIME
  if (btn.hasAttribute('data-import')) {
    const teamId = btn.getAttribute('data-import');
    try {
      await ensureCharacterList(); // garante a lista carregada
      const r = await apiGet('action=getteam&team_id='+encodeURIComponent(teamId));
      if (!r?.ok || !r.team){ console.warn('getteam fail', r); alert('Não foi possível carregar esse time.'); return; }
      applyTeamFromServer(r.team); // preenche o grid
    } catch (e) {
      console.error('import error', e);
      alert('Erro ao importar time.');
    }
    return;
  }

  // COMENTÁRIOS
  if (btn.hasAttribute('data-comments')) {
    const teamId = btn.getAttribute('data-comments');
    try {
      await openCommentsUI(teamId); // abre o modal e carrega comentários
    } catch(e){
      console.error('comments error', e);
      alert('Não foi possível abrir os comentários.');
    }
  }
});

// aplica um time vindo da API ao teu grid
// ===== helpers =====
const POS_ORDER = ['S','MB','WS','L','WS','MB','OP'];

// Índice de match exato por nome COMPLETO (preserva UR/SSR/SP)
(function buildCharFullIndex(){
  const L = (window.characters || window.charactersEN || window.allCharacters || []);
  const m = new Map();
  const put = (k,c)=>{
    if (!k) return;
    const key = String(k).trim().toUpperCase().replace(/\s+/g,' ');
    if (key) m.set(key, c);
  };
  for (const c of L){
    put(c.nome, c);
    put(c.name, c);
    put(c.display, c);
    put(c.id, c);
  }
  window.CHAR_FULL = m;
})();

// Preferir EXATO (sem retirar raridade). Se não achar, cai no fuzzy antigo.
function findCharPreferExact(q){
  const s = String(q||'').trim();
  if (!s) return null;

  // 1) exato (case-insensitive, espaços normalizados)
  const key = s.toUpperCase().replace(/\s+/g,' ');
  const hit = window.CHAR_FULL && window.CHAR_FULL.get(key);
  if (hit) return hit;

  // 2) exato tolerante a acento
  const norm = (x)=>String(x||'').normalize('NFD').replace(/[\u0300-\u036f]/g,'').toUpperCase().replace(/\s+/g,' ');
  if (window.CHAR_FULL){
    const target = norm(s);
    for (const [k,v] of window.CHAR_FULL){
      if (norm(k) === target) return v;
    }
  }

  // 3) fallback: fuzzy existente (pode remover UR/SSR/SP etc.)
  return (typeof findCharByAnyName==='function') ? findCharByAnyName(s) : null;
}


function getHexList(){ return [...document.querySelectorAll('.hex')]; }

function clearGrid(){
  getHexList().forEach(el => { el.innerHTML=''; delete el.dataset.nome; });
  document.querySelectorAll('.bench-slot').forEach(el => { el.innerHTML=''; delete el.dataset.nome; });
  
}

function norm(s){
  return String(s||'').normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/\s+/g,' ').trim().toLowerCase();
}
function canon(s){
  return norm(String(s||'')
    .replace(/\s*-\s*(S|MB|WS|L|OP)\b/gi,'')
    .replace(/\b(UR|SSR|SP)\b/gi,'')
  );
}
function getCharList(){
  return window.characters || window.charactersEN || window.allCharacters || [];
}
function findCharByAnyName(name){
  const t = canon(name);
  const L = getCharList();
  return L.find(c => canon(c.nome)===t) ||
         L.find(c => canon(c.name)===t) ||
         L.find(c => canon(c.display)===t) ||
         L.find(c => canon(c.id)===t) || null;
}

function nextFreeSlotForPos(pos, usedIdx){
  const hexes = getHexList();

  // tentar por rótulo do slot
  for (let i=0;i<hexes.length;i++){
    if (usedIdx.has(i)) continue;
    const el = hexes[i];
    const parent = el.closest('.slot, .slot-wrap, .slot-container, .grid-cell, .hex-wrap') || el.parentElement;
    const label  = parent && parent.querySelector('.pos, .role, .slot-role, .slot-label, .position, .label');
    const txt = (label?.textContent || el.nextElementSibling?.textContent || '').trim().toUpperCase();
    if (['S','MB','WS','L','OP'].includes(txt) && txt === pos) return {el, i};
  }
  // fallback por ordem visual fixa
  for (let i=0;i<hexes.length;i++){
    if (usedIdx.has(i)) continue;
    if (POS_ORDER[i] === pos) return {el:hexes[i], i};
  }
  return {el:null, i:-1};
}

function safeSetCharacter(el, ch, pos){
  try {
    if (typeof setCharacter === 'function') {
      setCharacter(el, ch, ch.funcao || ch.role || pos);
      emitTeamChanged();
      return true;
      if (typeof emitTeamChanged==='function');
    }
  } catch(e){ console.warn('setCharacter falhou', e); }
  try {
    el.innerHTML = `<img src="${ch.img}" alt="${ch.nome||ch.name}">`;
    el.dataset.nome = ch.nome || ch.name || ch.id;
    return true;
  } catch(_) {}
  return false;
  
}

const wait = (ms)=>new Promise(r=>setTimeout(r,ms));


// tenta achar o elemento .hex do slot que TEM rótulo == pos (S,MB,WS,L,OP)
function getSlotElByPos(pos){
  const hexes = [...document.querySelectorAll('.hex')];
  // seletores comuns de rótulos sob/ao lado do slot – testamos vários
  const labelSelectors = ['.pos', '.role', '.slot-role', '.slot-label', '.position', '.label'];
  for (const el of hexes){
    const parent = el.closest('.slot, .slot-wrap, .slot-container, .grid-cell, .hex-wrap') || el.parentElement;
    if (!parent) continue;
    let labelText = '';
    for (const sel of labelSelectors){
      const lab = parent.querySelector(sel);
      if (lab){ labelText = (lab.textContent||'').trim().toUpperCase(); if (labelText) break; }
    }
    // fallback: se o texto do próximo irmão é só "S"/"MB"/etc
    if (!labelText && el.nextElementSibling){
      const txt = (el.nextElementSibling.textContent||'').trim().toUpperCase();
      if (/^(S|MB|WS|L|OP)$/.test(txt)) labelText = txt;
    }
    if (labelText === pos) return el;
  }
  // não achou por rótulo: tenta por índice fixo (ordem visual)
  const idx = POS_FALLBACK_ORDER.findIndex(p => p === pos);
  return hexes[idx] || null;
}



// ===== import principal =====
async function applyTeamFromServer(team){
  const slots = team.slots || [];
  const bench = team.bench || [];
  const used  = new Set();

  clearGrid();

  // titulares, um por vez
  for (const s of slots){
    const pos = (s.pos||'').toUpperCase();
    const ch  = findCharPreferExact(s.id);
    if (!ch){ console.warn('[import] personagem não encontrado:', s.id); continue; }

    const {el, i} = nextFreeSlotForPos(pos, used);
    if (!el){ console.warn('[import] slot livre não encontrado para', pos); continue; }

    used.add(i);
    safeSetCharacter(el, ch, pos);
    onGridChanged();
    await wait(40);
  }

  // banco
  const benchEls = [...document.querySelectorAll('.bench-slot')];
  for (let i=0;i<benchEls.length;i++){
    const name = bench[i] || '';
    if (!name) continue;
    const ch = findCharPreferExact(name);
    if (ch){ safeSetCharacter(benchEls[i], ch, 'BENCH'); await wait(20); }
  }

  if (typeof updateSynergies==='function') updateSynergies();
  if (typeof emitTeamChanged==='function') emitTeamChanged(); // conta no ranking


  // itens (opcional)
  try { if (typeof applyTeamItems === 'function') applyTeamItems(team.items||{}); } catch(_){}

  console.log(`[Import] Aplicado: ${applied} titulares`);
  console.groupEnd();

  // dispara o envio automático para contar no ranking
  emitTeamChanged();
  onGridChanged();
}



document.addEventListener('DOMContentLoaded', ()=>{
  // pré-carrega em background; quando abrir a página, já está pronto
  loadRankings().catch(()=>{});
});
setInterval(loadRankings, 60000);
async function openCommentsUI(team_id){
  const wrap = document.createElement('div');
  wrap.className = 'item-modal-backdrop';
  const box = document.createElement('div');
  box.className  = 'item-modal';
  wrap.appendChild(box);

  box.innerHTML = `
    <h3>Comments</h3>
    <div id="cList" style="max-height:260px; overflow:auto; border:1px solid #444; padding:8px; border-radius:8px; background:#1e1e1e;"></div>
    <div style="display:flex; gap:8px; margin-top:8px;">
      <input id="cNick" placeholder="Nick" style="flex:0 0 160px; padding:6px;">
      <input id="cMsg"  placeholder="Message..." style="flex:1; padding:6px;">
      <button id="cSend" class="item-btn">Send</button>
      <button id="cClose" class="item-btn">Close</button>
    </div>
  `;

  async function load(){
    const lang = currentLang(); // "ptbr" | "en"
    const r = await apiGet(`action=comments&team_id=${encodeURIComponent(team_id)}&limit=100&lang=${lang}`);
    const list = (r?.comments||[]);
    const html = list.map(c=>`<div style="padding:6px 4px;border-bottom:1px solid #333;"><b>${c.nick}</b> — <small>${(c.created_at||'').replace('T',' ')}</small><br>${c.message}</div>`).join('') || '<i>No comments yet.</i>';
    box.querySelector('#cList').innerHTML = html;
    // nick lembrado
    const saved = localStorage.getItem('hqNick');
    if(saved) box.querySelector('#cNick').value = saved;
  }

  box.querySelector('#cSend').addEventListener('click', async ()=>{
    const nick = (box.querySelector('#cNick').value || '').trim().slice(0,20);
    const message = (box.querySelector('#cMsg').value || '').trim().slice(0,300);
    if(!message){ box.querySelector('#cMsg').focus(); return; }
    localStorage.setItem('hqNick', nick || 'Anon');
    const res = await apiPost('addcomment', { team_id, nick: (nick||'Anon'), message, lang: currentLang(), session_id: SESSION_ID });
    if(res?.ok){
      box.querySelector('#cMsg').value = '';
      load(); // aparece sem recarregar a página
    }else if(res?.error === 'cooldown'){
      alert(`Aguarde ${res.seconds_left||120}s para comentar novamente.`);
    }else{
      alert('Falha ao enviar comentário.');
    }
  });
  box.querySelector('#cClose').addEventListener('click', ()=> wrap.remove());

  document.body.appendChild(wrap);
  load();
}
function debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms);} }
function emitTeamChanged(){ window.dispatchEvent(new Event('team:changed')); }
function setupAutoSendObservers(){
  const sendDebounced = debounce(()=>{ try{ sendTeamIfComplete(); }catch(e){ console.warn(e);} }, 300);

  // 2a) observar alterações nos slots titulares e bench
  const mo = new MutationObserver(() => onGridChanged());
  document.querySelectorAll('.hex, .bench-slot').forEach(el=>{
    mo.observe(el, {
      attributes:true,
      attributeFilter:['data-nome','src'],
      childList:true,
      subtree:false
    });
  });

  // 2b) escutar um evento global (vamos emitir em vários lugares)
  window.addEventListener('team:changed', () => scheduleSendTeam(300));

  // 2c) integrar com hooks já existentes (se existirem)
  const oldAfterAssign = window.afterAssignCharacter;
  window.afterAssignCharacter = function(el, nome){
    if (typeof oldAfterAssign === 'function') oldAfterAssign(el, nome);
    emitTeamChanged();
  };
  const oldAfterRemove = window.afterRemoveCharacter;
  window.afterRemoveCharacter = function(el){
    if (typeof oldAfterRemove === 'function') oldAfterRemove(el);
    emitTeamChanged();
  };

  // 2d) primeira checagem (página já pode abrir com time completo)
  setTimeout(sendDebounced, 500);
}

document.addEventListener('DOMContentLoaded', setupAutoSendObservers);

// se existir função que carrega time salvo ao trocar “Team 1/2/3…”
const oldLoadSaved = window.loadSavedTeam;
window.loadSavedTeam = function(...args){
  const r = oldLoadSaved ? oldLoadSaved.apply(this, args) : undefined;
  emitTeamChanged();
  return r;
};

// se o botão “+ Team” limpa/muda o grid:
const plus = document.querySelector('[data-action="add-team"], .btn-add-team, .plus-team');
if (plus) plus.addEventListener('click', ()=> setTimeout(emitTeamChanged, 200));
/* ====== FUNÇÕES ORIGINAIS (mantidas) ====== */
function addBenchSlot() {
    const benchRow = document.getElementById("bench-row");
    const slot = document.createElement("div");
    slot.className = "player-slot bench";
    slot.innerHTML = `<div class="bench-slot" data-role="bench"></div><div class="player-info">Bench</div>`;
    benchRow.insertBefore(slot, benchRow.querySelector(".add-slot-btn"));
    attachBenchEvents(slot.querySelector(".bench-slot"));
}

function attachBenchEvents(slot) {
  if (slot.__benchBound) return;         // evita duplicar handlers
  slot.__benchBound = true;

  let clickTimer = null;

  slot.addEventListener("click", (e) => {
    e.stopPropagation();

    // 2º clique dentro da janela => trata como duplo clique
    if (clickTimer) {
      clearTimeout(clickTimer);
      clickTimer = null;

      const nome = slot.dataset.nome;
      if (!nome) {
        // slot vazio: no duplo clique, abrimos o menu mesmo assim
        if (typeof showMenu === "function") showMenu("bench", slot);
        return;
      }

      const p = (typeof characters !== "undefined") && characters.find(x => x.nome === nome);
      if (!p) return;

      const sm = document.getElementById("scrollMenu");
      if (sm) sm.style.display = "none";     // fecha menu de seleção, se aberto

      if (typeof showCharacterDetails === "function") showCharacterDetails(p);

      const sidebar = document.getElementById("sidebar");
      const menuBtn = document.getElementById("menuBtn");
      if (sidebar) sidebar.classList.add("open");
      if (menuBtn) menuBtn.style.display = "none";
      return;
    }

    // 1º clique: se não vier 2º clique rápido, abre o menu do banco
    clickTimer = setTimeout(() => {
      clickTimer = null;
      if (typeof showMenu === "function") showMenu("bench", slot);
    }, 250);
  });

  // botão direito: remover do banco
  slot.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    if (typeof removeCharacter === "function") removeCharacter(slot);
  });
}

function isAllowedForStarterSlot(slotRole, charRole) {
  const slot = String(slotRole || '').toUpperCase();
  const role = String(charRole || '').toUpperCase();
  if (!slot || slot === 'BENCH') return true;   // segurança
  if (slot === 'L') return role === 'L';
  return role !== 'L';
}

function showMenu(role, slot) {
  const scrollMenu = document.getElementById("scrollMenu");
  scrollMenu.innerHTML = '';
  window.__lastMenuCtx = { role, slot };
  scrollMenu.style.display = 'flex';
  scrollMenu.style.flexDirection = 'column';

  const isBench = (role === 'bench');
  const slotRole = isBench ? 'bench' : (slot.dataset.role || slot.getAttribute('data-role'));

  // Cabeçalho com botões
  const bar = document.createElement('div');
  bar.className = 'bench-quick-inside';

  const ROLES = ['All','S','MB','WS','OP','L'];
  // Filtro inicial: se for L, começa em L; caso contrário, começa em All (não-L).
  let currentFilter = isBench ? 'All' : (ROLES.includes(String(slotRole).toUpperCase()) ? String(slotRole).toUpperCase() : 'All');

  function roleAllowedInThisSlot(r){
    if (r === 'All') return true; // "All" será interpretado como "todos permitidos"
    if (slotRole === 'bench') return true; // bench não restringe por função aqui
    // starters
    return isAllowedForStarterSlot(slotRole, r);
  }

  ROLES.forEach(r => {
    const b = document.createElement('button');
    b.textContent = r;
    b.dataset.role = r;

    // Botões inválidos para o slot ficam desabilitados
    if (!roleAllowedInThisSlot(r)) {
      b.disabled = true;
      b.classList.add('disabled');
    }

    if (r === currentFilter) b.classList.add('active');
    b.addEventListener('click', (e) => {
      e.stopPropagation();
      if (b.disabled) return;
      currentFilter = r;
      bar.querySelectorAll('button').forEach(x => x.classList.toggle('active', x === b));
      render();
    });
    bar.appendChild(b);
  });

  scrollMenu.appendChild(bar);

  // Container das imagens
  const grid = document.createElement('div');
  grid.style.display = 'flex';
  grid.style.flexWrap  = 'wrap';
  grid.style.gap = '8px';
  scrollMenu.appendChild(grid);

  function render(){
    grid.innerHTML = '';

    let disponiveis = characters.filter(p => !selecionados.includes(p));

    // 1) aplica filtro por botão (exceto 'All')
    if (currentFilter !== 'All') {
      disponiveis = disponiveis.filter(p => p.funcao === currentFilter);
    }

    // 2) aplica regra do slot (para starters). Em 'All', isso converte "todos" em "todos permitidos"
    if (!isBench) {
      disponiveis = disponiveis.filter(p => isAllowedForStarterSlot(slotRole, p.funcao));
    } else {
      // bench mantém os próprios limites, se você quiser já pré-filtrar, pode aplicar aqui
      disponiveis = disponiveis.filter(p => respeitaLimiteBench(p, slot));
    }

    if (disponiveis.length === 0){
      grid.innerHTML = `<div style="color:#ccc; padding:8px;">
        No available ${currentFilter === 'All' ? '' : currentFilter}${isBench ? ' for bench' : ''}.
      </div>`;
      return;
    }

    disponiveis.forEach(p => {
      const img = document.createElement('img');
      img.src = p.img;
      img.alt = p.nome;
      img.title = p.nome;
      img.addEventListener('click', (e) => {
        e.stopPropagation();
        const keepRole = isBench ? 'bench' : slotRole; // preserva o label do slot
        setCharacter(slot, p, keepRole);
        scrollMenu.style.display = 'none';
      });
      grid.appendChild(img);
    });
  }

  render();
}

function respeitaLimiteBench(p, slot) {
    const Bench = Array.from(document.querySelectorAll(".bench-slot"))
        .map(s => s.dataset.nome && characters.find(x => x.nome === s.dataset.nome))
        .filter(Boolean);

    if (slot.dataset.nome === p.nome) return true;

    const contagem = Bench.reduce((acc, cur) => {
        acc[cur.funcao] = (acc[cur.funcao] || 0) + 1;
        return acc;
    }, {});

    if (p.funcao === "MB" && contagem["MB"] >= 6) return false;
    if (p.funcao === "WS" && contagem["WS"] >= 6) return false;
    if (["L",].includes(p.funcao) && contagem[p.funcao] >= 1) return false;

    return true;
}
    function getFirstEmptyBenchSlot() {
  // Procura um slot vazio do banco; se não houver, cria um novo
  const slots = Array.from(document.querySelectorAll(".bench-slot"));
  const empty = slots.find(s => !s.dataset.nome);
  if (empty) return empty;
  if (typeof addBenchSlot === "function") addBenchSlot(); // cria e já liga eventos
  const all = Array.from(document.querySelectorAll(".bench-slot"));
  return all[all.length - 1] || null;
}

function showBenchMenuByRole(role) {
  const slot = getFirstEmptyBenchSlot();
  if (!slot) return;

  const scrollMenu = document.getElementById("scrollMenu");
  scrollMenu.innerHTML = '';

  // Filtra por posição + respeita regras do banco
  const disponiveis = characters.filter(p =>
    p.funcao === role &&
    !selecionados.includes(p) &&
    respeitaLimiteBench(p, slot)   // mesma regra usada quando role === "bench"
  );

  if (disponiveis.length === 0) {
    scrollMenu.innerHTML = `<div style="color:#ccc; padding:8px;">No available ${role} for bench.</div>`;
  } else {
    disponiveis.forEach(p => {
      const img = document.createElement('img');
      img.src = p.img;
      img.alt = p.nome;
      img.title = p.nome;
      img.addEventListener('click', (e) => {
        e.stopPropagation();
        setCharacter(slot, p, 'bench');   // adiciona direto ao banco
        scrollMenu.style.display = 'none';
      });
      scrollMenu.appendChild(img);
    });
  }

  scrollMenu.style.display = 'flex';
}
document.querySelectorAll(".bench-quick-btn").forEach(btn => {
  btn.addEventListener("click", (e) => {
    e.stopPropagation();
    showBenchMenuByRole(btn.dataset.role);
  });
});

// índices dos 6 slots que formam o "anel" (L fica fora, é fixo no índice 3)
const RING_IDX = [0, 1, 2, 6, 5, 4]; // [S, MB, WS, OP, MB, WS] na orientação base

// Rotaciona o anel 'steps' vezes no sentido horário (move conteúdo e data-role)
function rotateRingClockwise(steps){
  const hexes = [...document.querySelectorAll('.hex')];
  const ring = RING_IDX.map(i => hexes[i]);
  const k = ((steps % 6) + 6) % 6;
  if (k === 0) return;
const ids = ring.map(h => getSlotId(h));
  const eq = ids.map(id => equipState.get(id) || null);
  const eqRot = eq.slice(-k).concat(eq.slice(0, -k));
  ids.forEach((id, idx) => {
    if (eqRot[idx]) equipState.set(id, eqRot[idx]); else equipState.delete(id);
  });
  // 1) Captura estado completo (inclui charName!)
  const state = ring.map(h => ({
    html: h.innerHTML,
    nome: h.dataset.nome || null,
    charName: h.dataset.charName || null,
    role: h.dataset.role || h.getAttribute('data-role') || ''
  }));

  // 2) Roda
  const rotated = state.slice(-k).concat(state.slice(0, -k));

  // 3) Aplica e reanexa handlers/badges
  ring.forEach((h, i) => {
    const st = rotated[i];
    h.innerHTML = st.html;                  // isto remove listeners antigos
    if (st.nome) h.dataset.nome = st.nome; else delete h.dataset.nome;
    h.dataset.role = st.role;
    if (st.charName) h.dataset.charName = st.charName; else delete h.dataset.charName; // **novo**

    // atualiza o label do slot
    const info = h.parentElement.querySelector('.player-info');
    if (info) {
      if (st.nome) {
        const p = (typeof characters !== "undefined") && characters.find(x => x.nome === st.nome);
        info.textContent = p ? `${st.nome} - ${p.funcao}` : st.nome;
      } else {
        info.textContent = st.role;
      }
    }
    
    // **importante**: recriar o botão ⚙️ com listener e a badge
    removeItemGear(h);
    ensureItemGear(h);
    updateItemBadge(h);
    emitTeamChanged();
  });
}

// Ajusta a orientação do grid para coincidir com o time salvo
function orientGridToSavedTeam(team) {
  // pega a função (S/MB/WS/OP/L) em cada índice salvo
  const funcaoEm = (idx) => {
    const nome = team.main[idx];
    if (!nome) return null;
    const p = characters.find(x => x.nome === nome);
    return p ? p.funcao : null;
  };

  // Tentamos ancorar por S; se não existir, ancoramos por OP
  const idxS = RING_IDX.find(i => funcaoEm(i) === 'S');
  if (idxS !== undefined) {
    const posNoAnel = RING_IDX.indexOf(idxS); // onde o S está
    // na base, S está em RING_IDX[0] -> steps = pos atual
    rotateRingClockwise(posNoAnel);
    return;
  }
  const idxOP = RING_IDX.find(i => funcaoEm(i) === 'OP');
  if (idxOP !== undefined) {
    const posNoAnel = RING_IDX.indexOf(idxOP);
    // na base, OP está em RING_IDX[3] -> passos = pos atual - 3
    rotateRingClockwise((posNoAnel - 3 + 6) % 6);
  }
}

    
function setCharacter(slot, personagem, role) {
    // se já tinha alguém nesse slot, remove dos selecionados
    if (slot.dataset.nome) {
        selecionados = selecionados.filter(p => p.nome !== slot.dataset.nome);
    }

    // monta imagem
   slot.innerHTML = `<img src="${personagem.img}" alt="${personagem.nome}">`;
slot.dataset.nome = personagem.nome;
slot.dataset.role = role;

    afterAssignCharacter(slot, personagem.nome);

    // atualiza texto de info (procura .player-info no mesmo player-slot)
    const infoDiv = slot.parentElement.querySelector('.player-info');
    if (infoDiv) infoDiv.textContent = `${personagem.nome} - ${personagem.funcao}`;

    selecionados.push(personagem);
    updateSynergies();
}

function removeCharacter(slot) {
  if (slot.dataset.nome) {
    selecionados = selecionados.filter(p => p.nome !== slot.dataset.nome);

    // CHAME O HOOK ANTES de limpar o slot
    if (typeof window.afterRemoveCharacter === "function") {
      window.afterRemoveCharacter(slot);
    }

    slot.innerHTML = "";
    delete slot.dataset.nome;

    const infoDiv = slot.parentElement.querySelector('.player-info');
    if (slot.classList.contains("bench-slot")) {
      infoDiv.textContent = "Bench";
    } else {
      infoDiv.textContent = slot.dataset.role
        || slot.getAttribute("data-role")
        || slot.parentElement.querySelector('.hex')?.dataset.role || "";
    }

    updateSynergies();
    if (typeof afterRemoveCharacter === "function") afterRemoveCharacter(slot);
  }
}

function updateSynergies() {
    const synergyListEl = document.getElementById("synergy-list");
    synergyListEl.innerHTML = "";

    // === CONFIG: which bonds need 3 to activate ===
    // Put the EXACT vinculo names here (case-sensitive).
    const bondsRequire3 = new Set([
      "Swimming",  
     "Twin Heads", 
    ]);

    const DEFAULT_BOND_MIN = 2; // all bonds default to 2 unless listed above
    const SCHOOL_MIN = 4;       // school synergy rule stays the same

    const SchoolsCount = {};
    const vinculosCount = {};

    // --- Count Schools (starters only) ---
    document.querySelectorAll(".hex").forEach(slot => {
        if (slot.dataset.nome) {
            const p = characters.find(x => x.nome === slot.dataset.nome);
            if (!p) return;
            SchoolsCount[p.School] = (SchoolsCount[p.School] || 0) + 1;
        }
    });

    // --- Count Bonds (starters + bench) ---
    document.querySelectorAll(".hex, .bench-slot").forEach(slot => {
        if (slot.dataset.nome) {
            const p = characters.find(x => x.nome === slot.dataset.nome);
            if (!p) return;

            if (Array.isArray(p.vinculo)) {
                p.vinculo.forEach(v => {
                    vinculosCount[v] = (vinculosCount[v] || 0) + 1;
                });
            } else if (p.vinculo) {
                vinculosCount[p.vinculo] = (vinculosCount[p.vinculo] || 0) + 1;
            }
        }
    });

    let algumaSinergia = false;

    // --- School synergies (>= 4) ---
    for (const school in SchoolsCount) {
        if (SchoolsCount[school] >= SCHOOL_MIN) {
            synergyListEl.innerHTML += `
                <li>
                    <button class="bond-btn school-btn" data-school="${school}">
                        School: ${school}
                    </button>
                </li>
            `;
            algumaSinergia = true;
        }
    }

    // --- Bond synergies (>= per-bond threshold) ---
    for (const vinculo in vinculosCount) {
        const required = bondsRequire3.has(vinculo) ? 3 : DEFAULT_BOND_MIN;
        if (vinculosCount[vinculo] >= required) {
            synergyListEl.innerHTML += `
                <li>
                    <button class="bond-btn synergy-btn" data-bond="${vinculo}">
                        ${vinculo}
                    </button>
                </li>
            `;
            algumaSinergia = true;
        }
    }

    // === Click: School ===
    document.querySelectorAll(".school-btn").forEach(btn => {
        btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const schoolName = btn.dataset.school;

            const relacionados = characters.filter(pers => pers.School === schoolName);

            sidebarContent.innerHTML = `
                <h3>School: ${schoolName}</h3>
                <p>${descricoesSinergia[schoolName] || "Sem descrição disponível"}</p>
                <div class="char-list">
                    ${relacionados.map(r => `
                        <div class="char-card" data-nome="${r.nome}">
                            <img src="${r.img}" alt="${r.nome}">
                            <p>${r.nome}</p>
                        </div>
                    `).join('')}
                </div>
                <button id="backToSynergies" class="bond-btn">← Voltar</button>
            `;

            sidebar.classList.add("open");
            menuBtn.style.display = "none";

            document.getElementById("backToSynergies").addEventListener("click", (e) => {
                e.stopPropagation();
                updateSynergies();
                sidebar.classList.add("open");
                menuBtn.style.display = "none";
            });

            sidebarContent.querySelectorAll(".char-card").forEach(card => {
                card.addEventListener("click", (e) => {
                    e.stopPropagation();
                    const nome = card.dataset.nome;
                    const personagem = characters.find(x => x.nome === nome);
                    showCharacterDetails(personagem);
                    sidebar.classList.add("open");
                    menuBtn.style.display = "none";
                });
            });
        });
    });

    // === Click: Bond ===
    document.querySelectorAll(".synergy-btn").forEach(btn => {
        btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const bondName = btn.dataset.bond;

            const relacionados = characters.filter(pers => {
                if (Array.isArray(pers.vinculo)) return pers.vinculo.includes(bondName);
                return pers.vinculo === bondName;
            });

            sidebarContent.innerHTML = `
                <h3>Vínculo: ${bondName}</h3>
                <p>${descricoesSinergia[bondName] || "Sem descrição disponível"}</p>
                <div class="char-list">
                    ${relacionados.map(r => `
                        <div class="char-card" data-nome="${r.nome}">
                            <img src="${r.img}" alt="${r.nome}">
                            <p>${r.nome}</p>
                        </div>
                    `).join('')}
                </div>
                <button id="backToSynergies" class="bond-btn">← Voltar</button>
            `;

            sidebar.classList.add("open");
            menuBtn.style.display = "none";

            document.getElementById("backToSynergies").addEventListener("click", (e) => {
                e.stopPropagation();
                updateSynergies();
                sidebar.classList.add("open");
                menuBtn.style.display = "none";
            });

            sidebarContent.querySelectorAll(".char-card").forEach(card => {
                card.addEventListener("click", (e) => {
                    e.stopPropagation();
                    const nome = card.dataset.nome;
                    const personagem = characters.find(x => x.nome === nome);
                    showCharacterDetails(personagem);
                    sidebar.classList.add("open");
                    menuBtn.style.display = "none";
                });
            });
        });
    });

    if (!algumaSinergia) {
        synergyListEl.innerHTML = "<li>Only Deployment Synergies are displayed.Synergies will only work when players are in court inside the game.</li>";
    }
    // --- Tipo do time (apenas titulares) ---
(function renderTeamType(){
  function symbolToType(sym){
    const s = String(sym||"").toLowerCase();
    if (s.includes("quicksymbol"))   return "quick";
    if (s.includes("powersymbol"))   return "power";
    if (s.includes("receivesymbol")) return "receive";
    if (s.includes("blocksymbol"))   return "block";
    return null;
  }

  const TYPE_DEFAULT_MIN = 4;
  const typeCounts = {};

  // conta tipos só dos titulares (.hex)
  document.querySelectorAll(".hex").forEach(slot => {
    const nome = slot.dataset?.nome;
    if (!nome) return;
    const p = characters.find(x => x.nome === nome);
    if (!p) return;
    const syms = Array.isArray(p.symbols) ? p.symbols : [];
    const types = new Set(syms.map(symbolToType).filter(Boolean));
    types.forEach(t => { typeCounts[t] = (typeCounts[t] || 0) + 1; });
  });

  // vencedores entre os ativados
  let top = []; let topCount = 0;
  for (const [t, c] of Object.entries(typeCounts)) {
    const min = (t === "receive") ? 5 : TYPE_DEFAULT_MIN;
    if (c >= min) {
      if (c > topCount) { top = [t]; topCount = c; }
      else if (c === topCount) top.push(t);
    }
  }

  // garante cabeçalho flex ao redor do título "Synergies"
  const box = synergyListEl?.parentElement || document; // container da lista
  let title = box.querySelector('h2');
  if (!title) return;

  let header = title.closest('.synergy-header');
  if (!header){
    header = document.createElement('div');
    header.className = 'synergy-header';
    title.replaceWith(header);
    header.appendChild(title);
  }

  // cria/atualiza a badge ao lado do título
  let badge = header.querySelector('.team-type-badge');
  if (!badge){
    badge = document.createElement('span');
    badge.className = 'team-type-badge';
    header.appendChild(badge);
  }

  if (top.length){
    const label = {
      quick:"Quick Attack", power:"Power Attack", receive:"Receive", block:"Block"
    };
    const names = top.map(t => label[t] || t).join(" ou ");
    badge.textContent = `Team type: ${names} (${topCount})`;
  } else {
    badge.textContent = ''; // nada ativado, não mostra texto
  }
})();
}
// ====== Eventos iniciais (grid principal com detecção de duplo clique) ======
document.querySelectorAll(".hex").forEach(slot => {
  // Timer por slot para distinguir clique simples x duplo clique
  slot.__clickTimer = null;

  slot.addEventListener("click", (e) => {
    e.stopPropagation();

    // Se já existe um timer, este clique é o 2º -> trata como duplo clique
    if (slot.__clickTimer) {
      clearTimeout(slot.__clickTimer);
      slot.__clickTimer = null;

      // ⏩ Duplo clique: abrir detalhes (se houver personagem nesse slot)
      const nome = slot.dataset.nome;
      if (!nome) return; // slot vazio
      const p = (typeof characters !== "undefined") && characters.find(x => x.nome === nome);
      if (!p) return;

      // fecha o menu, se estiver aberto
      const sm = document.getElementById("scrollMenu");
      if (sm) sm.style.display = "none";

      // mostra detalhes no painel lateral
      if (typeof showCharacterDetails === "function") {
        showCharacterDetails(p);
      }
      // garante que o painel lateral fique aberto (se você usa esses ids)
      const sidebar = document.getElementById("sidebar");
      const menuBtn = document.getElementById("menuBtn");
      if (sidebar) sidebar.classList.add("open");
      if (menuBtn) menuBtn.style.display = "none";

      return;
    }

    // 1º clique: arma o timer; se não houver 2º clique, abre o menu
    slot.__clickTimer = setTimeout(() => {
      slot.__clickTimer = null;
      // ✅ Clique simples (sem 2º clique): abre o menu de seleção
      if (typeof showMenu === "function") {
        showMenu(slot.dataset.role, slot);
      }
    }, 250); // janela para detectar duplo clique
  });

  // Botão direito: remover personagem (igual antes)
  slot.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    if (typeof removeCharacter === "function") removeCharacter(slot);
  });
});

document.querySelectorAll(".bench-slot").forEach(slot => attachBenchEvents(slot));

/* ====== SIDEBAR NAV ====== */
const sidebarContent = document.getElementById("sidebar-content");
document.querySelectorAll(".menu-link").forEach(btn => {
  btn.addEventListener("click", (e) => {
    e.stopPropagation();
    const section = btn.dataset.section;
    if (section === "characters") {
      showCharacterList();
    } else if (section === "schools") {
      showSchoolsList();             
    } else if (section === "save") {
      showSavedTeams();
    } else if (section === "help") {
    sidebarContent.innerHTML = `
        <h3>Info</h3>
        <div style="display:flex; flex-direction:column; gap:10px;">
            <button id="faqBtn" class="bond-btn">📄 FAQ</button>
            <button id="creditsBtn" class="bond-btn">👥 Credits</button>
            <button id="patchBtn" class="bond-btn">🔄 Patch</button>
        </div>
    `;

    // Botão FAQ
    document.getElementById("faqBtn").addEventListener("click", (e) => {
        e.stopPropagation();
        sidebarContent.innerHTML = `
            <h3>FAQ</h3>
            <p>Player bonds work if one is benched?</p>
            <p>It doesn't, only gonna be applied in game when the bond players are in court</p>
            <p>"X" bond doesn't show, why?</p>
            <p>This version only shows DEPLOYMENT bonds, since "normal" bonds requirements are just to have the characters on the account, meaning they don't have to be in court to activate</p>
            <p>How can i help with team builderr?</p>
            <p>Contact goN6 on discord, to send ideas, fixes to erros, new information, etc.</p>
            <button id="backToHelp" class="bond-btn">← Voltar</button>
        `;
        document.getElementById("backToHelp").addEventListener("click", (e) => {
            e.stopPropagation();
            document.querySelector('.menu-link[data-section="help"]').click();
            sidebar.classList.add("open");
            menuBtn.style.display = "none";
        });
    });

    // Botão Credits
    document.getElementById("patchBtn").addEventListener("click", (e) => {
        e.stopPropagation();
        sidebarContent.innerHTML = `
            <h3>Patch notes</h3>
            <p>Patch 1.2.1 Added:</p>
            <p>NO position restriction filter for new JP mechanic</p>
            <p>Shows new "Team Type" mechanic</p>
            <p>Multi teams function</p>
            <p>Patch 1.2 Added:</p>
            <p>Drag/drop players to bench and to starting line up</p>
            <p>Filter players by type (quick/power/etc)</p>
            <p>Team recommendations based on most synergies</p>
            <p>Memory and potential sets on character</p>
            <p>School page with all characters from each school and its buff</p>
            <p>Fixed:</p>
            <p>Some synergies that required 3 players were not being displayed correctly</p>
            <p>Some bench rules were not working correctly, EX: couldnt add more than 2 MB's on bench</p>
            <p>Added:</p>
            <p>Double click opens character details</p>
            <p>Bench filter per positions</p>
            <p>Side menu</p>
            <p>Save and Load teams</p>
            <p>Clear all button</p>
            <p>Filter characters on side menu</p>
            <p>Character Skills description</p>
            <p>Character Stats</p>
            <p>Expected release date</p>
            <button id="backToHelp" class="bond-btn">← Back</button>
        `;
        document.getElementById("backToHelp").addEventListener("click", (e) => {
            e.stopPropagation();
            document.querySelector('.menu-link[data-section="help"]').click();
            sidebar.classList.add("open");
            menuBtn.style.display = "none";
        });
    });
               // Botão FAQ
    document.getElementById("creditsBtn").addEventListener("click", (e) => {
        e.stopPropagation();
        sidebarContent.innerHTML = `
            <h3>Credits</h3>
            <p>Devoy Aces: goN6 , Kari, Marin, Kaito</p>
            <p>Tradução para inglês by KRILL group https://discord.gg/EEBqSKvAsp</p>
            <button id="backToHelp" class="bond-btn">← Voltar</button>
            
        `;
        document.getElementById("backToHelp").addEventListener("click", (e) => {
            e.stopPropagation();
            document.querySelector('.menu-link[data-section="help"]').click();
            sidebar.classList.add("open");
            menuBtn.style.display = "none";
        });
    });
}
    });
});

// === Meme Version (acrescenta personagens extras à lista) ===
window.MEME_VERSION_ON = window.MEME_VERSION_ON || false;

/**
 * Preencha aqui os seus novos personagens.
 * Mantém o mesmo shape de "characters": { nome, funcao, School, img, symbols, Stats, data }
 */
window.MEME_CHARACTERS = window.MEME_CHARACTERS || [
  // EXEMPLO:
   {
   nome: "Kagenata Max Power SP",
   funcao: "WS",
   School: "Karasuno",
   img: "img/MEMEkagenata.png",
   symbols: ["img/quicksymbol.png","img/powersymbol.png"],
   Stats: { Serve: 100, Spike: 999, Set: 0, Receive: 123, Block: 45, Save: 67 },
   data: "12/31/25"
  },
    { 
     nome: "Ennoshita SP", 
     funcao: "WS", img: "img/MEMEennoshitaSP.png", 
     School: "Karasuno", vinculo: ["Graduation Ceremony"], 
     Stats:{Serve:1,Spike:1,Set:1,Receive:1,Block:1,Save:1}, 
     habilidades:[
  {nome:"Anchor Receive", descricao:"Performs a receive that nullifies 1 incoming spike or serve (guaranteed once per rally). He will also grant himself a 20% buff on his [Receive] + [Save], lasting 2 rallies."},
  {nome:"Adaptive Spike", descricao:"Performs a spike that scales with [Block] stats of opponent's front row by 20%. He will also have 40% chance to reduce enemy block by 10% for 2 rallies. This percentage will increase to 30% if he scores"},
  {nome:"Unshakable Resolve", descricao:"Whenever an ally receive is not PERFECT, he will gain a stack of [Resolving], each stack grants him 10% [Receive] and [Save]. Maximum 4 stacks."},
  {nome:"Captain’s Burden", descricao:"Can activate anytime. Removes all allies debuff and grants all allies 20% boost in Attack and Defense Technique. If any ally is below 50% stamina, granting them 30% more. This effect lasts 3 rallies."}
], 
    symbols: [ "img/receivesymbol.png","img/powersymbol.png"] 
    },
    {
   nome: "Atsumu SP",
   funcao: "S",
   School: "Inarizaki", vinculo: ["Freaky Holiday"], 
   img: "img/MEMEatsumusantaSP.png",
   symbols: ["img/quicksymbol.png","img/settersymbol.png"],
   Stats: { Serve: 9999, Spike: 0, Set: 9999, Receive: 0, Block: 0, Save: 0 },
   data: "12/31/25"
  }
];

// Guarda a base original para podermos voltar quando o toggle estiver OFF
window.__BASE_CHARACTERS = window.__BASE_CHARACTERS || characters.slice();

/** Recalcula o array global "characters" de acordo com o toggle */
function syncCharactersWithToggle(){
  const base = window.__BASE_CHARACTERS;
  const out  = base.slice(); // cópia da base

  if (window.MEME_VERSION_ON && Array.isArray(window.MEME_CHARACTERS)) {
    const baseNames = new Set(base.map(p => p?.nome));
    for (const p of window.MEME_CHARACTERS) {
      if (p && !baseNames.has(p.nome)) out.push(p); // só acrescenta se for NOVO
    }
  }

  // IMPORTANTE: muta o array "characters" sem trocar a referência
  characters.splice(0, characters.length, ...out);
}

// Garante que o site já comece consistente com o estado do toggle
syncCharactersWithToggle();
updateWinDiamondsBtn(); 
// ---- helpers do menu do grid (scrollMenu) ----
function isGridMenuOpen(){
  const el = document.getElementById('scrollMenu');
  return !!(el && getComputedStyle(el).display !== 'none' && el.childElementCount > 0);
}

function refreshGridMenu(){ // atualiza sem fechar
  const ctx = window.__lastMenuCtx;
  if (!ctx) return;
  // salva o scroll do menu, se existir
  const el = document.getElementById('scrollMenu');
  const keepScroll = el ? el.scrollTop : 0;

  // se o slot ainda está no DOM, reabre
  if (document.body.contains(ctx.slot)) {
    showMenu(ctx.role, ctx.slot);
    const el2 = document.getElementById('scrollMenu');
    if (el2) el2.scrollTop = keepScroll; // restaura posição
  }
}

function closeGridMenu(){ // fecha o menu do grid
  const el = document.getElementById('scrollMenu');
  if (!el) return;
  el.innerHTML = '';
  el.style.display = 'none';
}
// ===== WIN 999 DIAMONDS =====
const WIN_URL = "https://docs.google.com/forms/d/e/1FAIpQLSeTFIekmM_fEn_Ch1lv26WLtuCPto_opjiTx8pme180oZk6EQ/viewform";

/** tenta achar o container do grid principal para ancorar a posição do botão */
function __findGridEl(){
  // coloque primeiro os ids/candidatos que existem no seu HTML
  const candidates = [
    '#mainGrid', '#gridContainer', '#court', '#grid', '#pageBuilder',
    '.grid', '.court'
  ];
  for (const sel of candidates){
    const el = document.querySelector(sel);
    if (el) return el;
  }
  return null;
}

/** posiciona o botão à direita do grid (fallback: canto direito da tela) */
function __positionWinBtn(btn){
  const grid = __findGridEl();
  if (!btn) return;

  if (grid){
    const r = grid.getBoundingClientRect(); // relativo à viewport
    const left = Math.min(window.innerWidth - 300, r.right + 16);
    const top  = Math.max(16, r.top + 60);
    btn.style.left = left + 'px';
    btn.style.top  = top  + 'px';
    btn.style.right = 'auto';
    btn.style.bottom = 'auto';
  } else {
    // fallback
    btn.style.right = '24px';
    btn.style.top   = '120px';
    btn.style.left = 'auto';
    btn.style.bottom = 'auto';
  }
}

/** cria o botão se não existir e mostra */
function showWinDiamondsBtn(){
  if (document.getElementById('winDiamondsBtn')) {
    const btn = document.getElementById('winDiamondsBtn');
    btn.style.display = 'inline-flex';
    __positionWinBtn(btn);
    return;
  }
  const btn = document.createElement('button');
  btn.id = 'winDiamondsBtn';
  btn.className = 'win-diamonds-btn';
  btn.type = 'button';
  btn.textContent = 'WIN 999 DIAMONDS 💎 RULES IN GOOGLE FORM';
  btn.addEventListener('click', () => window.open(WIN_URL, '_blank', 'noopener'));
  document.body.appendChild(btn);
  __positionWinBtn(btn);

  // reposiciona ao redimensionar/rolar
  const reposition = () => __positionWinBtn(btn);
  window.addEventListener('resize', reposition);
  window.addEventListener('scroll', reposition);
}

/** esconde (não remove) */
function hideWinDiamondsBtn(){
  const btn = document.getElementById('winDiamondsBtn');
  if (btn) btn.style.display = 'none';
}

/** decide mostrar/ocultar conforme o toggle */
function updateWinDiamondsBtn(){
  if (window.MEME_VERSION_ON) showWinDiamondsBtn();
  else hideWinDiamondsBtn();
}
// ============================================


/* ====== LISTA / FILTROS DE characters (mantida com stopPropagation nos clicks) ====== */
function showCharacterList() {
    const POOL = characters;

    const funcoes   = [...new Set(POOL.map(p => p.funcao))];
    const escolas   = [...new Set(POOL.map(p => p.School))];
    const StatsKeys = [...new Set(POOL.flatMap(p => Object.keys(p.Stats || {})))];

    function symbolToType(sym){
  const s = String(sym||"").toLowerCase();
  if (s.includes("quicksymbol"))   return "quick";
  if (s.includes("powersymbol"))   return "power";
  if (s.includes("servesymbol"))   return "serve";
  if (s.includes("settersymbol"))  return "setter";
  if (s.includes("receivesymbol")) return "receive";
  if (s.includes("blocksymbol"))   return "block";
  if (s.includes("savesymbol"))    return "save";
  return null;
}

// tipos únicos lendo characters[*].symbols
const allTypes = [...new Set(
  POOL.flatMap(p => (Array.isArray(p.symbols) ? p.symbols : [])
    .map(symbolToType).filter(Boolean))
)].sort();

let html = `
  <h3>Characters</h3>
  <div class="filtros">
    <div>
      <label>Role:</label>
      <select id="filtroFuncao">
        <option value="">All</option>
        ${funcoes.map(f => `<option value="${f}">${f}</option>`).join('')}
      </select>
    </div>
    <div>
      <label>School:</label>
      <select id="filtroEscola">
        <option value="">All</option>
        ${escolas.map(e => `<option value="${e}">${e}</option>`).join('')}
      </select>
    </div>
    <div>
      <label>Stats:</label>
      <select id="filtroStats">
        <option value="">All</option>
        ${StatsKeys.map(s => `<option value="${s}">${s}</option>`).join('')}
      </select>
    </div>
    <div>
      <label>Expected Release Date:</label>
      <select id="filtroDataOrdem" title="Ordenar pela data (ignora quem não tem data)">
        <option value="">Ignorar</option>
        <option value="asc">Ascendente (MM/DD/YY)</option>
        <option value="desc">Descendente (MM/DD/YY)</option>
      </select>
    </div>
    <div>
      <label>Type:</label>
      <div id="filtroType">
        ${allTypes.map(t => `
          <label style="display:inline-flex;align-items:center;gap:6px;margin:2px 8px 2px 0;">
            <input type="checkbox" name="typeFilter" value="${t}"> ${t.toUpperCase()}
          </label>
        `).join("")}
      </div>
    </div>

    <button id="limparFiltros">Limpar</button>
  </div>

  <div id="memeToggleRow" style="display:flex;align-items:center;gap:8px;margin:6px 0;">
    <input type="checkbox" id="memeToggle" ${window.MEME_VERSION_ON ? 'checked' : ''}>
    <div>Community Characters</div>
  </div>

  <div class="char-list" id="charList"></div>
`;


    sidebarContent.innerHTML = html;
    const memeTg = document.getElementById('memeToggle');
if (memeTg){
  memeTg.addEventListener('change', (e)=>{
    window.MEME_VERSION_ON = !!e.target.checked;
    syncCharactersWithToggle();   // <-- atualiza o array characters
    showCharacterList();          // <-- reconstrói a UI
    updateWinDiamondsBtn(); 
    // Mantém o toggle do topo sincronizado (se existir)
    const top = document.getElementById('memeToggleTop');
    if (top && top.checked !== window.MEME_VERSION_ON) top.checked = window.MEME_VERSION_ON;
  });
}


    const list = document.getElementById('charList');
if (list) list.classList.remove('is-hidden');
    enableCloseOutsideCharList();

    // Helpers de data (MM/DD/YY)
    function parseDateMMDDYY(s) {
        if (typeof s !== "string") return null;
        const m = s.match(/^(\d{2})\/(\d{2})\/(\d{2})$/);
        if (!m) return null;
        const mm = parseInt(m[1], 10), dd = parseInt(m[2], 10), yy = 2000 + parseInt(m[3], 10);
        const d = new Date(yy, mm - 1, dd);
        return Number.isNaN(d.getTime()) ? null : d;
    }
    function hasValidDate(p) {
        return !!parseDateMMDDYY(p?.data);
    }

function getStatsSafe(p, key) {
  const v = p?.Stats?.[key];
  return (typeof v === "number") ? v : "-";
}


   function renderLista() {
  const listaEl   = document.getElementById("charList");
  if (listaEl) listaEl.classList.remove('is-hidden');

  const funcaoSel = (document.getElementById("filtroFuncao").value || "").trim();
  const escolaSel = (document.getElementById("filtroEscola").value || "").trim();
  let   StatsSel = (document.getElementById("filtroStats").value || "").trim();
  const dataOrdem = (document.getElementById("filtroDataOrdem")?.value || "").trim();
  const typeSel = Array.from(
  document.querySelectorAll('#filtroType input[name="typeFilter"]:checked')
).map(el => el.value);
  const typeBox = document.getElementById('filtroType');
if (typeBox) typeBox.addEventListener('change', renderLista);

  function getCharTypes(p){
  const arr = Array.isArray(p?.symbols) ? p.symbols : [];
  const types = new Set(arr.map(symbolToType).filter(Boolean));
  return [...types];
}

  if (StatsSel.toLowerCase() === "todos") StatsSel = "";

  // 1) filtro base
  const BASE = POOL; // usa a pool ativa
let filtrados = BASE.filter(p =>
  (funcaoSel === "" || p.funcao === funcaoSel) &&
  (escolaSel === "" || p.School === escolaSel) &&
  (typeSel.length === 0 || typeSel.every(t => getCharTypes(p).includes(t)))
);


  // 2) ordenar por data quando escolhido (e ignorar sem data)
  if (dataOrdem === "asc" || dataOrdem === "desc") {
    filtrados = filtrados
      .filter(hasValidDate)
      .sort((a, b) => {
        const da = parseDateMMDDYY(a.data);
        const db = parseDateMMDDYY(b.data);
        return dataOrdem === "asc" ? (da - db) : (db - da);
      });
  } else if (StatsSel) {
    // 3) ordenar por Stats quando data está em "Ignorar"
    filtrados.sort((a, b) => {
      const bv = (b.Stats && typeof b.Stats[StatsSel] === "number") ? b.Stats[StatsSel] : -Infinity;
      const av = (a.Stats && typeof a.Stats[StatsSel] === "number") ? a.Stats[StatsSel] : -Infinity;
      return bv - av;
    });
  }

  // 4) render (agora em <li>)
  const html = filtrados.map((p, i) => {
    const metaLine =
      (dataOrdem === "asc" || dataOrdem === "desc")
        ? (hasValidDate(p) ? `<div class="card-sub">Expected Release Date: ${p.data}</div>` : "")
        : (StatsSel ? `<div class="card-sub">${StatsSel}: ${getStatsSafe(p, StatsSel)}</div>` : "");

    return `
      <li class="person-card" data-idx="${i}">
        <img src="${p.img}" alt="${p.nome}">
        <div class="card-name">${p.nome}</div>
        ${metaLine}
      </li>
    `;
  }).join("");

  listaEl.innerHTML = html;

  // 5) clique abre detalhes
  listaEl.querySelectorAll(".person-card").forEach(card => {
    card.addEventListener("click", (ev) => {
      ev.stopPropagation();  
      const idx = +card.getAttribute("data-idx");
      const person = filtrados[idx];
      if (person) showCharacterDetails(person);
    });
  });
}

    // listeners dos filtros
document.getElementById("filtroFuncao").addEventListener("change", renderLista);
document.getElementById("filtroEscola").addEventListener("change", renderLista);
document.getElementById("filtroStats").addEventListener("change", renderLista);
document.getElementById("filtroDataOrdem").addEventListener("change", renderLista);


// botão Limpar
document.getElementById("limparFiltros").addEventListener("click", () => {
  document.getElementById("filtroFuncao").value = "";
  document.getElementById("filtroEscola").value = "";
  document.getElementById("filtroStats").value = "";
  document.querySelectorAll('#filtroType input[name="typeFilter"]').forEach(cb => cb.checked = false);
  const selData = document.getElementById("filtroDataOrdem");
  if (selData) selData.value = "";
  renderLista();
});

// ⬇️ AQUI (fora do botão, depois dos listeners)
const listaEl = document.getElementById("charList");
if (listaEl && !listaEl.dataset.stopCloseBound) {
  listaEl.addEventListener("click", (ev) => ev.stopPropagation());
  listaEl.dataset.stopCloseBound = "1";
}

// primeira renderização
renderLista();
}

function showSchoolsList(){
  const sidebar = document.getElementById("sidebar");
  const menuBtn  = document.getElementById("menuBtn");

  const schools = [...new Set(characters.map(p => p.School))].sort((a,b)=>a.localeCompare(b));

  sidebarContent.innerHTML = `
    <h3>Schools</h3>
    <div style="display:flex; flex-direction:column; gap:8px;">
      ${schools.map(s => `
        <button class="bond-btn school-open" data-school="${s}">
           ${s}
        </button>
      `).join("")}
    </div>
  `;

  // abre e esconde o botão verde
  if (sidebar) sidebar.classList.add("open");
  if (menuBtn) menuBtn.style.display = "none";

  // clique de cada escola abre a página detalhada
  sidebarContent.querySelectorAll(".school-open").forEach(btn=>{
    btn.addEventListener("click", (e)=>{
      e.stopPropagation();
      showSchoolDetail(btn.dataset.school);
    });
  });
}

// Página de uma escola específica: descrição + personagens
function showSchoolDetail(schoolName){
  const sidebar = document.getElementById("sidebar");
  const menuBtn  = document.getElementById("menuBtn");

  const relacionados = characters.filter(p => p.School === schoolName);
  const desc = (typeof descricoesSinergia === "object" && descricoesSinergia[schoolName])
             ? descricoesSinergia[schoolName]
             : "No description available.";

  sidebarContent.innerHTML = `
    <h3>School: ${schoolName}</h3>
    <p>${desc}</p>
    <div class="char-list">
      ${relacionados.map(r => `
        <div class="char-card" data-nome="${r.nome}">
          <img src="${r.img}" alt="${r.nome}">
          <p>${r.nome}</p>
        </div>
      `).join("")}
    </div>
    <button id="backToSchools" class="bond-btn">← Voltar</button>
  `;

  if (sidebar) sidebar.classList.add("open");
  if (menuBtn) menuBtn.style.display = "none";

  // voltar para a lista de Schools
  document.getElementById("backToSchools").addEventListener("click", (e)=>{
    e.stopPropagation();
    showSchoolsList();
  });

  // clicar num personagem abre os detalhes dele (já existe showCharacterDetails)
  sidebarContent.querySelectorAll(".char-card").forEach(card=>{
    card.addEventListener("click", (e)=>{
      e.stopPropagation();
      const nome = card.dataset.nome;
      const p = characters.find(x => x.nome === nome);
      if (p && typeof showCharacterDetails === "function") {
        showCharacterDetails(p);
      }
    });
  });
}

function showCharacterDetails(p) {
  // Normalize fields so we can safely render
  const bonds   = Array.isArray(p?.vinculo) ? p.vinculo.filter(Boolean)
                : (p?.vinculo ? [p.vinculo] : []);
  const skills  = Array.isArray(p?.habilidades) ? p.habilidades : [];
  const symbols = Array.isArray(p?.symbols) ? p.symbols : [];
  const Stats  = Array.isArray(p?.Stats) ? p.Stats : [];
 // Stat Bonds que esse personagem participa
  const myStatBonds = Object.entries(window.STATS_BONDS || {})
    .filter(([bondName, map]) => Object.prototype.hasOwnProperty.call(map, p.nome));

  const pillsHtml = myStatBonds.length ? `
    <h4 style="margin-top:12px;">Stat Bonds</h4>
    <div>
      ${myStatBonds.map(([bn])=>`<button class="pill statbond-pill" data-bond="${bn}">${bn}</button>`).join('')}
    </div>
    <div id="statBondDesc" class="subdesc"></div>
  ` : '';

  sidebarContent.innerHTML = `
    <h3>${p.nome}</h3>
    <img src="${p.img}" alt="${p.nome}" style="width:100%;">

    ${symbols.length ? `
      <div class="person-symbols">
        ${symbols.map(sym => `<img src="${sym}" class="symbol-icon">`).join("")}
      </div>` : ""}

    ${p.data ? `<p><b>Expected Release Date:</b> ${p.data}</p>` : ""}
    <p><b>Position:</b> ${p.funcao || "-"}</p>
    <p><b>School:</b> ${p.School || "-"}</p>

    ${bonds.length ? `
      <p><b>Bonds:</b></p>
      <ul>
        ${bonds.map(v => `<li><button class="bond-btn bond-link" data-bond="${v}">${v}</button></li>`).join("")}
      </ul>` : `<p><b>Bonds:</b> <i>None</i></p>`}

    ${skills.length ? `
      <h4>Skills</h4>
      <ul>
        ${skills.map(h => `<li><button class="skill-btn" data-skill="${h.nome}">${h.nome}</button></li>`).join("")}
      </ul>` : ""}

    ${p.descricao ? `<p style="margin-top:8px;">${p.descricao}</p>` : ""}

    ${p.Stats ? `
      <ul>
        <li><b>Serve:</b> ${p.Stats.Serve}</li>
        <li><b>Spike:</b> ${p.Stats.Spike}</li>
        <li><b>Set:</b> ${p.Stats.Set}</li>
        <li><b>Receive:</b> ${p.Stats.Receive}</li>
        <li><b>Block:</b> ${p.Stats.Block}</li>
        <li><b>Save:</b> ${p.Stats.Save}</li>
      </ul>` : ""}

    ${pillsHtml}

    <button id="backToList" class="bond-btn">← Voltar</button>
  `;

  // Mantém aberto etc. (o resto do teu código permanece)
  sidebar.classList.add("open"); menuBtn.style.display = "none";

  // Back → lista
  document.getElementById("backToList").addEventListener("click", (e) => {
    e.stopPropagation(); showCharacterList();
  });

  // Abrir “Bond” normal (já existia)
  sidebarContent.querySelectorAll(".bond-link").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const bondName = btn.dataset.bond;
      const relacionados = characters.filter(pers =>
        Array.isArray(pers.vinculo) ? pers.vinculo.includes(bondName) : pers.vinculo === bondName
      );
      sidebarContent.innerHTML = `
        <h3>Bond: ${bondName}</h3>
        <p>${descricoesSinergia[bondName] || "Sem descrição disponível"}</p>
        <div class="char-list">
          ${relacionados.map(r => `
            <div class="char-card" data-nome="${r.nome}">
              <img src="${r.img}" alt="${r.nome}">
              <p>${r.nome}</p>
            </div>
          `).join("")}
        </div>
        <button id="backToChar" class="bond-btn">← Voltar</button>
      `;
      document.getElementById("backToChar").addEventListener("click", (e) => {
        e.stopPropagation(); showCharacterDetails(p);
      });
      sidebarContent.querySelectorAll(".char-card").forEach(card => {
        card.addEventListener("click", (e) => {
          e.stopPropagation();
          const nome = card.dataset.nome;
          const personagem = characters.find(x => x.nome === nome);
          if (personagem) showCharacterDetails(personagem);
        });
      });
    });
  });

  // Clique nas pills de Stat Bonds → descreve os participantes + buffs
  sidebarContent.querySelectorAll(".statbond-pill").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const bondName = btn.dataset.bond;
      const mapping = (window.STATS_BONDS||{})[bondName] || {};
      const html = `
        <b>${bondName}</b>
        <ul>
          ${Object.entries(mapping).map(([nm,buff])=>`
            <li><b>${nm}</b> — ${String(buff||'').trim() ? buff : '<em>sem buff</em>'}</li>
          `).join('')}
        </ul>`;
      const box = sidebarContent.querySelector('#statBondDesc');
      if (box) box.innerHTML = html;
    });
  });

  // Skills (mantido)
  sidebarContent.querySelectorAll(".skill-btn").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const skillName = btn.dataset.skill;
      const habilidade = skills.find(h => h.nome === skillName);
      if (!habilidade) return;
      sidebarContent.innerHTML = `
        <h3>Skill: ${habilidade.nome}</h3>
        <p>${habilidade.descricao || ""}</p>
        <button id="backToChar" class="bond-btn">← Voltar</button>
      `;
      document.getElementById("backToChar").addEventListener("click", (e) => {
        e.stopPropagation(); showCharacterDetails(p);
      });
    });
  });


  // Keep sidebar open
  sidebar.classList.add("open");
  menuBtn.style.display = "none";

  // Back to character list
  document.getElementById("backToList").addEventListener("click", (e) => {
    e.stopPropagation();
    showCharacterList();
  });

  // Open a Bond page
  sidebarContent.querySelectorAll(".bond-link").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const bondName = btn.dataset.bond;

      const relacionados = characters.filter(pers =>
        Array.isArray(pers.vinculo) ? pers.vinculo.includes(bondName)
                                    : pers.vinculo === bondName
      );

      sidebarContent.innerHTML = `
        <h3>Bond: ${bondName}</h3>
        <p>${descricoesSinergia[bondName] || "Sem descrição disponível"}</p>
        <div class="char-list">
          ${relacionados.map(r => `
            <div class="char-card" data-nome="${r.nome}">
              <img src="${r.img}" alt="${r.nome}">
              <p>${r.nome}</p>
            </div>
          `).join("")}
        </div>
        <button id="backToChar" class="bond-btn">← Voltar</button>
      `;

      sidebar.classList.add("open");
      menuBtn.style.display = "none";

      // Back to THIS character's details
      document.getElementById("backToChar").addEventListener("click", (e) => {
        e.stopPropagation();
        showCharacterDetails(p);
      });

      // Jump from bond list to another character
      sidebarContent.querySelectorAll(".char-card").forEach(card => {
        card.addEventListener("click", (e) => {
          e.stopPropagation();
          const nome = card.dataset.nome;
          const personagem = characters.find(x => x.nome === nome);
          if (personagem) showCharacterDetails(personagem);
        });
      });
    });
  });

  // Open a Skill page
  sidebarContent.querySelectorAll(".skill-btn").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const skillName = btn.dataset.skill;
      const habilidade = skills.find(h => h.nome === skillName);
      if (!habilidade) return;

      sidebarContent.innerHTML = `
        <h3>Skill: ${habilidade.nome}</h3>
        <p>${habilidade.descricao || ""}</p>
        <button id="backToChar" class="bond-btn">← Voltar</button>
      `;
      document.getElementById("backToChar").addEventListener("click", (e) => {
        e.stopPropagation();
        showCharacterDetails(p);
      });
    });
  });
}

/* ====== SALVAR / Load TIMES (localStorage) ====== */

// pega composição atual por NOME do personagem (não por src)
function getCurrentTeamByName() {
    // titulares: procuramos .hex dentro de .player-slot (apenas as hex)
    const mainHexes = Array.from(document.querySelectorAll(".hex"));
    const main = mainHexes.map(h => h.dataset.nome || null);

    // bench: cada .bench-slot
    const benches = Array.from(document.querySelectorAll(".bench-slot"));
    const benchNames = benches.map(b => b.dataset.nome || null);

    return { main, bench: benchNames };
}

const saveTeamBtn = document.getElementById("saveTeamBtn");
saveTeamBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    const teamName = prompt("Type team name:");
    if (!teamName) return;

    let teams = JSON.parse(localStorage.getItem("savedTeams") || "{}");

    if (teams[teamName]) {
        if (!confirm(`Team "${teamName}" is already saved. Do you want to replace?`)) {
            return;
        }
    }

    const savePayload = {
  ...getCurrentTeamByName(),   // { main: [...], bench: [...] }
  items: serializeTeamItems()  // <- memories / potentials por slot
};

teams[teamName] = savePayload;
localStorage.setItem("savedTeams", JSON.stringify(teams));
    alert(`Team "${teamName}" saved!`);

    showSavedTeams();
    sidebar.classList.add("open");
    menuBtn.style.display = "none";
});

    // wrapper: um passo no sentido horário + housarkeeping
  function rotateMainGridClockwise() {
  rotateRingClockwise(1);           // gira o anel (L fica parado)
  const sm = document.getElementById("scrollMenu");
  if (sm) sm.style.display = "none";
  if (typeof updateSynergies === "function") updateSynergies();
  }
    const rotateBtn = document.getElementById("rotateBtn");
  if (rotateBtn) {
  rotateBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      rotateMainGridClockwise();
    });
  }
/* mostra lista de times salvos no painel lateral */
function showSavedTeams() {
    const teams = JSON.parse(localStorage.getItem("savedTeams") || "{}");
    let html = "<h3>Saved teams</h3>";

    if (Object.keys(teams).length === 0) {
        html += "<p>Sem times salvos</p>";
    } else {
        html += `<div class="saved-list">`;
        for (const [name, team] of Object.entries(teams)) {
            html += `
                <div style="margin-bottom:8px; display:flex; align-items:center; justify-content:space-between;">
                    <div style="text-align:left;">
                        <b>${name}</b>
                    </div>
                    <div>
                        <button class="load-btn" data-name="${name}">Load</button>
                        <button class="del-btn" data-name="${name}">Delete</button>
                    </div>
                </div>
            `;
        }
        html += `</div>`;
    }

    sidebarContent.innerHTML = html;


    document.querySelectorAll(".load-btn").forEach(btn => {
        btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const name = btn.dataset.name;
        loadTeam(name);

        // Atualiza sinergias e mantém menu aberto na lista
        updateSynergies();
        sidebar.classList.add("open");
        menuBtn.style.display = "none";
        });
    });

    document.querySelectorAll(".del-btn").forEach(btn => {
        btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const name = btn.dataset.name;
            if (confirm(`Delete team "${name}"?`)) {
                deleteTeam(name);
                showSavedTeams();
            }
        });
    });
}

function deleteTeam(name) {
    let teams = JSON.parse(localStorage.getItem("savedTeams") || "{}");
    delete teams[name];
    localStorage.setItem("savedTeams", JSON.stringify(teams));
}

/* Carrega time — monta usando setCharacter... */
function loadTeam(name) {
  equipState.clear();  // evita lixo de items grudado em slots antigos
  const teams = JSON.parse(localStorage.getItem("savedTeams") || "{}");
  const team = teams[name];
  if (!team) return;

  selecionados = [];

  // limpa grid e bench
  document.querySelectorAll(".hex, .bench-slot").forEach(slot => {
    slot.innerHTML = "";
    delete slot.dataset.nome;
    const infoDiv = slot.parentElement.querySelector('.player-info');
    if (infoDiv) {
      if (slot.classList.contains("bench-slot")) infoDiv.textContent = "Bench"; // ou "Bench"
      else infoDiv.textContent = slot.dataset.role || slot.getAttribute("data-role") || "";
    }
  });

  // 🔧 NOVO: alinhar orientação do grid ao time salvo
  orientGridToSavedTeam(team);

  // agora preenche titulares nos índices do time salvo
  const hexes = Array.from(document.querySelectorAll(".hex"));
  team.main.forEach((nome, i) => {
    if (!nome) return;
    const personagem = characters.find(p => p.nome === nome);
    if (personagem && hexes[i]) {
      setCharacter(hexes[i], personagem, hexes[i].dataset.role || hexes[i].getAttribute("data-role"));
    }
  });

    const benches = Array.from(document.querySelectorAll(".bench-slot"));
    team.bench.forEach((nome, i) => {
        if (!nome) return;
        const personagem = characters.find(p => p.nome === nome);
        if (personagem && benches[i]) {
            setCharacter(benches[i], personagem, 'bench');
            attachBenchEvents(benches[i]);
        }
    });

    equipState.clear();                 // (garante que nada antigo fique no Map)
    restoreTeamItems(team.items);       // <- aplica memories/potentials
    updateSynergies();
}

/* ====== ABRIR / FECHAR MENU ====== */
const menuBtn = document.getElementById("menuBtn");
const sidebar = document.getElementById("sidebar");
const closeSidebar = document.getElementById("closeSidebar");

menuBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    sidebar.classList.add("open");
    menuBtn.style.display = "none";
});

closeSidebar.addEventListener("click", (e) => {
    e.stopPropagation();
    sidebar.classList.remove("open");
    menuBtn.style.display = "block";
});

// Fecha se clicar fora do painel (ignora se clicar dentro)
document.addEventListener("click", (e) => {
    // Clique dentro do sidebar ou no botão de abrir → não fecha
    if (sidebar.contains(e.target) || e.target === menuBtn) {
        return;
    }

    // Clique num personagem → não fecha
   if (e.target.closest(".char-card, .person-card, #charList")) {
  return;
}

    // Clique em botões de voltar (FAQ, Credits, Synergies, Detalhes) → não fecha
    if (
        e.target.closest("#backToHelp") ||
        e.target.closest("#backToSynergies") ||
        e.target.closest("#backToChar")
    ) {
        return;
    }
    if (
  e.target.closest('#pageRanking') ||
  e.target.closest('#btnOpenRanking') ||
  e.target.closest('#btnRank7d') ||
  e.target.closest('#btnRankAll') ||
  e.target.closest('#btnRankChars')
) {
  return;
}
    // Fecha apenas se realmente foi fora
    if (sidebar.classList.contains("open")) {
        sidebar.classList.remove("open");
        menuBtn.style.display = "block";
    }
});
    // Botão para limpar todo o time e resetar o banco
    document.getElementById("clearTeamBtn").addEventListener("click", (e) => {
    e.stopPropagation();
    if (!confirm("Are you sure you want to reset court and bench?")) return;

    // Fecha o Side Menu se estiver aberto
    sidebar.classList.remove("open");
    menuBtn.style.display = "block";

    // Limpa seleção
    selecionados = [];
    equipState.clear();
    document.querySelectorAll('.hex, .bench-slot')
   .forEach(el => el.querySelectorAll('.item-badge,.item-gear').forEach(n => n.remove()));

    clearAllEquips();
    document.querySelectorAll('.hex, .bench-slot').forEach(el => {
    if (el.dataset.nome || el.dataset.charName) removeCharacter(el);
});
    // Reseta todos os slots principais
    document.querySelectorAll(".hex").forEach(slot => {
        slot.innerHTML = "";
        delete slot.dataset.nome;
        const infoDiv = slot.parentElement.querySelector('.player-info');
        infoDiv.textContent = slot.dataset.role || slot.getAttribute("data-role") || "";
    });

    // Reseta banco para 3 slots
    const benchRow = document.getElementById("bench-row");
    benchRow.querySelectorAll(".player-slot.bench").forEach((benchSlot, index) => {
        if (index >= 3) {
            benchSlot.remove();
        } else {
            const slot = benchSlot.querySelector(".bench-slot");
            slot.innerHTML = "";
            delete slot.dataset.nome;
            const infoDiv = benchSlot.querySelector('.player-info');
            infoDiv.textContent = "Bench";
        }
    });
    updateSynergies();
    });
    /* ===================== ITEMS: Memory + Potential (4p/2p) ===================== */

/** Estat keys do seu dataset */
const STAT_KEYS = ["Serve","Spike","Set","Receive","Block","Save"];

/** Estado por slot: { memoryId, set4, set2 } */
const equipState = new Map();

/** Utils de slot */
function getSlotId(el){
  if(!el.dataset.slotId){
    const prefix = el.classList.contains('bench-slot') ? 'bench' : 'court';
    const all = [...document.querySelectorAll('.hex, .bench-slot')];
    const idx = all.indexOf(el);
    el.dataset.slotId = `${prefix}-${idx >= 0 ? idx : Math.random().toString(36).slice(2,8)}`;
  }
  return el.dataset.slotId;
}
function getSlotChar(el){ return el?.dataset?.charName || null; }
function findCharacterByName(name){ return characters.find(c => c.nome === name) || null; }

/** Aplicadores de bônus */
function applyBonus(twoPiece, bonus){
  if(!bonus) return;
  for(const [stat, mod] of Object.entries(bonus)){
    if(twoPiece[stat] == null) continue;
    if(mod.pct)  twoPiece[stat] = Math.round(twoPiece[stat]*(1+mod.pct/100));
    if(mod.flat) twoPiece[stat] = Math.max(0, twoPiece[stat]+mod.flat);
  }
}
function computeEffectiveStats(baseStats, memoryId, set4Id, set2Id){
  const out = { ...baseStats};
  // Memory
  if(memoryId){
    const mem = memoryCatalog.find(m=>m.id===memoryId);
    if(mem) applyBonus(out, mem.bonus);
  }
  // Potential (sets)
  if(set2Id){
    const s2 = setCatalog.find(s=>s.id===set2Id);
    if(s2) applyBonus(out, s2.twoPiece);
  }
  if(set4Id){
    const s4 = setCatalog.find(s=>s.id===set4Id);
    if(s4){
      // comportamento comum: 4p também concede o 2p do mesmo set
      if(!set2Id || set2Id===set4Id) applyBonus(out, s4.twoPiece);
      applyBonus(out, s4.fourPiece);
    }
  }
  return out;
}


// normaliza função (role) do personagem para os códigos do catálogo
function normalizeRole(role){
  const r = String(role||"").toLowerCase();
  if (["s","setter","levantador"].includes(r)) return "S";
  if (["mb","middle","middle blocker","central","meio"].includes(r)) return "MB";
  if (["ws","wing","wing spiker","ponteiro","ponta"].includes(r)) return "WS";
  if (["op","opposite","oposto"].includes(r)) return "OP";
  if (["l","libero","líbero","libero"].includes(r)) return "L";
  return role || "WS"; // fallback
}

// pega % de um bônus {pct} dado um stat
function pctOf(obj, key){
  return (obj && obj[key] && typeof obj[key].pct === "number") ? obj[key].pct : 0;
}

// normaliza nomes p/ casar personagem com memória
function norm(s){
  return (s||"").toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'') // sem acento
    .replace(/[^\p{L}\p{N}]+/gu,' ')                 // sem pontuação
    .trim();
}
function recommendMemoryForCharacter(ch, allowedMem){
  if (!allowedMem || allowedMem.length === 0) return null;
  const cname = norm(ch.nome || ch.name);

  // 1) owner explícito (se você usa esse campo)
  let cand = allowedMem.find(m => m.owner && norm(m.owner) === cname);
  if (cand) return cand.id;

  // 2) nome/id contém o nome do personagem (ex.: "Ushijima UR")
  cand = allowedMem.find(m => norm(m.name).includes(cname) || norm(m.id).includes(cname.replace(/\s+/g,'_')));
  if (cand) return cand.id;

  // 3) todos os tokens do nome do personagem aparecem no nome da memória
  const tokens = cname.split(' ').filter(Boolean);
  cand = allowedMem.find(m => tokens.every(t => norm(m.name).includes(t)));
  if (cand) return cand.id;

  // 4) fallback: primeira compatível
  return allowedMem[0]?.id || null;
}


function topStatKey(stats){
  let bestK=null, bestV=-Infinity;
  for(const k of STAT_KEYS){
    const v = typeof stats?.[k] === "number" ? stats[k] : -Infinity;
    if (v > bestV){ bestV=v; bestK=k; }
  }
  return bestK;
}

function totalPctForCombo(set4, set2, statKey){
  let total = 0;
  if (set4){
    // 4p concede 2p do mesmo set quando não há 2p selecionado ou quando é o mesmo set
    if ((!set2 || set2.id === set4.id) && set4.twoPiece) total += pctOf(set4.twoPiece, statKey);
    if (set4.fourPiece) total += pctOf(set4.fourPiece, statKey);
  }
  if (set2 && (!set4 || set2.id !== set4.id) && set2.twoPiece){
    total += pctOf(set2.twoPiece, statKey);
  }
  return total;
}

// util: pega % de um bônus para um stat
function pctOf(obj, key){
  return (obj && obj[key] && typeof obj[key].pct === 'number') ? obj[key].pct : 0;
}
// util: qual o Mayr stat base do personagem
function topStatKey(stats){
  let bestK=null, bestV=-Infinity;
  for(const k of STAT_KEYS){
    const v = typeof stats?.[k] === "number" ? stats[k] : -Infinity;
    if (v > bestV){ bestV=v; bestK=k; }
  }
  return bestK;
}

function recommendSetsByTopStat(ch, allowedSet){
  if (!allowedSet || allowedSet.length === 0) return { set4:null, set2:null };

  // helpers locais
  const findSetIdByName = (arr, name) => {
    const n = (name||"").toLowerCase();
    const hit = arr.find(s =>
      (s.name && s.name.toLowerCase() === n) ||
      (s.id   && s.id.toLowerCase()   === n)
    );
    return hit ? hit.id : null;
  };
  const hasSymbol = (sym) => Array.isArray(ch.symbols) && ch.symbols.includes(sym);

  // escolhe o melhor 4p e 2p para um stat (mantém a sua regra anterior)
  const bestByStat = (statKey) => {
    let best4 = null, best4Score = -Infinity;
    for (const s4 of allowedSet){
      const score = pctOf(s4.twoPiece, statKey) + pctOf(s4.fourPiece, statKey);
      if (score > best4Score){ best4Score = score; best4 = s4; }
    }
    let best2 = null, best2Score = -Infinity;
    for (const s2 of allowedSet){
      if (best4 && s2.id === best4.id) continue;      // 2p diferente do 4p
      const score = pctOf(s2.twoPiece, statKey);
      if (score > best2Score){ best2Score = score; best2 = s2; }
    }
    return { set4: best4?.id || null, set2: best2?.id || null };
  };

  const role = normalizeRole(ch.funcao); // já existe no seu código
  const top  = topStatKey(ch.Stats || {}); // já existe no seu código

  // --- Regra 1: Setters (S) têm recomendação fixa
  if (role === 'S'){ // Ex.: é montado a partir de ch.funcao na abertura do modal
    const s4 = findSetIdByName(allowedSet, 'Precise Set');
    const s2 = findSetIdByName(allowedSet, 'Precise Serve');
    return { set4: s4, set2: (s2 && s2 !== s4) ? s2 : null };
  }

  // --- Regra 3: Mayr atributo = Spike -> símbolos "quick" ou "power"
  if (top === 'Spike'){
    if (hasSymbol('img/quicksymbol.png')){
      const s4 = findSetIdByName(allowedSet, 'Rapid Quick Attack');
      const s2 = findSetIdByName(allowedSet, 'Sharp Sense');
      if (s4 || s2) return { set4: s4, set2: (s2 && s2 !== s4) ? s2 : null };
      // se não achar pelos nomes (catálogo diferente), cai no fallback
    }
    if (hasSymbol('img/powersymbol.png')){
      const s4 = findSetIdByName(allowedSet, 'Power Vibe');
      const s2 = findSetIdByName(allowedSet, 'Power Rise');
      if (s4 || s2) return { set4: s4, set2: (s2 && s2 !== s4) ? s2 : null };
    }
  }

  // --- Regra 2 (fallback): como antes, escolher pelo Mayr atributo
  return bestByStat(top || 'Spike'); // se não houver top claro, Spike como padrão
}

// helper p/ gerar HTML de um ícone com etiqueta opcional
function badgeIconHTML(src, title, tagText){
  if(!src) return "";
  return `
    <span class="ico" title="${title || ""}">
      <img src="${src}" alt="">
      ${tagText ? `<span class="tag">${tagText}</span>` : ""}
    </span>`;
}

function updateItemBadge(slotEl){
  // remove a badge anterior
  slotEl.querySelectorAll('.item-badge').forEach(n=>n.remove());

  // não mostra badge se o slot estiver vazio
  if(!slotEl.dataset.charName) return;

  const slotId = getSlotId(slotEl);
  const eq = equipState.get(slotId);
  if(!eq) return;

  const mem = eq.memoryId ? memoryCatalog.find(m=>m.id===eq.memoryId) : null;
  const s4  = eq.set4      ? setCatalog.find(s=>s.id===eq.set4)       : null;
  const s2  = eq.set2      ? setCatalog.find(s=>s.id===eq.set2)       : null;

  if(!mem && !s4 && !s2) return;

  const badge = document.createElement('div');
  badge.className = 'item-badge';

  // ÍCONES (sem texto). Etiqueta pequena: "M", "4", "2" (remova se não quiser nada)
  const parts = [];
  if(mem) parts.push(badgeIconHTML(mem.img,  `Memory: ${mem.name}`,          "M"));
  if(s4)  parts.push(badgeIconHTML(s4.img,   `Potential 4-Piece: ${s4.name}`, "4"));
  if(s2)  parts.push(badgeIconHTML(s2.img,   `Potential 2-Piece: ${s2.name}`, "2"));

  badge.innerHTML = parts.join("");
  slotEl.appendChild(badge);
}

/** Botão ⚙️ para abrir o modal (não conflita com seu dblclick de Details) */
function ensureItemGear(slotEl){
  if(slotEl.querySelector('.item-gear')) return;
  if(!slotEl.dataset.charName) return;
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.className = 'item-gear';
  btn.title = 'Items (Memory + Potential)';
  btn.innerHTML = '⚙️';
  btn.addEventListener('click', (e)=>{ e.stopPropagation(); e.preventDefault(); openItemModal(slotEl); });
  slotEl.appendChild(btn);
}
function removeItemGear(slotEl){ slotEl.querySelectorAll('.item-gear').forEach(n=>n.remove()); }

/** MODAL com Memory + Potential (4p/2p) */
function openItemModal(slotEl){
  const charName = getSlotChar(slotEl);
  if(!charName){ alert('Coloque um personagem no slot antes de equipar.'); return; }
  const ch = findCharacterByName(charName);
  if(!ch){ alert('Personagem não encontrado.'); return; }

  const slotId = getSlotId(slotEl);
  const current = equipState.get(slotId) || { memoryId:null, set4:null, set2:null };

  const role = normalizeRole(ch.funcao);
const allowedMem = memoryCatalog.filter(m => m.positions?.includes(role));
const allowedSet = setCatalog.filter(s => !s.positions || s.positions.includes(role));

  const $back = document.createElement('div'); $back.className = 'item-modal-backdrop';
  const $box  = document.createElement('div'); $box.className  = 'item-modal';
  $back.appendChild($box);

  $box.innerHTML = `
  <h3>Items for <b>${ch.nome}</b> (${ch.funcao})</h3>

   <div class="items-3col">
    <div class="row-3col">
      <div class="label">Memory</div>
      <img id="memThumb" class="big-thumb" src="" alt="">
      <div>
        <select id="memSel" class="select-wide">
          <option value="">— none —</option>
          ${allowedMem.map(m=>`<option value="${m.id}" ${m.id===current.memoryId?'selected':''}>${m.name}</option>`).join('')}
        </select>
        <div id="memDesc" class="subdesc"></div>
      </div>
    </div>

    <div class="row-3col">
      <div class="label">4-Piece</div>
      <img id="set4Thumb" class="big-thumb" src="" alt="">
      <div>
        <select id="set4Sel" class="select-wide">
          <option value="">— none —</option>
          ${allowedSet.map(s=>`<option value="${s.id}" ${s.id===current.set4?'selected':''}>${s.name}</option>`).join('')}
        </select>
        <div id="set4Desc" class="subdesc"></div>
      </div>
    </div>

    <div class="row-3col">
      <div class="label">2-Piece</div>
      <img id="set2Thumb" class="big-thumb" src="" alt="">
      <div>
        <select id="set2Sel" class="select-wide">
          <option value="">— none —</option>
          ${allowedSet.map(s=>`<option value="${s.id}" ${s.id===current.set2?'selected':''}>${s.name}</option>`).join('')}
        </select>
        <div id="set2Desc" class="subdesc"></div>
      </div>
    </div>

    <div class="row-3col">
      <div class="label">Stats</div>
      <div></div>
      <div><ul id="statsList" class="stats-list"></ul></div>
    </div>
  </div>

  <div class="item-actions">
    <button class="item-btn" id="btnRec">Recommend</button>
    <button class="item-btn" id="btnClear">Clear</button>
    <button class="item-btn" id="btnSave">Save</button>
    <button class="item-btn" id="btnClose">Close</button>
  </div>
`;
  document.body.appendChild($back);

  const $mem  = $box.querySelector('#memSel');
  const $mD   = $box.querySelector('#memDesc');
  const $set4 = $box.querySelector('#set4Sel');
  const $set2 = $box.querySelector('#set2Sel');
  const $d4   = $box.querySelector('#set4Desc');
  const $d2   = $box.querySelector('#set2Desc');
  const $statsList = $box.querySelector('#statsList');
  const $memThumb  = $box.querySelector('#memThumb');
  const $set4Thumb = $box.querySelector('#set4Thumb');
  const $set2Thumb = $box.querySelector('#set2Thumb');

  function getSetBonusPct(statKey){
  let total = 0;
  const s4 = setCatalog.find(s => s.id === $set4.value);
  const s2 = setCatalog.find(s => s.id === $set2.value);

  if (s4){
    if (s4.twoPiece && s4.twoPiece[statKey] && typeof s4.twoPiece[statKey].pct === "number")
      total += s4.twoPiece[statKey].pct;   // 2p “embutido” no 4p
    if (s4.fourPiece && s4.fourPiece[statKey] && typeof s4.fourPiece[statKey].pct === "number")
      total += s4.fourPiece[statKey].pct;  // 4p
  }
  // só soma 2p diferente do 4p
  if (s2 && (!s4 || s2.id !== s4.id)){
    if (s2.twoPiece && s2.twoPiece[statKey] && typeof s2.twoPiece[statKey].pct === "number")
      total += s2.twoPiece[statKey].pct;
  }
  return total;
}

  function refreshThumbs(){
  const mem = memoryCatalog.find(m=>m.id===$mem.value);
  const s4  = setCatalog.find(s=>s.id===$set4.value);
  const s2  = setCatalog.find(s=>s.id===$set2.value);
  $memThumb.src  = mem?.img  || "";
  $set4Thumb.src = s4?.img   || "";
  $set2Thumb.src = s2?.img   || "";
}

  function renderChoice($el, item, fallbackTitle){
  if(item){
    $el.classList.remove('empty');
    $el.querySelector('img').src = item.img || "";
    $el.querySelector('.title').textContent = item.name;
    $el.querySelector('.subtitle').textContent = item.short || ""; // opcional
  }else{
    $el.classList.add('empty');
    $el.querySelector('img').src = "";
    $el.querySelector('.title').textContent = fallbackTitle || "— none —";
    $el.querySelector('.subtitle').textContent = "";
  }
}

function refreshChoices(){
  const mem = memoryCatalog.find(m=>m.id===$mem.value);
  const s4  = setCatalog.find(s=>s.id===$set4.value);
  const s2  = setCatalog.find(s=>s.id===$set2.value);
  renderChoice($box.querySelector('#memChoice'),  mem, "— none —");
  renderChoice($box.querySelector('#set4Choice'), s4,  "— none —");
  renderChoice($box.querySelector('#set2Choice'), s2,  "— none —");
}
  function updateSetLocks(){
  const v4 = $set4.value, v2 = $set2.value;
  [...$set2.options].forEach(o => o.disabled = !!v4 && o.value === v4 && o.value !== "");
  [...$set4.options].forEach(o => o.disabled = !!v2 && o.value === v2 && o.value !== "");
}
$set4.addEventListener('change', ()=>{ updateSetLocks(); refreshDescs(); renderStats(); });
$set2.addEventListener('change', ()=>{ updateSetLocks(); refreshDescs(); renderStats(); });
updateSetLocks();

  function refreshDescs(){
  const mem = memoryCatalog.find(m=>m.id===$mem.value);
  const s4  = setCatalog.find(s=>s.id===$set4.value);
  const s2  = setCatalog.find(s=>s.id===$set2.value);
  $mD.textContent = mem ? (mem.desc || '') : '';
  $d4.textContent = s4 ? (s4.desc4 || '') : '';
  $d2.textContent = s2 ? (s2.desc2 || '') : '';
  refreshThumbs();
}
// Retorna quanto a Memory soma EM PONTOS para um stat específico
function getMemoryBonusAbs(statKey){
  const mem = memoryCatalog.find(m=>m.id===$mem.value);
  if(!mem || !mem.bonus || !mem.bonus[statKey]) return 0;
  const base = ch.Stats[statKey] || 0;
  const mod  = mem.bonus[statKey];
  const pct  = mod.pct ? Math.round(base * (mod.pct/100)) : 0;
  const flat = mod.flat ? mod.flat : 0;
  return pct + flat; // valor absoluto adicionado pela memória
}

// Retorna o TOTAL de % dos sets (2p/4p) efetivamente aplicados para o stat
function getSetBonusPct(statKey){
  let total = 0;

  const s4 = setCatalog.find(s=>s.id===$set4.value);
  const s2 = setCatalog.find(s=>s.id===$set2.value);

  // 4p selecionado: normalmente concede o 2p do mesmo set se o 2p não estiver escolhido
  if(s4){
    // aplica 2p do 4p quando NÃO há set2 OU quando set2 é o mesmo set
    if((!s2 || s2.id === s4.id) && s4.twoPiece && s4.twoPiece[statKey]?.pct){
      total += s4.twoPiece[statKey].pct;
    }
    // aplica 4p
    if(s4.fourPiece && s4.fourPiece[statKey]?.pct){
      total += s4.fourPiece[statKey].pct;
    }
  }

  // 2p de um set diferente do 4p
  if(s2 && (!s4 || s2.id !== s4.id)){
    if(s2.twoPiece && s2.twoPiece[statKey]?.pct){
      total += s2.twoPiece[statKey].pct;
    }
  }

  return total; // só porcentagem
}

  // helper para considerar 0, 0.0, null etc.
function zeroish(x){ return !x || Math.abs(x) < 1e-6; }

function renderStats(){
  const rows = STAT_KEYS.map((k)=>{
    const base   = ch.Stats[k] || 0;
    const memAbs = getMemoryBonusAbs(k);   // pontos absolutos da Memory
    const setPct = getSetBonusPct(k);      // % total dos sets para esse stat

    const parts = [String(base)];
    if (!zeroish(memAbs)) parts.push(`+ ${memAbs}`);
    if (!zeroish(setPct)) parts.push(`+ ${setPct}%`); // só mostra se > 0%

    return `<li><b>${k}:</b> ${parts.join(' ')}</li>`;
  }).join('');
  $statsList.innerHTML = rows;
}

  $mem.addEventListener('change', ()=>{ refreshDescs(); renderStats(); });
  $set4.addEventListener('change', ()=>{ updateSetLocks(); refreshDescs(); renderStats(); });
  $set2.addEventListener('change', ()=>{ updateSetLocks(); refreshDescs(); renderStats(); });
  updateSetLocks();refreshDescs(); renderStats();

  $box.querySelector('#btnClose').onclick = ()=> $back.remove();
  $box.querySelector('#btnClear').onclick = ()=>{
    $mem.value=""; $set4.value=""; $set2.value="";
    refreshDescs(); renderStats();
  };
  $box.querySelector('#btnSave').onclick = ()=>{
    const data = { memoryId: $mem.value || null, set4: $set4.value || null, set2: $set2.value || null };
    equipState.set(slotId, data);
    updateItemBadge(slotEl);
    $back.remove();
  };
  $box.querySelector('#btnRec').onclick = ()=>{
  const memId = recommendMemoryForCharacter(ch, allowedMem);
  const rec   = recommendSetsByTopStat(ch, allowedSet);

  if (memId) $mem.value = memId;
  if (rec.set4) $set4.value = rec.set4;
  $set2.value = rec.set2 || "";           // sempre tenta diferente; se não houver, fica vazio

  updateSetLocks();                        // mantém 4p/2p mutuamente exclusivos na UI
  refreshDescs();
  renderStats();
};
}

/** Hooks para seu fluxo atual */
window.afterAssignCharacter = function(slotEl, charName){
  slotEl.dataset.charName = charName;
  updateItemBadge(slotEl);
  ensureItemGear(slotEl); // botão ⚙️ para abrir o modal (não conflita com dblclick de detalhes)
};
window.afterRemoveCharacter = function(slotEl){
  delete slotEl.dataset.charName;   // mantém compatibilidade com suas badges
  clearSlotEquip(slotEl);           // <- limpa Map + badges/engrenagem
  updateItemBadge(slotEl);          // defensivo (como já faz no assign)
};

// Guarda por slot, mas também salva o nome do char para restaurar por nome
function serializeTeamItems(){
  const data = {};
  document.querySelectorAll('.hex, .bench-slot').forEach(el=>{
    const id = getSlotId(el);
    const charName = el.dataset.charName || el.dataset.nome || null;
    if (!charName) return;
    const eq = equipState.get(id) || { memoryId:null, set4:null, set2:null };
    data[id] = { charName, ...eq };
  });
  return data;
}

// Ao carregar: 1) limpa tudo; 2) tenta aplicar itens pelo NOME do char.
// Se não achar o nome no grid atual, cai no slot salvo (fallback).
function restoreTeamItems(saved){
  clearAllEquips();
  if (!saved) return;

  const allSlots = Array.from(document.querySelectorAll('.hex, .bench-slot'));

  // mapa rápido: nome -> slot atual
  const byName = new Map();
  allSlots.forEach(el=>{
    const n = el.dataset.charName || el.dataset.nome || null;
    if (n) byName.set(n, el);
  });

  for (const [slotId, payload] of Object.entries(saved)){
    const target =
      byName.get(payload.charName) ||
      allSlots.find(e => getSlotId(e) === slotId);

    if (!target) continue;

    const id = getSlotId(target);
    equipState.set(id, {
      memoryId: payload.memoryId || null,
      set4:     payload.set4     || null,
      set2:     payload.set2     || null
    });
    updateItemBadge(target);
    ensureItemGear(target);
  }
}
// ========= DRAG & DROP (compatível com sua estrutura) =========
(function(){
  if (window.__dndFix) return; window.__dndFix = true;

  const getChar = n => characters.find(c => c.nome === n);
  let dragCtx = null; // {type:'character'|'slot', nome?, id?}

  function setDragCtx(obj, e){
    dragCtx = obj;
    try { e.dataTransfer.setData('application/json', JSON.stringify(obj)); } catch(_) {}
    try { e.dataTransfer.setData('text/plain', JSON.stringify(obj)); } catch(_) {}
    e.dataTransfer.effectAllowed = (obj.type === 'slot') ? 'move' : 'copyMove';
  }
  function isAllowedForStarterSlot(slotRole, charRole) {
  if (!slotRole || slotRole === 'bench') return true; // não é starter
  if (slotRole === 'L') return charRole === 'L';
  return charRole !== 'L';
}

  function canDropCharOn(slot, p){
  const isBench = slot.classList.contains('bench-slot');
  if (isBench) return respeitaLimiteBench(p, slot);

  const role = (slot.dataset.role || slot.getAttribute('data-role') || '').toUpperCase();
  if (role === 'L') return p.funcao === 'L';  // Líbero só no L
  return p.funcao !== 'L';                    // demais titulares: qualquer NÃO-L
}

  function dropCharacterOn(slot, p) {
  // zera items pendurados nesse slot (é um overwrite vindo do menu)
  equipState.delete(getSlotId(slot));

  const isBench = slot.classList.contains('bench-slot');
  const role = isBench ? 'bench' : (slot.dataset.role || slot.getAttribute('data-role'));
  setCharacter(slot, p, role);

  const sm = document.getElementById("scrollMenu");
  if (sm) sm.style.display = "none";
}
 // Helper: pega o personagem de um slot (titular ou banco)
function getCharacterFromSlot(el){
  if (!el) return null;
  const n = el.dataset?.nome || el.dataset?.charName || null;
  return n ? (characters.find(c => c.nome === n) || null) : null;
}

  // Troca/move entre slots (qualquer posição entre si, exceto L só em L)
function moveBetweenSlots(srcEl, dstEl){
  if (!srcEl || !dstEl || srcEl === dstEl) return;

  const pSrc = getCharacterFromSlot(srcEl);
  const pDst = getCharacterFromSlot(dstEl);
  if (!pSrc && !pDst) return;   // nada para fazer
  if (!pSrc) return;            // origem vazia (arraste inválido)

  const srcIsBench = srcEl.classList.contains('bench-slot');
  const dstIsBench = dstEl.classList.contains('bench-slot');

  const srcRole = ((srcEl.dataset.role || srcEl.getAttribute('data-role') || '') + '').toUpperCase();
  const dstRole = ((dstEl.dataset.role || dstEl.getAttribute('data-role') || '') + '').toUpperCase();

  // Regras dos titulares: L só em L; demais titulares: qualquer NÃO-L
  function allowedForStarter(slotRole, charRole){
    if (!slotRole || slotRole === 'BENCH') return true;
    if (slotRole === 'L') return charRole === 'L';
    return charRole !== 'L';
  }

  // 1) Validar destino para pSrc
  if (dstIsBench) {
    if (!respeitaLimiteBench(pSrc, dstEl)) return;
  } else {
    if (!allowedForStarter(dstRole, pSrc.funcao)) return;
  }

  // 2) Se houver pDst (swap), validar “volta” para pDst
  if (pDst){
    if (srcIsBench) {
      if (!respeitaLimiteBench(pDst, srcEl)) return;
    } else {
      if (!allowedForStarter(srcRole, pDst.funcao)) return;
    }
  }

  // --- Itens (equipState): preparar ids e estados
  const srcId = getSlotId(srcEl);
  const dstId = getSlotId(dstEl);
  const srcEq = equipState.get(srcId) || null;
  const dstEq = equipState.get(dstId) || null;

  const srcKeepRole = srcIsBench ? 'bench' : srcRole;
  const dstKeepRole = dstIsBench ? 'bench' : dstRole;

  if (pDst){
    // SWAP: troca itens também
    if (srcEq) equipState.set(dstId, srcEq); else equipState.delete(dstId);
    if (dstEq) equipState.set(srcId, dstEq); else equipState.delete(srcId);

    removeCharacter(srcEl);
    removeCharacter(dstEl);
    setCharacter(srcEl, pDst, srcKeepRole);
    setCharacter(dstEl, pSrc, dstKeepRole);
  } else {
    // MOVE: leva itens juntos
    const keep = srcEq ? { ...srcEq } : null;
    equipState.delete(srcId);
    if (keep) equipState.set(dstId, keep);

    removeCharacter(srcEl);
    setCharacter(dstEl, pSrc, dstKeepRole);
  }

  // Atualiza badges/engrenagem (seu fluxo atual)
  if (typeof updateItemBadge === 'function') { updateItemBadge(srcEl); updateItemBadge(dstEl); }
  if (typeof ensureItemGear   === 'function') { ensureItemGear(srcEl); ensureItemGear(dstEl); }
}

  function decorateDropTarget(slot){
    slot.addEventListener('dragover', (e)=>{
      // permita o drop SEM depender de getData()
      e.preventDefault();
      const ctx = dragCtx;
      let ok = false;
      if (ctx?.type === 'character'){
        const p = getChar(ctx.nome);
        ok = !!p && canDropCharOn(slot, p);
      } else if (ctx?.type === 'slot'){
        const srcEl = Array.from(document.querySelectorAll('.hex, .bench-slot')).find(el => getSlotId(el) === ctx.id);
        const p = srcEl?.dataset.nome ? getChar(srcEl.dataset.nome) : null;
        ok = !!p && (slot === srcEl || canDropCharOn(slot, p));
      }
      slot.classList.toggle('drop-ok', ok);
      slot.classList.toggle('drop-bad', ctx && !ok);
    });

    slot.addEventListener('dragleave', ()=> slot.classList.remove('drop-ok','drop-bad'));

    slot.addEventListener('drop', (e)=>{
      e.preventDefault();
      slot.classList.remove('drop-ok','drop-bad');
      const ctx = dragCtx; dragCtx = null; // consome o contexto

      if (!ctx) return;
      if (ctx.type === 'character'){
        const p = getChar(ctx.nome);
        if (p && canDropCharOn(slot, p)) dropCharacterOn(slot, p);
      } else if (ctx.type === 'slot'){
        const srcEl = Array.from(document.querySelectorAll('.hex, .bench-slot')).find(el => getSlotId(el) === ctx.id);
        if (srcEl) moveBetweenSlots(srcEl, slot);
      }
    });

    // habilita arrastar a partir do slot quando tiver personagem
    const refresh = ()=> slot.setAttribute('draggable', slot.dataset.nome ? 'true' : 'false');
    refresh();
    slot.addEventListener('dragstart', (e)=>{
      if (!slot.dataset.nome) return;
      setDragCtx({ type:'slot', id:getSlotId(slot), nome:slot.dataset.nome }, e);
    });

    // atualiza o draggable quando setar/remover
    const oldAssign = window.afterAssignCharacter;
    window.afterAssignCharacter = function(el, name){
      if (typeof oldAssign === 'function') oldAssign(el, name);
      if (el === slot) slot.setAttribute('draggable','true');
    };
    const oldRemove = window.afterRemoveCharacter;
    window.afterRemoveCharacter = function(el){
      if (typeof oldRemove === 'function') oldRemove(el);
      if (el === slot) slot.setAttribute('draggable','false');
    };
  }

  function decorateAll(){ document.querySelectorAll('.hex, .bench-slot').forEach(decorateDropTarget); }

  function initDnd(){
    // 1) Fontes: **#charList** (lista do menu lateral)
    const list = document.getElementById('charList');
    if (list){
      list.addEventListener('dragstart', (e)=>{
        const img = e.target.closest('img'); if (!img) return;
        const nome = img.alt || img.title;
        if (getChar(nome)) { img.setAttribute('draggable','true'); setDragCtx({type:'character', nome}, e); }
      });
      list.querySelectorAll('img').forEach(img => img.setAttribute('draggable','true'));
    }

    // 2) Fontes: #scrollMenu (seu menu flutuante por posição)
    const sm = document.getElementById('scrollMenu');
    if (sm){
      sm.addEventListener('dragstart', (e)=>{
        const img = e.target.closest('img'); if (!img) return;
        const nome = img.alt || img.title;
        if (getChar(nome)) { img.setAttribute('draggable','true'); setDragCtx({type:'character', nome}, e); }
      });
      sm.querySelectorAll('img').forEach(img => img.setAttribute('draggable','true'));
    }

    // 3) Alvos e fontes: quadra + banco
    decorateAll();

    // redecorar após rotacionar (se você rotaciona os hex com innerHTML)
    if (typeof window.rotateRingClockwise === 'function' && !window.__dndWrapRot){
      const old = window.rotateRingClockwise;
      window.rotateRingClockwise = function(){
        const r = old.apply(this, arguments);
        try { RING_IDX.map(i => document.querySelectorAll('.hex')[i]).forEach(decorateDropTarget); }
        catch(_) { decorateAll(); }
        return r;
      };
      window.__dndWrapRot = true;
    }

    // redecorar após adicionar novo slot de bench
    if (typeof window.addBenchSlot === 'function' && !window.__dndWrapAdd){
      const old = window.addBenchSlot;
      window.addBenchSlot = function(){
        const r = old.apply(this, arguments);
        const last = Array.from(document.querySelectorAll('.bench-slot')).pop();
        if (last) decorateDropTarget(last);
        return r;
      };
      window.__dndWrapAdd = true;
    }
  }

  (function bootOnce(){
  function start(){
    if (!window.__dndInited){ window.__dndInited = true; initDnd(); }
    if (!window.__mtInited){ window.__mtInited = true; initMultiTeams(); }
    if (!window.__recoInited){ window.__recoInited = true; bindRecommendControls(); }
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', start);
  } else {
    start();
  }
})();
})();

// === fechar #charList ao clicar fora / ESC, ligado sob demanda ===
(function(){
  let off = null; // guard para remover handlers antigos

  function enableCloseOutsideCharList(){
  if (off) { off(); off = null; }

  const list = document.getElementById('charList');
  if (!list) return;

  const onDown = (e) => {
    // ✅ qualquer clique dentro do sidebar (filtros + lista) NÃO fecha
    if (e.target.closest('#sidebar-content')) return;

    // cliques no link que abre Characters também não fecham
    if (e.target.closest("[data-section='characters'], [data-open-charlist]")) return;

    // ❌ clique realmente fora => fecha
    list.classList.add('is-hidden');
    cleanup();
  };

    const onEsc = (e)=>{
      if (e.key === "Escape") {
        list.classList.add('is-hidden');
        cleanup();
      }
    };

    function cleanup(){
      document.removeEventListener('pointerdown', onDown, true);
      document.removeEventListener('keydown', onEsc);
      off = null;
    }

    document.addEventListener('pointerdown', onDown, true); // captura cedo
    document.addEventListener('keydown', onEsc);

    // fornece um “desligar” externo para quando trocar de seção
    off = cleanup;
  }

  // deixa acessível para chamar ao montar a seção
  window.enableCloseOutsideCharList = enableCloseOutsideCharList;
})();

function clearSlotEquip(slotEl){
  const id = getSlotId(slotEl);
  equipState.delete(id);
  slotEl.querySelectorAll('.item-badge,.item-gear').forEach(n=>n.remove());
}

function clearAllEquips(){
  equipState.clear();
  document.querySelectorAll('.hex, .bench-slot')
    .forEach(el => el.querySelectorAll('.item-badge,.item-gear').forEach(n=>n.remove()));
}

// mover o “equip” junto com o personagem (A -> B), trocando se B já tiver algo
function transferEquipState(fromEl, toEl){
  const a = getSlotId(fromEl);
  const b = getSlotId(toEl);
  const aEq = equipState.get(a) || null;
  const bEq = equipState.get(b) || null;

  if (aEq == null && bEq == null) return;

  // se B já tem alguém, trocamos; se B estava vazio, apenas movemos
  if (bEq != null && aEq != null){
    equipState.set(a, bEq);
    equipState.set(b, aEq);
  } else if (aEq != null){
    equipState.delete(a);
    equipState.set(b, aEq);
  } else { // bEq != null
    equipState.set(a, bEq);
    equipState.delete(b);
  }

  updateItemBadge(fromEl);
  updateItemBadge(toEl);
}
// ===== Recommend: preenche os slots vazios maximizando sinergias =====

// Soma total dos Stats do personagem
function sumStats(p){
  const S = p.Stats || {};
  let total = 0;
  for (const k in S) total += (S[k] || 0);
  return total;
}

// Coleta nomes atuais (starters e bench)
function getCurrentTeamNames(){
  const main = [...document.querySelectorAll('.hex')]
    .map(s => s.dataset.nome).filter(Boolean);
  const bench = [...document.querySelectorAll('.bench-slot')]
    .map(s => s.dataset.nome).filter(Boolean);
  return { main, bench };
}

// Quais slots de titulares estão vazios
function getEmptyStarterSlots(){
  return [...document.querySelectorAll('.hex')].filter(s => !s.dataset.nome);
}

// === Índices de sinergias (construídos 1x) ===
let BOND_INDEX = null;    // { bondName -> Set(nomes) }
let SCHOOL_INDEX = null;  // { schoolName -> Set(nomes) }

function buildSynergyIndices(){
  if (BOND_INDEX && SCHOOL_INDEX) return;
  BOND_INDEX = {};
  SCHOOL_INDEX = {};

  for (const p of characters){
    // Schools
    if (p.School){
      if (!SCHOOL_INDEX[p.School]) SCHOOL_INDEX[p.School] = new Set();
      SCHOOL_INDEX[p.School].add(p.nome);
    }
    // Bonds (vinculo pode ser string ou array)
    const vs = Array.isArray(p.vinculo) ? p.vinculo : (p.vinculo ? [p.vinculo] : []);
    for (const v of vs){
      if (!BOND_INDEX[v]) BOND_INDEX[v] = new Set();
      BOND_INDEX[v].add(p.nome);
    }
  }
}

// Conta quantas sinergias ativas (Schools + Bonds) do time final
// incluem ao menos 1 dos titulares que já estavam no grid (âncora).
function anchoredSynergyScore(activeSchools, activeBonds, oldMainSet){
  let score = 0;

  // Schools: se a school ativa tem pelo menos 1 membro já presente no grid original
  for (const sch of activeSchools){
    const members = SCHOOL_INDEX[sch];
    if (!members) continue;
    for (const name of members){
      if (oldMainSet.has(name)){
        score++;
        break;
      }
    }
  }
  // Bonds: se o bond ativo tem pelo menos 1 participante que já estava no grid original
  for (const bond of activeBonds){
    const members = BOND_INDEX[bond];
    if (!members) continue;
    for (const name of members){
      if (oldMainSet.has(name)){
        score++;
        break;
      }
    }
  }
  return score;
}

// Conta quantas sinergias ficariam ativas com os nomes passados
// (mesma regra do updateSynergies: Schools=starter-only com 4+, Bonds=starter+bench com 2+, exceto algumas que pedem 3)
function computeActivatedSynergyCount(mainNames, benchNames){
  // Mesmas exceções do seu painel
  const bondsRequire3 = new Set(["Swimming","Twin Heads"]);  // idem ao updateSynergies
  const DEFAULT_BOND_MIN = 2;
  const SCHOOL_MIN = 4;

  const SchoolsCount = {};
  const vinculosCount = {};

  // Contagem de School: só starters
  for (const nome of mainNames){
    const p = characters.find(x => x.nome === nome);
    if (!p) continue;
    SchoolsCount[p.School] = (SchoolsCount[p.School] || 0) + 1;
  }

  // Contagem de Bonds: starters + bench
  const allForBonds = [...mainNames, ...benchNames];
  for (const nome of allForBonds){
    const p = characters.find(x => x.nome === nome);
    if (!p) continue;
    const vs = Array.isArray(p.vinculo) ? p.vinculo : (p.vinculo ? [p.vinculo] : []);
    for (const v of vs){
      vinculosCount[v] = (vinculosCount[v] || 0) + 1;
    }
  }

  let count = 0;
  const activeSchools = new Set();
  const activeBonds = new Set();

  // Schools
  for (const school in SchoolsCount){
    if (SchoolsCount[school] >= SCHOOL_MIN){
      count++;
      activeSchools.add(school);
    }
  }
  // Bonds
  for (const v in vinculosCount){
    const required = bondsRequire3.has(v) ? 3 : DEFAULT_BOND_MIN;
    if (vinculosCount[v] >= required){
      count++;
      activeBonds.add(v);
    }
  }

  return { count, activeSchools, activeBonds };
}

// Gera todas as combinações escolhendo 1 candidato por slot (sem repetir nomes)
function* cartesianByIndex(lists){
  // lists: array de arrays (candidatos por slot)
  const idx = lists.map(()=>0);
  const lens = lists.map(l=>l.length);
  if (lens.some(len => len===0)) return;

  while (true){
    // combinação atual
    const combo = lists.map((l,i)=>l[idx[i]]);
    // valida duplicados de nomes
    const names = new Set(combo.map(c=>c.nome));
    if (names.size === combo.length) yield combo;

    // próximo índice (odômetro)
    let k = lists.length - 1;
    while (k >= 0){
      idx[k]++;
      if (idx[k] < lens[k]) break;
      idx[k] = 0;
      k--;
    }
    if (k < 0) break;
  }
}
// Contagens de school/bond a partir de conjuntos de nomes (starters e bench)
function synergyCounts(startersSet, benchSet){
  const all = new Set(startersSet);
  if (benchSet) benchSet.forEach(n=> all.add(n));
  const schools = {};  // {name: count}
  const bonds   = {};  // {name: count}

  all.forEach(n=>{
    const p = characters.find(x=>x.nome === n); if (!p) return;
    if (p.School) schools[p.School] = (schools[p.School]||0)+1;
    (Array.isArray(p.vinculo)?p.vinculo:[]).forEach(b=>{
      bonds[b] = (bonds[b]||0)+1;
    });
  });
  return {schools, bonds};
}

// Ativadas (o que você já usava) a partir das contagens
function synergyActivatedTotalFromCounts(cnt){
  const actSchools = Object.values(cnt.schools).filter(c=> c>=4).length;
  const actBonds   = Object.entries(cnt.bonds).filter(([b,c])=> c >= bondRequired(b)).length;
  return actSchools + actBonds;
}

// 🔥 Progresso fracionado rumo à ativação (0..nSchools+nBonds)
function synergyProgressFromCounts(cnt){
  let prog = 0;
  // schools (precisam de 4)
  for (const c of Object.values(cnt.schools)) prog += Math.min(c/4, 1);
  // bonds (precisam de 2, exceto alguns = 3)
  for (const [b,c] of Object.entries(cnt.bonds)) {
    const need = bondRequired(b);
    prog += Math.min(c/need, 1);
  }
  return prog;
}
function bondRequired(b){
  const k = String(b||'').trim().toLowerCase();
  return (k === 'swimming' || k === 'twin heads') ? 3 : 2;
}
// ==================== Recommend 2.0 ====================
const RecommendCfg = {
  wSynergy: 3, wAnchor: 1, wStats: 1,
  allowCrossRole: true,
  preferTypes: new Set(),     // 'quick','power','block','receive'

  // 🔥 pesos governados pelo slider wTeamType:
  typePrefWeight: 2.0,        // progresso
  typeActivateBonus: 6.0,     // ativou (4 / 5) -> bônus forte
  typeMajorityBonus: 3.0,     // virou majoritário
  typeNonPreferredPenalty: 2.0, // majoritário ≠ preferido? penaliza

  preselectPerSlot: 10,
  beamWidth: 100
};

// Liga os controles de recomendação (abre/fecha painel e botão Aplicar)
function bindRecommendControls(){
  const panel = document.getElementById('recoPanel');
  const btnToggle = document.getElementById('recommendBtn');
  const btnRun = document.getElementById('runRecommendBtn');
  const btnClose = document.getElementById('closeRecoBtn');

  function initSlidersOnce(){
    if (panel.__inited) return;
    panel.__inited = true;

    // sliders principais
    [
      ['wSynergy','wSynergyVal','wSynergy'],
      ['wAnchor','wAnchorVal','wAnchor'],
      ['wStats','wStatsVal','wStats']
    ].forEach(([inputId, outId, key])=>{
      const el = document.getElementById(inputId);
      const out = document.getElementById(outId);
      if (!el || !out) return;
      el.value = RecommendCfg[key];
      out.textContent = el.value;
      el.addEventListener('input', ()=>{ RecommendCfg[key] = +el.value; out.textContent = el.value; });
    });

    // 🔥 slider de Tipo do time -> typePrefWeight
    const wTT = document.getElementById('wTeamType');
const wTTv = document.getElementById('wTeamTypeVal');
if (wTT && wTTv){
  const applyTypeWeights = v => {
    const x = +v;              // 0..5 (ou o range que você definiu)
    RecommendCfg.typePrefWeight       = x;        // progresso
    RecommendCfg.typeActivateBonus    = 3 * x;    // ativar vale bastante
    RecommendCfg.typeMajorityBonus    = 1.5 * x;  // ser majoritário também ajuda
    RecommendCfg.typeNonPreferredPenalty = 1 * x; // e punimos majoritário “errado”
    wTTv.textContent = v;
  };
  wTT.value = String(RecommendCfg.typePrefWeight);
  applyTypeWeights(wTT.value);
  wTT.addEventListener('input', ()=> applyTypeWeights(wTT.value));
}

    const chkCR = document.getElementById('allowCrossRole');
    if (chkCR){
      chkCR.checked = RecommendCfg.allowCrossRole;
      chkCR.addEventListener('change', ()=> RecommendCfg.allowCrossRole = chkCR.checked);
    }

    // checkboxes de tipo preferido
    [
      ['prefQuick','quick'],
      ['prefPower','power'],
      ['prefBlock','block'],
      ['prefReceive','receive'],
    ].forEach(([id, t])=>{
      const cb = document.getElementById(id);
      if (!cb) return;
      cb.checked = RecommendCfg.preferTypes.has(t);
      cb.addEventListener('change', ()=>{
        if (cb.checked) RecommendCfg.preferTypes.add(t);
        else RecommendCfg.preferTypes.delete(t);
      });
    });
  }

  if (btnToggle && !btnToggle.__bound){
    btnToggle.__bound = true;
    btnToggle.addEventListener('click', ()=>{
      initSlidersOnce();
      panel.classList.toggle('open');
    });
  }
  if (btnRun && !btnRun.__bound){
    btnRun.__bound = true;
    btnRun.addEventListener('click', ()=>{ recommendFillSlots2(); /* panel.classList.remove('open'); */ });
  }
  if (btnClose && !btnClose.__bound){
    btnClose.__bound = true;
    btnClose.addEventListener('click', ()=> panel.classList.remove('open'));
  }
}

// helpers
function symbolToType(sym){
  const s = String(sym||"").toLowerCase();
  if (s.includes("quicksymbol"))   return "quick";
  if (s.includes("powersymbol"))   return "power";
  if (s.includes("servesymbol"))   return "serve";
  if (s.includes("settersymbol"))  return "setter";
  if (s.includes("receivesymbol")) return "receive";
  if (s.includes("blocksymbol"))   return "block";
  if (s.includes("savesymbol"))    return "save";
  return null;
}
const TYPE_MIN = t => (t === 'receive' ? 5 : 4);
const RARITY_TOKENS = new Set(['UR','SSR','SP','SR','R','N','MR']);
function baseName(name){
  const parts = String(name||'').trim().split(/\s+/);
  if (!parts.length) return '';
  const last = parts[parts.length-1].toUpperCase().replace(/[+]/g,'');
  if (RARITY_TOKENS.has(last)) parts.pop();   // remove “UR/SSR/SP/…”
  return parts.join(' ');
}

function typeProgress(counts, preferSet){
  let total = 0;
  preferSet.forEach(t=>{
    const c = counts[t] || 0;
    total += c / TYPE_MIN(t);
  });
  return total;
}
function startersSlots(){ return Array.from(document.querySelectorAll('.hex')); }
function benchSlots(){ return Array.from(document.querySelectorAll('.bench-slot')); }
function slotRole(el){ return (el.dataset.role || el.getAttribute('data-role') || '').toUpperCase(); }
function slotName(el){ return el?.dataset?.nome || null; }
function charByName(n){ return characters.find(c => c.nome === n); }
function sumStats(p){
  const S = p?.Stats || {};
  return (S.Serve|0)+(S.Spike|0)+(S.Set|0)+(S.Receive|0)+(S.Block|0)+(S.Save|0);
}
function allowedRolesForSlot(role, allowCross){
  if (role === 'L') return ['L'];
  return allowCross ? ['S','MB','WS','OP'] /* não-L */ : [role];
}

// contagem de tipos entre titulares (Set de nomes)
function teamTypeCountsFromNames(nameSet){
  const counts = {};
  nameSet.forEach(n=>{
    const p = characters.find(x => x.nome === n); if (!p) return;
    (Array.isArray(p.symbols)?p.symbols:[]).map(symbolToType).filter(Boolean)
      .forEach(t => counts[t] = (counts[t]||0)+1);
  });
  return counts;
}
function maxTypeInfo(counts){
  let best = [], bestN = 0;
  for (const [t,c] of Object.entries(counts)){
    if (c > bestN){ best=[t]; bestN=c; }
    else if (c === bestN) best.push(t);
  }
  return {types:best, count:bestN};
}

// Schools e Bonds ativados, recebendo SET de titulares e SET de banco (opcional)
function schoolsAndBondsActivated(startersSet, benchSet){
  const all = new Set(startersSet);
  if (benchSet) benchSet.forEach(n=> all.add(n));

  const schoolCount = {};
  const bondCount = {};
  all.forEach(n=>{
    const p = characters.find(x => x.nome === n); if (!p) return;
    if (p.School) schoolCount[p.School] = (schoolCount[p.School]||0)+1;
    (Array.isArray(p.vinculo)?p.vinculo:[]).forEach(b=>{
      bondCount[b] = (bondCount[b]||0)+1;
    });
  });

  const schoolsActive = Object.values(schoolCount).filter(c=>c>=4).length;
  const bondsActive = Object.entries(bondCount).filter(([b,c])=> c >= bondRequired(b)).length;
  return {schoolsActive, bondsActive, total: schoolsActive + bondsActive};
}

// âncora: quantas novas sinergias (school/bond) incluem ao menos 1 nome já existente
function anchorGain(beforeSet, afterSet){
  const added = new Set([...afterSet].filter(n=>!beforeSet.has(n)));
  if (!added.size) return 0;

  const bondMembers = {}, schoolMembers = {};
  afterSet.forEach(n=>{
    const p = characters.find(x => x.nome === n); if (!p) return;
    if (p.School) (schoolMembers[p.School]||(schoolMembers[p.School]=new Set())).add(n);
    (Array.isArray(p.vinculo)?p.vinculo:[]).forEach(b=>{
      (bondMembers[b]||(bondMembers[b]=new Set())).add(n);
    });
  });

  let gain = 0;
  for (const [school, members] of Object.entries(schoolMembers)){
    if (members.size>=4){
      const hasOld = [...members].some(n=>beforeSet.has(n));
      const hasNew = [...members].some(n=>added.has(n));
      if (hasOld && hasNew) gain += 1;
    }
  }
  for (const [bond, members] of Object.entries(bondMembers)){
    if (members.size>=bondRequired(bond)){
      const hasOld = [...members].some(n=>beforeSet.has(n));
      const hasNew = [...members].some(n=>added.has(n));
      if (hasOld && hasNew) gain += 1;
    }
  }
  return gain;
}

// construção de candidatos por slot
function candidatePoolForSlot(slot, excludeNames, allowCross){
  const role = slotRole(slot);
  const allowed = new Set(allowedRolesForSlot(role, allowCross));
  return characters.filter(p=>{
    if (excludeNames.has(p.nome)) return false;
    // L só pode ir no L; se allowed == [role] no modo não-cross, já restringe
    if (role === 'L') return p.funcao === 'L';
    if (!allowCross) return p.funcao === role;
    return p.funcao !== 'L'; // cross-role: qualquer não-L em slots não-L
  });
}

// cria produto cartesiano limitado
function* cartesianLimited(arrays, limit){
  const idx = arrays.map(()=>0);
  let produced = 0;
  while (arrays.length && produced < limit){
    // yield combinação atual
    yield arrays.map((a,i)=>a[idx[i]]);
    produced++;
    // incrementa
    let k = arrays.length - 1;
    while (k>=0){
      idx[k]++;
      if (idx[k] < arrays[k].length) break;
      idx[k]=0; k--;
    }
    if (k<0) break;
  }
}

function recommendFillSlots2(){
  const starterEls = Array.from(document.querySelectorAll('.hex'));
  const benchEls   = Array.from(document.querySelectorAll('.bench-slot'));

  // 1) Estado atual
  const beforeStarters = new Set(starterEls.map(s => s.dataset?.nome).filter(Boolean));
  const benchNames     = new Set(benchEls.map(s => s.dataset?.nome).filter(Boolean));
  const emptySlots     = starterEls.filter(s => !s.dataset?.nome);
  if (!emptySlots.length) return;

  // 2) Sinergias "antes"
  const beforeCnt     = synergyCounts(beforeStarters, benchNames);
  const synBeforeAct  = synergyActivatedTotalFromCounts(beforeCnt);
  const synBeforeProg = synergyProgressFromCounts(beforeCnt);

  // 3) Pré-cálculos
  const filledBase       = new Set([...beforeStarters, ...benchNames].map(baseName));
  const beforeTypeCounts = teamTypeCountsFromNames(beforeStarters);
  const baseTypeProg     = typeProgress(beforeTypeCounts, RecommendCfg.preferTypes);
  const synBeforeTotal   = schoolsAndBondsActivated(beforeStarters, benchNames).total;

  // utils
  const slotRole = el => (el.dataset.role || el.getAttribute('data-role') || '').toUpperCase();
  const allowedRolesForSlot = role => role==='L' ? ['L'] : (RecommendCfg.allowCrossRole ? ['S','MB','WS','OP'] : [role]);
  const sumStats = p => { const S=p.Stats||{}; return (S.Serve|0)+(S.Spike|0)+(S.Set|0)+(S.Receive|0)+(S.Block|0)+(S.Save|0); };

  // 4) Pools por slot (pré-seleção por sinergia + tipo + stats)
  const pools = emptySlots.map(slot=>{
    const role = slotRole(slot);

    let list = characters.filter(p=>{
      if (beforeStarters.has(p.nome) || benchNames.has(p.nome)) return false;
      if (filledBase.has(baseName(p.nome))) return false;      // evita duplicar jogador em outra raridade
      if (role==='L') return p.funcao==='L';
      return RecommendCfg.allowCrossRole ? (p.funcao!=='L') : (p.funcao===role);
    });

    list = list.map(p=>{
      // --- Sinergia 1 passo: ativadas + progresso ---
      const afterStarters = new Set(beforeStarters); afterStarters.add(p.nome);
      const cntAfter   = synergyCounts(afterStarters, benchNames);
      const synAct     = synergyActivatedTotalFromCounts(cntAfter);
      const synProg    = synergyProgressFromCounts(cntAfter);
      const synDeltaAct  = synAct  - synBeforeAct;
      const synDeltaProg = synProg - synBeforeProg;
      const synScore     = RecommendCfg.wSynergy * (synDeltaAct + 0.5*synDeltaProg);

      // --- Tipo preferido ---
      const typeCountsAfter = {...beforeTypeCounts};
      (Array.isArray(p.symbols)?p.symbols:[]).map(symbolToType).filter(Boolean)
        .forEach(t=> typeCountsAfter[t]=(typeCountsAfter[t]||0)+1);

      const prefProgressAfter = typeProgress(typeCountsAfter, RecommendCfg.preferTypes);
      const prefDelta         = prefProgressAfter - baseTypeProg;

      const afterMax = maxTypeInfo(typeCountsAfter);
      const activatedPreferred   = afterMax.types.some(t=>RecommendCfg.preferTypes.has(t)) && afterMax.count >= TYPE_MIN(afterMax.types[0]||'');
      const majorityPreferred    = afterMax.types.some(t=>RecommendCfg.preferTypes.has(t));
      const majorityActivated    = afterMax.count >= TYPE_MIN(afterMax.types[0]||'');
      const nonPreferredMajority = majorityActivated && !majorityPreferred;

      const typeScore =
        (RecommendCfg.typePrefWeight * prefDelta) +
        (activatedPreferred   ? RecommendCfg.typeActivateBonus       : 0) +
        (majorityPreferred    ? RecommendCfg.typeMajorityBonus       : 0) +
        (nonPreferredMajority ? -RecommendCfg.typeNonPreferredPenalty: 0);

      return { p,
        heur: synScore + typeScore + (RecommendCfg.wStats * (sumStats(p)/2000))
      };
    })
    .sort((a,b)=> b.heur - a.heur)
    .slice(0, RecommendCfg.preselectPerSlot)
    .map(x=>x.p);

    // fallback por stats
    if (!list.length){
      list = characters
        .filter(p=> !beforeStarters.has(p.nome)
                 && !benchNames.has(p.nome)
                 && !filledBase.has(baseName(p.nome))
                 && (role==='L' ? p.funcao==='L'
                                 : (RecommendCfg.allowCrossRole ? p.funcao!=='L' : p.funcao===role)))
        .sort((a,b)=> sumStats(b)-sumStats(a))
        .slice(0, RecommendCfg.preselectPerSlot);
    }
    return list;
  });

  // 5) BEAM search
  let beam = [{ pick:[], names:new Set(), base:new Set(filledBase), score:0, stats:0 }];
  emptySlots.forEach((slot, stepIdx)=>{
    const next = [];
    for (const state of beam){
      for (const p of pools[stepIdx]){
        if (state.names.has(p.nome)) continue;
        const b = baseName(p.nome);
        if (state.base.has(b)) continue;

        const namesAfter = new Set([...beforeStarters, ...state.names, p.nome]);

        const synAfter = schoolsAndBondsActivated(namesAfter, benchNames).total;
        const synDelta = synAfter - synBeforeTotal;

        const ancGain = anchorGain(beforeStarters, namesAfter);

        const afterTypeCounts   = teamTypeCountsFromNames(namesAfter);
        const prefProgressAfter = typeProgress(afterTypeCounts, RecommendCfg.preferTypes);
        const prefDelta         = prefProgressAfter - baseTypeProg;

        const afterMax = maxTypeInfo(afterTypeCounts);
        const activatedPreferred   = afterMax.types.some(t=>RecommendCfg.preferTypes.has(t)) && afterMax.count >= TYPE_MIN(afterMax.types[0]||'');
        const majorityPreferred    = afterMax.types.some(t=>RecommendCfg.preferTypes.has(t));
        const majorityActivated    = afterMax.count >= TYPE_MIN(afterMax.types[0]||'');
        const nonPreferredMajority = majorityActivated && !majorityPreferred;

        const typeScore =
          (RecommendCfg.typePrefWeight * prefDelta) +
          (activatedPreferred   ? RecommendCfg.typeActivateBonus       : 0) +
          (majorityPreferred    ? RecommendCfg.typeMajorityBonus       : 0) +
          (nonPreferredMajority ? -RecommendCfg.typeNonPreferredPenalty: 0);

        const statsSum   = state.stats + sumStats(p);
        const statsScore = statsSum / ((state.pick.length + 1) * 2000);

        const score = (RecommendCfg.wSynergy*synDelta)
                    + (RecommendCfg.wAnchor*ancGain)
                    + typeScore
                    + (RecommendCfg.wStats*statsScore);

        next.push({
          pick:[...state.pick, {slot, p}],
          names:new Set([...state.names, p.nome]),
          base:new Set([...state.base, b]),
          score, stats: statsSum
        });
      }
    }
    next.sort((a,b)=> b.score - a.score);
    beam = next.slice(0, RecommendCfg.beamWidth);
  });

  if (!beam.length || !beam[0].pick?.length) return;

  // 6) Aplicar nos slots vazios
  beam[0].pick.forEach(({slot, p})=>{
    const keepRole = slotRole(slot)==='L' ? 'L' : (slot.dataset.role || slot.getAttribute('data-role'));
    setCharacter(slot, p, keepRole);
  });

  if (typeof updateSynergies === 'function') updateSynergies();
}



// ======================= Multi Teams =========================

// Coleta estado atual do grid (titulares + banco + itens)
function collectTeamState(name){
  const state = { name: name || `Time ${currentTeamIndex+1}`, starters:{}, bench:{}, equip:{} };

  // titulares
  document.querySelectorAll('.hex').forEach(slot=>{
    const id   = getSlotId(slot);
    const nome = slot.dataset?.nome || null;
    if (nome) state.starters[id] = nome;
    const eq = equipState.get(id);
    if (eq) state.equip[id] = JSON.parse(JSON.stringify(eq));
  });

  // banco
  document.querySelectorAll('.bench-slot').forEach(slot=>{
    const id   = getSlotId(slot);
    const nome = slot.dataset?.nome || null;
    if (nome) state.bench[id] = nome;
    const eq = equipState.get(id);
    if (eq) state.equip[id] = JSON.parse(JSON.stringify(eq));
  });

  return state;
}

// Cria um estado vazio (novo time)
function makeEmptyTeamState(name){
  return { name: name || `Time ${teams.length+1}`, starters:{}, bench:{}, equip:{} };
}

// Limpa completamente o grid atual (remove personagens e itens)
function clearWholeGrid(){
  document.querySelectorAll('.hex,.bench-slot').forEach(slot=>{
    if (slot.dataset?.nome) removeCharacter(slot);
    const id = getSlotId(slot);
    equipState.delete(id);
  });
}

// Aplica um estado ao grid
function applyTeamState(state){
  clearWholeGrid();

  // titulares
  Object.entries(state.starters || {}).forEach(([slotId, nome])=>{
    const slot = document.querySelector(`[data-slot-id="${slotId}"]`) || document.getElementById(slotId);
    if (!slot) return;
    const role = slot.classList.contains('bench-slot') ? 'bench' : (slot.dataset.role || slot.getAttribute('data-role'));
    const p = characters.find(c => c.nome === nome);
    if (p) setCharacter(slot, p, role);
  });

  // banco
  Object.entries(state.bench || {}).forEach(([slotId, nome])=>{
    const slot = document.querySelector(`[data-slot-id="${slotId}"]`) || document.getElementById(slotId);
    if (!slot) return;
    const role = 'bench';
    const p = characters.find(c => c.nome === nome);
    if (p) setCharacter(slot, p, role);
  });

  // itens
  Object.entries(state.equip || {}).forEach(([slotId, obj])=>{
    equipState.set(slotId, JSON.parse(JSON.stringify(obj)));
  });

  // atualiza UI dependente
  if (typeof updateSynergies === 'function') updateSynergies();
  if (typeof refreshAllGears  === 'function') refreshAllGears();
}

// Salva o time atual no array
function saveCurrentTeam(){
  if (!teams.length) return;
  const oldName = teams[currentTeamIndex]?.name || `Time ${currentTeamIndex+1}`;
  teams[currentTeamIndex] = collectTeamState(oldName);
}

// Renderiza as abas
function renderTeamTabs(){
  const tabs = document.getElementById('teamTabs');
  if (!tabs) return;
  tabs.innerHTML = '';

  teams.forEach((t, i)=>{
    const b = document.createElement('button');
    b.className = 'team-tab' + (i===currentTeamIndex ? ' active' : '');
    b.textContent = t.name;
    b.title = `Selecionar ${t.name}`;

    // evita troca enquanto estiver editando
    b.addEventListener('click', ()=>{
      if (b.classList.contains('editing')) return;
      if (i === currentTeamIndex) return;
      saveCurrentTeam();
      currentTeamIndex = i;
      applyTeamState(teams[i]);
      renderTeamTabs();
    });

    // === Renomear no dblclick ===
    b.addEventListener('dblclick', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      if (b.classList.contains('editing')) return;

      b.classList.add('editing');
      const oldName = teams[i].name;
      b.textContent = ''; // limpar para inserir input

      const input = document.createElement('input');
      input.className = 'team-tab-edit';
      input.type = 'text';
      input.value = oldName;
      input.setAttribute('maxlength', 40);
      b.appendChild(input);
      input.focus();
      input.select();

      const commit = ()=>{
        const val = (input.value || '').trim();
        teams[i].name = val || oldName; // se vazio, mantém
        b.classList.remove('editing');
        renderTeamTabs();
      };
      const cancel = ()=>{
        b.classList.remove('editing');
        renderTeamTabs();
      };

      input.addEventListener('keydown', (ev)=>{
        if (ev.key === 'Enter') commit();
        else if (ev.key === 'Escape') cancel();
      });
      input.addEventListener('blur', commit);
    });

    tabs.appendChild(b);
  });
}

// Inicializa a barra de times
function initMultiTeams(){
  const addBtn = document.getElementById('addTeamBtn');

  if (teams.length === 0){
    teams.push(collectTeamState('Team 1'));
    currentTeamIndex = 0;
  }
  renderTeamTabs();

  // evita ligar o clique mais de uma vez
  if (addBtn && !addBtn.__mtBound){
    addBtn.__mtBound = true;
    addBtn.addEventListener('click', ()=>{
      if (__mtAdding) return;          // trava se já estiver rodando
      __mtAdding = true;
      try {
        saveCurrentTeam();
        const newIdx = teams.length + 1;
        const empty = makeEmptyTeamState(`Team ${newIdx}`);
        teams.push(empty);
        currentTeamIndex = teams.length - 1;
        applyTeamState(empty);
        renderTeamTabs();
      } finally {
        // solta o lock no próximo ciclo do event loop
        setTimeout(()=>{ __mtAdding = false; }, 0);
      }
    });
  }

  // opcional: salvar automaticamente após qualquer mudança
  // se você já usa hooks globais, podemos plugar aqui:
  const oldAfterAssign = window.afterAssignCharacter;
  window.afterAssignCharacter = function(el, nome){
    if (typeof oldAfterAssign === 'function') oldAfterAssign(el, nome);
    saveCurrentTeam();
  };
  const oldAfterRemove = window.afterRemoveCharacter;
  window.afterRemoveCharacter = function(el){
    if (typeof oldAfterRemove === 'function') oldAfterRemove(el);
    saveCurrentTeam();
  };
}

</script>


<!-- ===================== PLANEJADOR DE RECURSOS (PÁGINA NOVA) ===================== -->
<style>
  /* Páginas alternáveis */
  .page { display: none; }
  .page.active { display: block; }
  /* Quando a classe show-planner está no <body>, mostramos o planner em overlay e ocultamos overflow */
  body.show-planner { overflow: hidden; }
  body.show-planner .hide-when-planner { display: none !important; }
  body.show-planner #pagePlanner { display: block; position: fixed; inset: 0; z-index: 9999; background:#111; overflow:auto; }

  /* Barra do botão Planejador acima de Save & Load */
  #plannerTopBar {
    display:flex; gap:10px; align-items:center; justify-content:center;
    margin: 14px 0 0;
  }
  #openPlannerBtn {
    background:#ffd54f; color:#222; border:0; font-weight:800;
    padding:10px 14px; border-radius:10px; cursor:pointer;
    box-shadow:0 3px 0 rgba(0,0,0,.25);
  }
  #openPlannerBtn:hover{ transform: translateY(-1px); }

  /* Layout do Planejador */
  #pagePlanner { padding: 18px; }
  .planner-wrap{
    max-width: 1180px; margin: 0 auto;
    display:grid; grid-template-columns: 1.1fr .9fr;
    gap: 20px;
    background:#2a2a2a; border:1px solid #3a3a3a; border-radius:14px; padding:16px;
  }
  @media (max-width: 980px){
    .planner-wrap{ grid-template-columns: 1fr; }
  }

  .panel {
    background:#242424; border:1px solid #3a3a3a; border-radius:12px; padding:12px;
  }
  .panel h3{ margin: 0 0 10px; }
  .panel .sub{ opacity:.8; font-size:.9rem; margin-top:-6px; }

  /* tabelas editáveis */
  .grid-table{ width:100%; border-collapse: collapse; }
  .grid-table th, .grid-table td{
    border-bottom: 1px solid #3a3a3a; padding:6px 8px; text-align:left;
  }
  .grid-table th{ background:#1f1f1f; position:sticky; top:0; z-index:1; }
  .grid-table input[type="number"], .grid-table input[type="text"], .grid-table select{
    width:100%; background:#1d1d1d; color:#fff; border:1px solid #555; border-radius:8px;
    padding:6px 8px; box-sizing:border-box;
  }
  .grid-table input[type="checkbox"]{ transform: scale(1.2); }

  .row-actions{ display:flex; gap:6px; }
  .btn { background:#333; color:#fff; border:1px solid #666; border-radius:8px; padding:8px 10px; cursor:pointer; }
  .btn.del{ background:#a33; border-color:#d66; }
  .btn.add{ background:#2f6; color:#000; font-weight:800; }
  .btn.primary{ background:#40f06a; color:#000; font-weight:800; }
  .btn.light{ background:#111; border-color:#444; }

  .flex { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .right { text-align:right; }

  /* Resumo */
  .summary{ display:grid; grid-template-columns: repeat(4,1fr); gap:10px; margin-top:10px; }
  .metric{
    background:#1e1e1e; border:1px solid #3a3a3a; border-radius:10px; padding:10px;
    text-align:center;
  }
  .metric b{ display:block; font-size:1.1rem; }

  /* Tabela de Simulação por Banner */
  #simTable{ width:100%; border-collapse: collapse; margin-top:10px; }
  #simTable th, #simTable td{ border-bottom:1px solid #3a3a3a; padding:8px; text-align:right; }
  #simTable th{ text-align:center; background:#1f1f1f; }
  #simTable td:first-child, #simTable th:first-child{ text-align:left; }
  /* === Planner em tela cheia === */
#pagePlanner{
  position: fixed;      /* vira um overlay */
  inset: 0;             /* top/right/bottom/left = 0 */
  width: 100vw;
  height: 100vh;
  margin: 0;
  padding: 16px clamp(12px,2vw,24px) 24px;
  background: #121212;  /* usar a cor do seu tema, se tiver variável */
  z-index: 999;         /* acima do restante da UI */
  overflow: auto;       /* rolagem interna */
}

/* evita “caixa” estreita por max-width herdado */
#pagePlanner .container,
#pagePlanner .planner-box,
#pagePlanner .planner-wrap,
#pagePlanner .planner-grid{
  max-width: none !important;
  width: 100% !important;
}

/* mantém cabeçalho/toolbar visível enquanto rola o planner */
#pagePlanner .planner-header{
  position: sticky;
  top: 0;
  z-index: 1;
  background: inherit;
  padding-bottom: 8px;
}

/* quando o planner está aberto, trava o scroll do body atrás */
body.planner-open{ overflow: hidden; }
#simInputs small.muted{opacity:.9}
#simTable tfoot{ display:none; }
#simTable .neg{ color:#ff5c5c; font-weight:700; }
/* Caixa numérica padrão do planner (usar em Saldo Inicial, Tickets e Memórias) */
.planner-input{
  width: 140px;      /* ajuste conforme seu layout */
  padding: 6px 10px;
  background:#111;
  color:#fff;
  border:1px solid #444;
  border-radius:8px;
  outline:none;
}
.planner-input:focus{ border-color:#777; }
.sim-extras{
  border-top:1px solid #333;
  padding-top:8px;
  font-weight:600;
  display:flex;
  flex-wrap:wrap;
  gap:10px 16px;
}
.sim-extras .pill{
  background:#1d1d1d;
  border:1px solid #444;
  border-radius:999px;
  padding:4px 10px;
}
/* ===== Planner: 2 colunas mais equilibradas ===== */


/* Simulação (direita) garante que não estoure a largura */
#pagePlanner .planner-sim{
  width: 100%;
  box-sizing: border-box;
}

/* Evita qualquer overflow horizontal do planner */
#pagePlanner{ overflow-x: hidden; }

/* ===== Cartões de banner mais enxutos ===== */
/* usar uma “variável” pra controlar o tamanho dos cards */
:root{ --card-w: 200px; }          /* antes: 320px */
.banner-card,
.rebanner-card{
  width: var(--card-w);
  flex: 0 0 var(--card-w);         /* não estica */
  margin: 0 auto;
}
.month-row > div{ min-width: 0; }  /* impede que colunas internas forcem largura */

/* Em telas um pouco menores, encolhe mais um pouco os cards */
@media (max-width: 1700px){
  :root{ --card-w: 280px; }
}

/* === 50% | 50%: Banners (esq) e Simulação (dir) === */
#pagePlanner .planner-right-grid,
#pagePlanner .planner-two-col{
  display: grid;
  grid-template-columns: 1fr 1fr;   /* META: meio a meio */
  gap: 12px;
  align-items: start;
}

/* Simulação fixa visível e scrollável dentro da metade direita (opcional) */
#simPane{
  position: sticky;
  top: 12px;
  max-height: calc(100vh - 120px);
  overflow: auto;
}

/* Em telas menores, caia para 1 coluna para não esmagar conteúdo */
@media (max-width: 1200px){
  #pagePlanner .planner-right-grid,
  #pagePlanner .planner-two-col{
    grid-template-columns: 1fr;
  }
}
/* Gutter (recuo) à direita da aba Simulação */
:root{
  --sim-gutter: clamp(8px, 1vw, 16px); /* ajuste aqui se quiser mais/menos */
}

#simPane{
  padding-right: calc(var(--sim-gutter) + env(safe-area-inset-right, 0px));
  box-sizing: border-box;   /* evita “estourar” a metade direita */
  /* já deve existir overflow:auto; mantenha */
}
/* ---------- Desktop (já existente): duas colunas ---------- */
/* (mantenha como estiver hoje; não precisa mexer) */


/* ---------- Mobile: <= 980px ---------- */
@media (max-width: 980px){

  /* A grade vira 1 coluna, e controlamos a ordem com áreas */
  #pagePlanner .planner-right-grid{
    display: grid;
    grid-template-columns: 1fr;
    grid-template-areas:
      "sim"
      "banners";
    row-gap: 14px;
  }

  /* Nomear as áreas */
  #bannersPane{ grid-area: banners; }
  #simPane{ grid-area: sim; }

  /* A Simulação NÃO deve ser sticky no mobile: mostra tudo */
  #simPane{
    position: static;
    max-height: none;
    overflow: visible;
    padding-right: var(--sim-gutter, 12px); /* mantém o leve recuo que fizemos */
    box-sizing: border-box;
  }

  /* Cards de banner ocupam 100% da linha para caber bem */
  .month-row{
    grid-template-columns: 1fr;   /* 1 por linha */
    gap: 12px;
  }
  .banner-card,
  .rebanner-card{
    width: 100%;
    max-width: 100%;
  }

  /* Inputs da Simulação não estourarem largura */
  #simPane #simInputs label{ display:flex; align-items:center; gap:10px; }
  #simPane #simInputs input{ max-width: 240px; }
}
/* 3) (Opcional) CSS leve para os painéis – mantém aparência limpa */
.rank-panel {
  background: var(--panel-bg, #1f1f1f);
  border-radius: 10px;
  padding: .75rem;
  box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset;
}
.ranking-panels .top-title { /* caso seu render já crie títulos */
  margin: 0 0 .5rem;
}
.btn-row .menu-btn { /* herda o estilo dos outros botões; ajuste se precisar */
  flex: 1 0 auto;
}
/* ==== Ranking list (igual ao EN) ==== */
.mini-line{ display:inline-flex; gap:4px; vertical-align:middle; margin-right:6px; }  /* EN */
.mini-char{ width:24px; height:32px; object-fit:cover; border-radius:4px; box-shadow:0 0 0 1px #444; }  /* EN */
.top-row-li{ display:flex; align-items:center; gap:6px; justify-content:center; }  /* EN */
.btn-more{ background:#2a2a2a; color:#ddd; border:1px solid #555; border-radius:8px; padding:2px 8px; cursor:pointer; }  /* EN */
.btn-imp,.btn-cmt{ margin-left:4px; }  /* EN */

/* ==== Abas do ranking (3 colunas, ocupando a largura toda) ==== */
.rank-tabs{ display:grid; grid-template-columns:repeat(3,1fr); gap:10px; margin:8px 0 12px; }
.rank-tabs .menu-btn{ display:block; width:100%; }

/* ==== Ranking de personagens centralizado ==== */
#panelRankChar .top-list{ width:fit-content; margin:0 auto; }           /* centraliza o bloco todo */
.char-row{ display:flex; align-items:center; justify-content:space-between; gap:.5rem; min-width:360px; }
.char-row .mini-line{ display:flex; align-items:center; gap:.5rem; }
.char-row small{ width:56px; text-align:center; }                        /* número centralizado */


</style>
<!-- 2) NOVA PÁGINA: Seção de Ranking (mantém o padrão das outras páginas, ex.: .page) -->
<section id="pageRanking" class="page">

  <h2 class="page-title">Ranking</h2>

  <!-- Descrição (placeholder): você edita depois -->
  <p class="muted" id="rankingRules">Ranking gathers all info when a team has all court positions filled</p>

  <!-- Barra de filtros (3 botões) no MESMO estilo dos botões do menu -->
  <div id="rankingPanels">
  <div class="rank-tabs">
    <button id="btnRank7d"  class="menu-btn">Ranking (7d)</button>
    <button id="btnRankAll" class="menu-btn">Ranking (All)</button>
    <button id="btnRankChar" class="menu-btn">Ranking Characters</button>
  </div>

  <section id="panelRank7d"></section>
  <section id="panelRankAll" hidden></section>
  <section id="panelRankChar" hidden></section>
</div>
</section>

<!-- ===================== PLANEJADOR DE RECURSOS (NOVA PÁGINA) ===================== -->
<section id="pagePlanner" class="page"
  style="display:none; text-align:left; position:fixed; inset:0; width:100vw; height:100vh; margin:0; padding:16px 20px; background:#121212; overflow:auto; z-index:999;">

  <!-- Cabeçalho -->
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
    <h3 style="margin:0;">Banners</h3>
    <button id="btnVoltarBuilder" class="btn" type="button"
      style="background:#444;border:1px solid #777;color:#fff;border-radius:8px;padding:6px 10px;cursor:pointer">
      ← Voltar ao Builder
    </button>
  </div>

  <!-- Duas colunas principais: Fontes (esq) | Painel de Banners+Simulação (dir) -->
  <div class="planner-wrap" style="display:grid; grid-template-columns: 420px 1fr; gap:16px; align-items:start;">

    <!-- Coluna ESQUERDA: Fontes de diamantes -->
    <div class="panel sources" style="background:#2a2a2a;border:1px solid #444;border-radius:10px;padding:10px;">
      <h3 style="display:flex;align-items:center;justify-content:space-between;margin:0 0 8px;">
        Fontes de Diamantes (editáveis)
        <button id="toggleSources" class="btn mini" type="button"
          style="background:#555;border:1px solid #777;color:#fff;border-radius:8px;padding:4px 8px;cursor:pointer">
          Minimizar
        </button>
      </h3>

      <!-- FREE -->
      <div style="font-weight:700;opacity:.9;margin-top:6px;">Fontes FREE</div>
      <table id="tblFree" class="grid-table" style="width:100%;border-collapse:separate;border-spacing:6px 6px;">
        <thead>
          <tr><th>usar</th><th class="col-System">System</th><th>Quantity</th><th>Frequency</th><th></th></tr>
        </thead>
        <tbody></tbody>
      </table>
      <button id="addFree" class="btn" type="button"
        style="background:#3a6bd4;color:#fff;border:0;border-radius:8px;padding:6px 10px;cursor:pointer">+ Fonte FREE</button>

      <!-- CASH -->
      <div style="font-weight:700;opacity:.9;margin-top:14px;">Fontes CASH</div>
      <table id="tblCash" class="grid-table" style="width:100%;border-collapse:separate;border-spacing:6px 6px;">
        <thead>
          <tr><th>usar</th><th class="col-System">System</th><th>Quantity</th><th>Frequency</th><th></th></tr>
        </thead>
        <tbody></tbody>
      </table>
      <button id="addCash" class="btn" type="button"
        style="background:#3a6bd4;color:#fff;border:0;border-radius:8px;padding:6px 10px;cursor:pointer">+ Fonte CASH</button>

      <!-- (qualquer outro bloco/observação que você já tinha pode ficar aqui) -->
    </div>

    <!-- Coluna DIREITA: Controles + Banners (esq) | Simulação (dir) -->
    <div class="panel" style="background:#2a2a2a;border:1px solid #444;border-radius:10px;padding:10px;">

      <!-- Controles do plano -->

        <label> Plan name:
          <input id="nomePlano" type="text"
            style="background:#1d1d1d;color:#fff;border:1px solid #555;border-radius:8px;padding:4px 6px;min-width:220px;">
        </label>

        <select id="slotsPlanos"
          style="background:#1d1d1d;color:#fff;border:1px solid #555;border-radius:8px;padding:6px;">
          <option value="">(select a saved plan)</option>
        </select>

        <button id="btnSalvarPlano" class="btn"
          style="background:#3a6bd4;color:#fff;border:0;border-radius:8px;padding:6px 10px;">Save</button>
        <button id="btnNovoPlano" class="btn"
          style="background:#555;color:#fff;border:0;border-radius:8px;padding:6px 10px;">New</button>
        <button id="btnExcluirPlano" class="btn"
          style="background:#b63a3a;color:#fff;border:0;border-radius:8px;padding:6px 10px;">Delete</button>
      </div>

      <!-- Grid interno: Banners (esquerda) + Simulação (direita/sticky) -->
      <div class="planner-right-grid">

        <!-- BANNERS POR MÊS (ESQUERDA) -->
        <section id="bannersPane">
          <h4 style="margin:12px 0 6px;text-align:center;">Banner Order</h4>
<!-- NOVO: alternador de servidor -->
<div id="serverSwitch" class="server-switch">
  <button id="serverJPBtn" class="server-btn active" type="button">JP</button>
  <button id="serverCNBtn" class="server-btn" type="button">CN</button>
</div>

<!-- já existente -->
<div id="bannersCards"></div>
        </section>

        <!-- SIMULAÇÃO (DIREITA, STICKY) -->
        <aside id="simPane" style="position:sticky; top:12px; max-height:calc(100vh - 120px); overflow:auto;">
          <h4 style="margin:12px 0 6px;text-align:center;">Simulation</h4>
          <!-- Inputs iniciais (agora dentro da Simulação) -->
<div id="simInputs" style="display:flex; flex-direction:column; gap:8px; margin-bottom:10px;">

  <label style="display:flex; gap:8px; align-items:center;">
    <label>Initial Balance (cristals):
  <input id="saldoInicial" type="number" class="planner-input" inputmode="numeric">
</label>

  <label style="display:flex; gap:8px; align-items:center;">
  <label>Initial Date:
  <input id="planStartDate" type="date" class="planner-input">
  <button id="startTodayBtn" class="btn mini" type="button">Today</button>
</label>

  <div style="display:flex; gap:8px;">
    <button id="openSourcesBtn" class="bond-btn" type="button">+ Critals Resources</button>
  </div>
  
</div>
          <table id="simTable" style="width:100%;border-collapse:separate;border-spacing:6px 6px;">
            <thead>
              <tr>
                <th>Month</th>
                
                <th>Gains (FREE+CASH)</th>
                <th>Pure Cost</th>
                <th>Cashback</th>
                <th>Liquid Cost</th>
                <th>Initial Balance</th>
                <th>Final Balance</th>
              </tr>
            </thead>
            <tbody></tbody>
            <tfoot>
              <tr style="font-weight:800;">
                <td>Total</td>
                <td></td>
                <td class="right" id="tgains">0</td>
                <td class="right" id="tGastoBruto">0</td>
                <td class="right" id="tCashback">0</td>
                <td class="right" id="tLiquido">0</td>
                <td></td>
                <td class="right" id="tSaldoFinal">0</td>
              </tr>
            </tfoot>
          </table>
          <div id="simExtras" class="sim-extras"></div>
        </aside>

      </div><!-- /planner-right-grid -->
    </div><!-- /panel direita -->
  </div><!-- /planner-wrap -->


  <!-- Modal de Recursos (FREE/CASH) -->
<div id="sourcesModal" class="modal-overlay" aria-hidden="true">
  <div class="modal-backdrop" data-close="1"></div>
  <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="sourcesTitle">
    <div class="modal-header">
      <h3 id="sourcesTitle">Recursos de cristais</h3>
      <button id="closeSourcesBtn" class="bond-btn">Fechar</button>
    </div>
    <div id="sourcesModalBody" class="modal-body">
      <!-- o painel .panel.sources será movido pra cá ao abrir -->
    </div>
  </div>
</div>

</section>

<!-- =================== FIM DO PLANEJADOR =================== -->


<script>
  
(function(){
  // ===== Configurações =====
  const MONTHS = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const FREQS  = ['Daily','Weekly','Biweekly','Monthly'];
  const TYPE_ORDER = { 'Banner 1': 0, 'Rebanner': 1, 'Banner 2': 2 };
  const COLLAPSE_KEY = 'hqPlannerSourcesCollapsed';
  const PLANS_KEY = 'hqPlannerPlansV1';
  const DRAFT_KEY = 'hqPlannerDraftV1';

  // ===== Defaults de fontes =====
  const DEFAULT_FREE = [
    {usar:true, nome:'Training Program', qtd:75,  freq:'Daily'},
    {usar:true, nome:'Daily Missions',            qtd:60,  freq:'Daily'},
    {usar:true, nome:'Weekly Missions',           qtd:100, freq:'Weekly'},
    {usar:true, nome:'Peak Challenge',           qtd:15,  freq:'Daily'},
    {usar:true, nome:'Peak Challeng Ranking',   qtd:20,  freq:'Daily'},
    {usar:true, nome:'Casual Games',            qtd:150, freq:'Weekly'},
    {usar:true, nome:'Quiz',                     qtd:10,  freq:'Daily'},
    {usar:true, nome:'Exercises',               qtd:10,  freq:'Daily'},
    {usar:true, nome:'Weekend Bonus',      qtd:120, freq:'Weekly'},
    {usar:true, nome:'Match Streak',    qtd:640, freq:'Biweekly'},
    {usar:true, nome:'Specialty Trial',   qtd:320, freq:'Weekly'},
    {usar:true, nome:'Store banner 1 e 2',   qtd:2500, freq:'Monthly'},
    {usar:true, nome:'Checkin banner 1 e 2',   qtd:1500, freq:'Monthly'},
  ];

  const DEFAULT_CASH = [
    {usar:true, nome:'Monthly Pass',           porDia:90,  dias:30},
    {usar:true, nome:'Monthly Pass Premium',   porDia:100, dias:30},
    {usar:true, nome:'Daily Conversion 80',    porDia:80,  dias:30},
    {usar:true, nome:'Daily Conversion 60',    porDia:60,  dias:14},
  ];

  // ===== Cronograma da planilha (por mês) =====
  const BANNER_SHEET = {
    'August':   { b1:'Ushijima UR',      rebs:[],                           b2:'Kuroo UR' },
    'September': { b1:'Oikawa UR',        rebs:[],                           b2:'Bokuto UR' },
    'October':  { b1:'Miya Atsumu UR',   rebs:[],                           b2:'Miya Osamu UR' },
    'November': { b1:'Hoshiumi UR',         rebs:['Oikawa UR'],                b2:'Hirugami UR' },
    'December': { b1:'Kageyama UR',      rebs:['Bokuto UR','Hoshiumi UR'],     b2:'Hinata SP' },
    'January':  { b1:'Kenma SP',         rebs:['Hirugami UR'],              b2:'Nishinoya SP' },
    'February':{ b1:'Sugawara SP',      rebs:['Kuro UR'],                 b2:'Bokuto SP' },
    'March':    { b1:'Akaashi SP',       rebs:['Kageyama UR'],   b2:'Aone SP' },
    'April':    { b1:'Sakusa UR',    rebs:['Osamu UR'],                 b2:'Komori UR' },
    'May':     { b1:'Tsuki SP',         rebs:[],                           b2:'Kuro SP' },
    'June':    { b1:'Kunimi SP',        rebs:[],                           b2:'Koganegawa SP' },
  };

  // ===== Estado =====
  let planner = {
    saldoInicial: 0,
    nomePlano: '',
    free: JSON.parse(JSON.stringify(DEFAULT_FREE)),
    cash: JSON.parse(JSON.stringify(DEFAULT_CASH)),
    banners: []
  };

  // ===== Helpers =====
  const $ = (s, el=document)=>el.querySelector(s);
  const $$ = (s, el=document)=>Array.from(el.querySelectorAll(s));
  const fmt = n => (Math.round((+n||0))).toLocaleString('pt-BR');

  // liga a data de início ao render dos banners e à simulação
(function bindPlanStartDate(){
  const dateEl = document.getElementById('planStartDate');
  const btnToday = document.getElementById('startTodayBtn');
  if(!dateEl) return;

  // quando mudar a data, re-renderiza e recalcula
  const onChange = ()=>{
    if (typeof renderBanners === 'function') renderBanners();
    if (typeof recalc === 'function') recalc();
  };
  dateEl.addEventListener('change', onChange);

  // botão "Hoje"
  if(btnToday){
    btnToday.addEventListener('click', ()=>{
      const now = new Date();
      dateEl.value = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
      onChange();
    });
  }

  // define um valor padrão (hoje) se estiver vazio ao abrir
  if(!dateEl.value){
    const now = new Date();
    dateEl.value = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
  }
})();


  function setCollapsed(on){
    document.body.classList.toggle('planner-collapsed', !!on);
    const btn = document.getElementById('toggleSources');
    if(btn) btn.textContent = on ? 'Maximizar' : 'Minimizar';
    try{ localStorage.setItem(COLLAPSE_KEY, on?'1':'0'); }catch(e){}
  }

  function sortBannersFixed(){
  const monthsSeq = Object.keys(BANNER_SHEET);
  planner.banners.sort((a,b)=>{
    const am = monthsSeq.indexOf(a.mes);
    const bm = monthsSeq.indexOf(b.mes);
    if (am !== bm) return am - bm;                    // ordem da planilha
    return (TYPE_ORDER[a.tipo] ?? 99) - (TYPE_ORDER[b.tipo] ?? 99); // dentro do mês
  });
}


  // Geração de caminho de imagem a partir do nome
  function nameToImgCandidates(nome){
    if(!nome) return [];
    const rar = (nome.match(/\b(UR|SP)\b/i)||[])[1];
    if(!rar) return [];
    const rarity = rar.toUpperCase();
    const base = nome.replace(/\b(UR|SP)\b/i,'').trim()
      .normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    const parts = base.split(/\s+/).filter(Boolean);
    if(!parts.length) return [];
    const lower = s => s.toLowerCase();
    const camel = parts.map((p,i)=> i===0 ? p.toLowerCase() : (p[0]||'').toUpperCase()+p.slice(1).toLowerCase()).join('');
    const last = lower(parts[parts.length-1]);
    const fullCamel = camel;
    return [
      `img/${last}${rarity}.png`,
      `img/${fullCamel}${rarity}.png`,
      `img/${last}${rarity}.webp`,
      `img/${fullCamel}${rarity}.webp`
    ];
  }
  function getBannerImage(b){
    if(b.img && b.img.trim()) return b.img;
    const list = nameToImgCandidates(b.nome);
    return list[0] || '';
  }

  // Cashback milestones
  function cashbackMilestones(totalPulls){
    let back150 = 0, back100 = 0;
    const extras = { ssrBox:0, milk:0, copy:0 };
    if(totalPulls >= 10)  back150 += 2;
    if(totalPulls >= 20)  back100 += 5;
    if(totalPulls >= 50)  back150 += 5;
    if(totalPulls >= 80)  back100 += 5;
    if(totalPulls >= 120) extras.ssrBox += 1;
    if(totalPulls >= 160) extras.milk   += 5;
    if(totalPulls >= 200) extras.copy   += 1;
    if(totalPulls >= 220) extras.milk   += 5;
    if(totalPulls >= 350) extras.milk   += 10;
    const cashbackDiamonds = back150*150 + back100*100;
    return { back150, back100, cashbackDiamonds, extras };
  }

  // Seed banners from sheet
  function uid(){ return 'b' + Math.random().toString(36).slice(2,9); }
  function seedBannersFromSheet(){
  planner.banners = [];
  // Ordem = a ordem de inserção em BANNER_SHEET
  for (const mes of Object.keys(BANNER_SHEET)) {
    const row = BANNER_SHEET[mes]; if(!row) continue;

    if (row.b1){
      const img = getBannerImage({nome: row.b1});
      planner.banners.push({ id: uid(), mes, tipo:'Banner 1', nome: row.b1, img, dias:14, t150:0, m100:0, cashback:0 });
    }
    if (Array.isArray(row.rebs)){
      row.rebs.forEach(nome=>{
        const img = getBannerImage({nome});
        planner.banners.push({ id: uid(), mes, tipo:'Rebanner', nome, img, dias:14, t150:0, m100:0, cashback:0 });
      });
    }
    if (row.b2){
      const img = getBannerImage({nome: row.b2});
      planner.banners.push({ id: uid(), mes, tipo:'Banner 2', nome: row.b2, img, dias:14, t150:0, m100:0, cashback:0 });
    }
  }
}


  // ===== Renderers =====
  function renderFree(){
    const tb = $('#tblFree tbody'); if(!tb) return;
    tb.innerHTML = '';
    planner.free.forEach((row, idx)=>{
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><input type="checkbox" data-k="usar" ${row.usar?'checked':''}></td>
        <td class="col-System"><input type="text" data-k="nome" value="${row.nome}" title="${row.nome}"></td>
        <td><input type="number" data-k="qtd" min="0" step="1" value="${row.qtd}"></td>
        <td><select data-k="freq">${FREQS.map(f=>`<option ${f===row.freq?'selected':''}>${f}</option>`).join('')}</select></td>
        <td class="row-actions">
          <button class="btn light up">↑</button>
          <button class="btn light down">↓</button>
          <button class="btn del rm">🗑</button>
        </td>
      `;
      const onEdit = (e)=>{
        const k = e.target.getAttribute('data-k'); if(!k) return;
        if(k==='usar'){ planner.free[idx][k] = e.target.checked; }
        else if(k==='nome' || k==='freq'){ planner.free[idx][k] = e.target.value; if(k==='nome') e.target.title = e.target.value; }
        else { planner.free[idx][k] = +e.target.value || 0; }
        recalc();
      };
      tr.addEventListener('input', onEdit); tr.addEventListener('change', onEdit);
      tr.querySelector('.rm').onclick   = ()=>{ planner.free.splice(idx,1); renderFree(); recalc(); };
      tr.querySelector('.up').onclick   = ()=>{ if(idx>0){ const t=planner.free[idx-1]; planner.free[idx-1]=planner.free[idx]; planner.free[idx]=t; renderFree(); recalc(); } };
      tr.querySelector('.down').onclick = ()=>{ if(idx<planner.free.length-1){ const t=planner.free[idx+1]; planner.free[idx+1]=planner.free[idx]; planner.free[idx]=t; renderFree(); recalc(); } };
      tb.appendChild(tr);
    });
  }

  function renderCash(){
    const tb = $('#tblCash tbody'); if(!tb) return;
    tb.innerHTML = '';
    planner.cash.forEach((row, idx)=>{
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><input type="checkbox" data-k="usar" ${row.usar?'checked':''}></td>
        <td class="col-System"><input type="text" data-k="nome" value="${row.nome}" title="${row.nome}"></td>
        <td><input type="number" data-k="porDia" min="0" step="1" value="${row.porDia}"></td>
        <td><input type="number" data-k="dias" min="0" step="1" value="${row.dias}"></td>
        <td class="row-actions">
          <button class="btn light up">↑</button>
          <button class="btn light down">↓</button>
          <button class="btn del rm">🗑</button>
        </td>
      `;
      const onEdit = (e)=>{
        const k = e.target.getAttribute('data-k'); if(!k) return;
        if(k==='usar'){ planner.cash[idx][k] = e.target.checked; }
        else if(k==='nome'){ planner.cash[idx][k] = e.target.value; e.target.title = e.target.value; }
        else { planner.cash[idx][k] = +e.target.value || 0; }
        recalc();
      };
      tr.addEventListener('input', onEdit); tr.addEventListener('change', onEdit);
      tr.querySelector('.rm').onclick   = ()=>{ planner.cash.splice(idx,1); renderCash(); recalc(); };
      tr.querySelector('.up').onclick   = ()=>{ if(idx>0){ const t=planner.cash[idx-1]; planner.cash[idx-1]=planner.cash[idx]; planner.cash[idx]=t; renderCash(); recalc(); } };
      tr.querySelector('.down').onclick = ()=>{ if(idx<planner.cash.length-1){ const t=planner.cash[idx+1]; planner.cash[idx+1]=planner.cash[idx]; planner.cash[idx]=t; renderCash(); recalc(); } };
      tb.appendChild(tr);
    });
  }
  
  function renderBanners(){
  // === helpers para normalizar mês (sem acento / minúsculo) e obter índice 1..12 ===
  const rmAccents = (s)=> String(s||'').normalize('NFD').replace(/[\u0300-\u036f]/g,'');
  const MONTH_INDEX = {
  // pt-BR
  "janeiro":1,"fevereiro":2,"marco":3,"março":3,"abril":4,"maio":5,"junho":6,
  "julho":7,"agosto":8,"setembro":9,"outubro":10,"novembro":11,"dezembro":12,
  // en
  "january":1,"february":2,"march":3,"april":4,"may":5,"june":6,
  "july":7,"august":8,"september":9,"october":10,"november":11,"december":12
};
const norm = s => String(s||'')
  .normalize('NFD').replace(/[\u0300-\u036f]/g,'') // remove acento
  .trim().toLowerCase();
  // ————— util para data de início e rotação de meses —————
function getPlanStartMonth(){
  const el = document.getElementById('planStartDate');
  if(!el || !el.value) return 8; // padrão August (ou ajuste)
  const dt = new Date(el.value + 'T00:00:00');
  const m = dt.getMonth()+1;
  return (m>=1 && m<=12) ? m : 8;
}
  // 1) setup padrão (mantido)
  
  const wrap = document.getElementById('bannersCards'); if(!wrap) return;
  wrap.innerHTML='';

  // 2) agrupar banners por mês (mantido)
  const byMonth={};
  (planner.banners||[]).forEach(b=>{
    if(!b||!b.mes) return;
    (byMonth[b.mes] ||= []).push(b);
  });

  // 3) determinar mês de início a partir de #planStartDate (fallback = mês atual)
  let startMonth = (new Date()).getMonth() + 1; // 1..12
  const startEl = document.getElementById('planStartDate');
  if (startEl && startEl.value){
    const d = new Date(startEl.value + 'T00:00:00');
    if (!Number.isNaN(d.getTime())) startMonth = d.getMonth() + 1;
  }
  // usar a ordem cronológica definida na planilha (BANNER_SHEET) como linha do tempo
const monthsSeq = Object.keys(BANNER_SHEET);

// Índice de início = primeiro mês cujo número (1..12) >= startMonth
let startIdx = monthsSeq.findIndex(m => PT_MONTH_INDEX[norm(m)] >= startMonth);
if (startIdx < 0) startIdx = 0;

// Da data inicial em diante (inclui January..June do “próximo ano”)
// e ainda filtra para manter só meses que realmente têm banners no dataset atual
const monthsToRender = monthsSeq.slice(startIdx).filter(m => byMonth[m]);

// ====== A partir daqui renderiza
monthsToRender.forEach(mes=>{
    const arr = byMonth[mes];
    const b1   = arr.find(x=>x.tipo==='Banner 1');
    const b2   = arr.find(x=>x.tipo==='Banner 2');
    const rebs = arr.filter(x=>x.tipo==='Rebanner'); // 0..2

    const group = document.createElement('div');
    group.className='month-group';
    group.innerHTML=`<div class="month-title">${mes}</div>`;

    const row = document.createElement('div');
    row.className='month-row';

    const mkLinesHTML = (b)=>{
      const t150 = +b.t150 || 0;
      const m100 = +b.m100 || 0;

      // cashback de Marchs e %: **apenas para tickets**
      const gastoTickets   = 150 * t150;
      const cbMilTickets   = cashbackMilestones(t150); // só tickets contam
      const cashbackPerc   = Math.round(gastoTickets * ((+b.cashback || 0)/100));
      const cashbackTotal  = (cbMilTickets.cashbackDiamonds || 0) + cashbackPerc;

      return `<div class="banner-lines">
        <span>Tickets: ${t150.toLocaleString('pt-BR')}</span>
        <span>Memories: ${m100.toLocaleString('pt-BR')}</span>
        <span>Cashback: ${cashbackTotal.toLocaleString('pt-BR')}</span>
      </div>`;
    };

    const mkCard=(b,label)=>{
      const el=document.createElement('div'); el.className='banner-card';
      const imgSrc=getBannerImage(b);
      el.innerHTML=`
        <h5>${label} • ${b.nome||''}</h5>
        ${imgSrc?`<img src="${imgSrc}" onerror="this.style.display='none'>`:
          `<div style="height:210px;border:1px dashed #444;border-radius:10px;display:flex;align-items:center;justify-content:center;opacity:.7">Sem imagem</div>`}
        <div class="banner-fields">
          <label>Tickets (150): <input type="number" class="planner-input" data-id="${b.id}" data-k="t150" min="0" step="1" value="${b.t150||0}"></label>
          <label>Memories (100): <input type="number" class="planner-input" data-id="${b.id}" data-k="m100" min="0" step="1" value="${b.m100||0}"></label>
        </div>
        ${mkLinesHTML(b)}
      `;
      el.querySelectorAll('input[data-id]').forEach(inp=>{
        inp.addEventListener('input', e=>{
          const it=planner.banners.find(x=>x.id===e.target.getAttribute('data-id'));
          if(!it) return; it[e.target.getAttribute('data-k')]=+e.target.value||0;
          const old=el.querySelector('.banner-lines');
          if(old){
            const tmp=document.createElement('div');
            tmp.innerHTML=mkLinesHTML(it);
            old.replaceWith(tmp.firstElementChild);
          }
          recalc();
        });
      });
      return el;
    };

    // Coluna esquerda: Banner 1
    const left=document.createElement('div');
    if(b1) left.appendChild(mkCard(b1,'Banner 1'));
    row.appendChild(left);

    // Coluna do meio: TODOS os rebanners LADO A LADO
    const mid=document.createElement('div'); mid.className='rebanners-row';
    rebs.forEach((rb,i)=>{
      const card=mkCard(rb, `Rebanner ${rebs.length>1?i+1:''}`.trim());
      card.classList.add('rebanner-card');
      mid.appendChild(card);
    });
    if(rebs.length) row.appendChild(mid); else row.appendChild(document.createElement('div')); // mantém 3 colunas

    // Coluna direita: Banner 2
    const right=document.createElement('div');
    if(b2) right.appendChild(mkCard(b2,'Banner 2'));
    row.appendChild(right);

    group.appendChild(row);
    wrap.appendChild(group);
  });
}






  // ===== Cálculos =====
  function gainsFreePorDia(){
    let total = 0;
    planner.free.forEach(f=>{
      if(!f.usar) return;
      const q = +f.qtd || 0;
      switch(f.freq){
        case 'Daily': total += q; break;
        case 'Weekly': total += q/7; break;
        case 'Biweekly': total += q/14; break;
        case 'Monthly': total += q/30; break;
      }
    });
    return total;
  }

  function recalc(){ simular(); persistTemp(); }
// ===== Alternador de servidor: Japão / China =====
const SERVER_KEYS = { JP: 'banners_JP', CN: 'banners_CN' };

// Inicializa os datasets por servidor.
// - Se ainda não existir, semeia JP com a lista atual e CN como cópia vazia (ou a atual, se preferir).
function initServerBanners(){
  // garante que planner existe
  window.planner = window.planner || {};
  if (!planner.server) planner.server = 'JP';

  // semear JP se vazio
  if (!localStorage.getItem(SERVER_KEYS.JP)) {
    localStorage.setItem(SERVER_KEYS.JP, JSON.stringify(planner.banners || []));
  }
  // semear CN se vazio (aqui começo igual ao JP; depois você edita a ordem manualmente)
  if (!localStorage.getItem(SERVER_KEYS.CN)) {
    localStorage.setItem(SERVER_KEYS.CN, JSON.stringify(planner.banners || []));
  }

  // carrega o dataset do servidor ativo para planner.banners
  const activeKey = SERVER_KEYS[planner.server] || SERVER_KEYS.JP;
  try {
    const saved = JSON.parse(localStorage.getItem(activeKey) || '[]');
    planner.banners = Array.isArray(saved) ? saved : [];
  } catch {
    planner.banners = planner.banners || [];
  }

  // estado visual dos botões
  document.getElementById('serverJPBtn')?.classList.toggle('active', planner.server === 'JP');
  document.getElementById('serverCNBtn')?.classList.toggle('active', planner.server === 'CN');
}

// Troca o servidor, salvando o dataset atual e carregando o outro.
function switchServer(s){
  if (!SERVER_KEYS[s]) return;
  if (!window.planner) return;

  // salva banners atuais no slot do servidor corrente
  const curKey = SERVER_KEYS[planner.server || 'JP'];
  try { localStorage.setItem(curKey, JSON.stringify(planner.banners || [])); } catch{}

  // carrega banners do novo servidor
  const nextKey = SERVER_KEYS[s];
  let next = [];
  try { next = JSON.parse(localStorage.getItem(nextKey) || '[]'); } catch{}
  planner.banners = Array.isArray(next) ? next : [];
  planner.server = s;

  // atualiza UI
  document.getElementById('serverJPBtn')?.classList.toggle('active', s === 'JP');
  document.getElementById('serverCNBtn')?.classList.toggle('active', s === 'CN');

  // re-render e recalcula
  if (typeof renderBanners === 'function') renderBanners();
  if (typeof recalc === 'function') recalc();
  if (typeof savePlanner === 'function') savePlanner(); // opcional
}
  // DEV: resetar dataset do servidor e reseed a partir da planilha atual
window.resetServer = function(s='JP'){
  const key = SERVER_KEYS[s] || SERVER_KEYS.JP;
  localStorage.removeItem(key);
  // re-semeia conforme init
  initServerBanners();
  renderBanners && renderBanners();
  recalc && recalc();
};
// Liga os botões (chame após montar o Planner)
function bindServerButtons(){
  document.getElementById('serverJPBtn')?.addEventListener('click', ()=>switchServer('JP'));
  document.getElementById('serverCNBtn')?.addEventListener('click', ()=>switchServer('CN'));
}

// >>> Em algum ponto da inicialização do Planner:

// (se já carrega banners antes, chame initServerBanners() logo depois)

  // meses pt-BR -> 1..12
const PT_MONTH_INDEX = {
  "January":1,"February":2,"March":3,"March":3,"April":4,"May":5,"June":6,
  "July":7,"August":8,"September":9,"October":10,"November":11,"December":12
};
const norm = s => String(s||'').trim().toLowerCase();
// Torna o mapa tolerante a maiúsc./minúsc. e acentos
(() => {
  const keys = Object.keys(PT_MONTH_INDEX);
  for (const k of keys) {
    const low = String(k).normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase();
    PT_MONTH_INDEX[low] = PT_MONTH_INDEX[k];
  }
})();
// dias reais do mês (considera ano bissexto)
function daysInMonth(year, month1to12){
  return new Date(year, month1to12, 0).getDate();
}

// lê a data do input; se vazio, usa hoje
function getPlanStartDate(){
  const el = document.getElementById('planStartDate');
  const v = el && el.value ? new Date(el.value+'T00:00:00') : new Date();
  // zera hora
  return new Date(v.getFullYear(), v.getMonth(), v.getDate());
}

// atalho p/ “Hoje”
(function bindStartToday(){
  const b = document.getElementById('startTodayBtn');
  const i = document.getElementById('planStartDate');
  if (b && i){
    b.addEventListener('click', ()=>{
      const now = new Date();
      i.value = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
      if (typeof recalc === 'function') recalc();
    });
  }
  if (i){
    i.addEventListener('change', ()=>{ if (typeof recalc === 'function') recalc(); });
  }
})();

  function simular(){
  const tbody = $('#simTable tbody'); if(!tbody) return;
  tbody.innerHTML = '';

  // --- 0) saldos iniciais (cristais + tickets*150)
  // --- 0) saldos iniciais (cristais + tickets*150) — com casting seguro
const num = (id)=> Math.max(0, +(document.getElementById(id)?.value || 0));
const saldoCristais = num('saldoInicial');
const saldoTickets  = num('ticketsInic') * 150;
let saldo = saldoCristais + saldoTickets;


  // --- 1) ordem cronológica de meses a partir dos banners
  const order = [];
  const seen = new Set();
  (planner.banners||[]).forEach(b=>{
    const m = norm(b.mes);
    if(m && !seen.has(m)){ seen.add(m); order.push(m); }
  });

  // --- 2) agrega GASTOS/CASHBACK/EXTRAS por mês (somando banners daquele mês)
  const byMonth = new Map();
  const extrasTot = { ssrBox:0, milk:0, copy:0 };

  (planner.banners||[]).forEach(b=>{
    const m = norm(b.mes); if(!m) return;
    if(!byMonth.has(m)){
      byMonth.set(m, { mes:m, gastoBruto:0, cashback:0, custoLiquido:0, extras:{ssrBox:0,milk:0,copy:0} });
    }
    const t150 = +b.t150 || 0;
    const m100 = +b.m100 || 0;

    // custo total continua somando tudo
  const gastoBruto  = 150*t150 + 100*m100;

// ⚠️ EXTRAS agora contam SÓ tickets (150), sem memórias (100)
  const cbMilExtras = cashbackMilestones(t150);

    // cashback só com tickets
    const cbMilTickets = cashbackMilestones(t150);
    const cashbackPerc = Math.round((150*t150) * ((+b.cashback || 0)/100));
    const cashback     = (cbMilTickets.cashbackDiamonds || 0) + cashbackPerc;

    const custoLiquido = gastoBruto - cashback;

    const mm = byMonth.get(m);
    mm.gastoBruto   += gastoBruto;
    mm.cashback     += cashback;
    mm.custoLiquido += custoLiquido;

    // extras somam pelos pulls totais
    mm.extras.ssrBox += (cbMilExtras.extras?.ssrBox || 0);
    mm.extras.milk   += (cbMilExtras.extras?.milk   || 0);
    mm.extras.copy   += (cbMilExtras.extras?.copy   || 0);

    extrasTot.ssrBox += (cbMilExtras.extras?.ssrBox || 0);
    extrasTot.milk   += (cbMilExtras.extras?.milk   || 0);
    extrasTot.copy   += (cbMilExtras.extras?.copy   || 0);
  });

  // --- 3) gains por mês (FREE + distribuir CASH a partir da data de início)
  const gainDiaFREE = gainsFreePorDia();
  const start = getPlanStartDate();
  const startMonthIdx = start.getMonth()+1; // 1..12
  const startYear = start.getFullYear();

  // encontra o índice do 1º mês que coincide com a data de início;
  // se não encontrar, usa o primeiro da lista (mês cheio).
  let idxStart = order.findIndex(m => PT_MONTH_INDEX[String(m).trim().toLowerCase()] === startMonthIdx);
if (idxStart < 0) idxStart = 0; // fallback seguro

  if (idxStart === -1) idxStart = 0;

  // consumo de CASH: começa na data de início
  // NÃO queremos mais consumo estadoful:



  // ano/mês correntes para cada entrada da order (contabiliza virada de ano)
  let runningYear = startYear;
  let prevIdx = startMonthIdx;

  // totais
  let totalgains=0, totalGastoBruto=0, totalCashback=0, totalLiquido=0;

  for (let i=0;i<order.length;i++){
    const label = order[i];
    const mIdx = PT_MONTH_INDEX[String(label).trim().toLowerCase()] || 1;



    // avança o ano quando cruza December->January
    if (i === 0){
      // se a lista começa antes do mês de início, ajuste o ano para trás
      // (opcional: pode deixar como está; não afeta pró-rata)
    } else if (prevIdx > mIdx){
      runningYear += 1;
    }
    prevIdx = mIdx;

    // dias do mês real
    const dim = daysInMonth(runningYear, mIdx);

    // se o mês é anterior à data de início → pula (sem gains, sem custos)
    // Obs: se NÃO quiser pular custos de meses anteriores, troque o 'continue' por 'activeDays=0'.
    if (i < idxStart){
      continue;
    }

    // dias ativos: pró-rata no primeiro mês útil, cheios nos demais
    const activeDays = (i === idxStart)
      ? (mIdx === startMonthIdx ? Math.max(0, dim - (start.getDate() - 1)) : dim) // se o label for o mesmo mês da data
      : dim;

    // gains FREE + CASH desse mês (CASH consome 'activeDays' sequencialmente)
    // FREE do mês (mantém)
const gFree = Math.round(gainDiaFREE * activeDays);

// CASH do mês: Quantity (por dia) × min(Frequency, dias ativos no mês)
let gCash = 0;
(planner.cash || []).forEach(c=>{
  if(!c || !c.usar) return;

  // Compat: alguns planos antigos usam c.porDia; no UI atual, a coluna é "Quantity" => c.qtd
  const perDay = (+c.qtd || +c.porDia || 0);

  // "Frequency" agora significa "dias ativos no mês" (ex.: 30 = mês inteiro)
  const diasAtivosNoMes = Math.min(activeDays, +c.dias || 0);

  gCash += perDay * diasAtivosNoMes;
});

const gains = gFree + Math.round(gCash);


    // custos agregados daquele mês (se não houver, zero)
    const mm = byMonth.get(label) || { gastoBruto:0, cashback:0, custoLiquido:0 };

    // saldo
    const saldoIni = saldo;
    saldo = saldo + gains - mm.custoLiquido;

    // render linha
    const pretty = label.charAt(0).toUpperCase() + label.slice(1);
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${pretty}</td>
      <td class="right">${gains.toLocaleString('pt-BR')}</td>
      <td class="right">${(mm.gastoBruto||0).toLocaleString('pt-BR')}</td>
      <td class="right">${(mm.cashback||0).toLocaleString('pt-BR')}</td>
      <td class="right">${(mm.custoLiquido||0).toLocaleString('pt-BR')}</td>
      <td class="right">${saldoIni.toLocaleString('pt-BR')}</td>
      <td class="right">${saldo.toLocaleString('pt-BR')}</td>
    `;
    // pinta saldo final negativo
    const saldoCell = tr.querySelector('td:last-child');
    if (saldoCell) saldoCell.classList.toggle('neg', saldo < 0);

    tbody.appendChild(tr);

    // totais (se mantiver rodapé)
    totalgains     += gains;
    totalGastoBruto += (mm.gastoBruto||0);
    totalCashback   += (mm.cashback||0);
    totalLiquido    += (mm.custoLiquido||0);
  }

  // atualiza rodapé se você ainda estiver usando <tfoot> (se não, pode remover)
  const el = (id)=>document.getElementById(id);
  if (el('tgains'))      el('tgains').textContent      = totalgains.toLocaleString('pt-BR');
  if (el('tGastoBruto'))  el('tGastoBruto').textContent  = totalGastoBruto.toLocaleString('pt-BR');
  if (el('tCashback'))    el('tCashback').textContent    = totalCashback.toLocaleString('pt-BR');
  if (el('tLiquido'))     el('tLiquido').textContent     = totalLiquido.toLocaleString('pt-BR');
  if (el('tSaldoFinal')){ el('tSaldoFinal').textContent  = saldo.toLocaleString('pt-BR');
                          el('tSaldoFinal').classList.toggle('neg', saldo < 0); }

  // extras (se estiver usando a caixa abaixo da tabela)
  const simEl = document.getElementById('simExtras');
  if (simEl) {
    simEl.innerHTML = `
      <div><b>Extras Totais</b> —
        SSR Box: <b>${extrasTot.ssrBox}</b> •
        Milk: <b>${extrasTot.milk}</b> •
        Copy: <b>${extrasTot.copy}</b>
      </div>`;
  }
}


   

  // ===== Persistência =====
  function savePlan(name){
    const store = JSON.parse(localStorage.getItem(PLANS_KEY)||'{}');
    store[name] = JSON.parse(JSON.stringify(planner));
    localStorage.setItem(PLANS_KEY, JSON.stringify(store));
    fillSlots(name);
  }
  function loadPlan(name){
    const store = JSON.parse(localStorage.getItem(PLANS_KEY)||'{}');
    if(!store[name]) return;
    planner = JSON.parse(JSON.stringify(store[name]));
    $('#saldoInicial').value = planner.saldoInicial || 0;
    $('#nomePlano').value = name;
    renderFree(); renderCash(); renderBanners(); recalc();
  }
  function delPlan(name){
    const store = JSON.parse(localStorage.getItem(PLANS_KEY)||'{}');
    delete store[name];
    localStorage.setItem(PLANS_KEY, JSON.stringify(store));
  }
  function fillSlots(sel=''){
    const store = JSON.parse(localStorage.getItem(PLANS_KEY)||'{}');
    const sl = $('#slotsPlanos'); if(!sl) return;
    sl.innerHTML = '<option value="">(selecione um plano salvo)</option>';
    Object.keys(store).sort().forEach(k=>{
      const opt = document.createElement('option');
      opt.value = k; opt.textContent = k; if(k===sel) opt.selected = true; sl.appendChild(opt);
    });
  }
  function persistTemp(){
    const draft = JSON.parse(JSON.stringify(planner));
    try{ localStorage.setItem(DRAFT_KEY, JSON.stringify(draft)); }catch(e){}
  }
  function loadDraft(){
    try{
      const draft = JSON.parse(localStorage.getItem(DRAFT_KEY)||'null');
      if(draft){
        planner = draft;
        return true;
      }
    }catch(e){}
    return false;
  }

  // ===== Navegação =====
  function showPlanner(){ document.body.classList.add('show-planner'); document.getElementById('pagePlanner').style.display='block';document.body.classList.add('planner-open');}
  function showBuilder(){ document.body.classList.remove('show-planner'); document.getElementById('pagePlanner').style.display='none';document.body.classList.remove('planner-open'); }

  window.hqShowPlanner = showPlanner;
  window.hqShowBuilder = showBuilder;

  
  // ===== Boot =====
  function boot(){
    {
  const btnOpenRanking = document.getElementById('btnOpenRanking');
  if (btnOpenRanking){
    btnOpenRanking.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      document.body.classList.remove('show-planner');
      document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
      const rankPg = document.getElementById('pageRanking');
      if (rankPg){ rankPg.classList.add('active'); rankPg.style.display='block'; }
     // 1) abre 7d por padrão (sem borbulhar)
document.getElementById('btnRank7d')?.dispatchEvent(new Event('click', { bubbles:false }));

// 2) rola suavemente até o bloco dos rankings (logo abaixo das sinergias)
requestAnimationFrame(()=> {
  // escolha automática do alvo (ajusta se você tiver um id específico)
  const target =
    document.getElementById('pageRanking') ||
    document.getElementById('rankingPanels') ||
    document.getElementById('panelRank7d');

  if (!target) return;

  // compensa cabeçalho fixo, se existir
  const sticky =
    document.querySelector('.topbar, .header, #stickyHeader, .navbar, .nav-top');
  const isFixed = sticky && getComputedStyle(sticky).position === 'fixed';
  const offset = isFixed ? sticky.offsetHeight + 12 : 12;

  const y = target.getBoundingClientRect().top + window.pageYOffset - offset;
  window.scrollTo({ top: y, behavior: 'smooth' });
});
    });
  }

  // botões internos do ranking
  (function(){
    const p7 = document.getElementById('panelRank7d');
    const pA = document.getElementById('panelRankAll');
    const pC = document.getElementById('panelRankChar');
    const showOnly = (panel) => [p7,pA,pC].forEach(p => p && (p.hidden = (p!==panel)));
    document.getElementById('btnRank7d') ?.addEventListener('click', ()=> showOnly(p7));
    document.getElementById('btnRankAll')?.addEventListener('click', ()=> showOnly(pA));
    document.getElementById('btnRankChar')?.addEventListener('click', ()=> showOnly(pC));
  })();
}
// Detecta pelo <html lang="...">, com override possível por window.SITE_LANG
const SITE_LANG = (window.SITE_LANG || document.documentElement.lang || 'pt-BR').toLowerCase();
// Nome da aba no Sheets
const COMMENTS_SHEET = SITE_LANG.startsWith('pt') ? 'commentsPTBR' : 'commentsEN';
    const btnOpen = document.getElementById('openPlannerBtn'); if(btnOpen) btnOpen.addEventListener('click', showPlanner);
    {
  const srcBtn = document.getElementById('openPlannerBtn')    // use o que já tem estilizado
             || document.querySelector('#sidebar button, #sidebar .menu-btn');
  const dstBtn = document.getElementById('btnOpenRanking');
  if (srcBtn && dstBtn){
    dstBtn.className = srcBtn.className;   // 🔁 copia as MESMAS classes
    // se o src tiver um wrapper específico (ex.: display:block 100%), copie também estilos inline úteis
    if (srcBtn.style.width)  dstBtn.style.width  = srcBtn.style.width;
    if (srcBtn.style.display)dstBtn.style.display= srcBtn.style.display;
  }
}
    const btnBack = document.getElementById('btnVoltarBuilder'); if(btnBack) btnBack.addEventListener('click', showBuilder);
    


    const btnToggle = document.getElementById('toggleSources');
    if(btnToggle){ btnToggle.addEventListener('click', ()=> setCollapsed(!document.body.classList.contains('planner-collapsed'))); }
    const btnReopen = document.getElementById('reopenSources');
    if(btnReopen){ btnReopen.addEventListener('click', ()=> setCollapsed(false)); }
    const prev = localStorage.getItem(COLLAPSE_KEY);

  // === Toggle "Meme Version" no topo, ao lado do + Team ===
(function placeTopMemeToggle(){
  const addBtn = document.getElementById('addTeamBtn');
  if (!addBtn || document.getElementById('memeToggleTop')) return; // já colocado

  const wrap = document.createElement('div');
  wrap.style.display = 'inline-flex';
  wrap.style.alignItems = 'center';
  wrap.style.gap = '10px';
  wrap.style.marginLeft = '10px';

  const label = document.createElement('label');
  label.style.display = 'inline-flex';
  label.style.alignItems = 'center';
  label.style.gap = '6px';
  label.innerHTML = `
    <input id="memeToggleTop" type="checkbox" ${window.MEME_VERSION_ON ? 'checked' : ''}>
    <div>Community Characters</div>
  `;

  // Insere imediatamente depois do botão + Team
  addBtn.parentNode.insertBefore(wrap, addBtn.nextSibling);
  wrap.appendChild(label);

  // Listener do toggle do topo
  const top = label.querySelector('#memeToggleTop');
  top.addEventListener('change', (e)=>{
    window.MEME_VERSION_ON = !!e.target.checked;
syncCharactersWithToggle(); // atualiza lista global "characters"
updateWinDiamondsBtn();

// se a lista do grid estiver aberta, reconstrói imediatamente
if (isGridMenuOpen()) {
  refreshGridMenu();
}

// manter os dois toggles sincronizados
const otherId = this.id === 'memeToggle' ? 'memeToggleTop' : 'memeToggle';
const other = document.getElementById(otherId);
if (other && other.checked !== window.MEME_VERSION_ON) {
  other.checked = window.MEME_VERSION_ON;
}


    // Se a aba Characters estiver aberta, re-renderiza
    if (document.getElementById('charList')) {
      showCharacterList();
    }

    // Sincroniza com o toggle da lateral (se existir)
    const side = document.getElementById('memeToggle');
    if (side && side.checked !== window.MEME_VERSION_ON) side.checked = window.MEME_VERSION_ON;
  });
})();

// 1ª visita: mantém colapsado; visitas seguintes: respeita o salvo
if (prev === null) {
  setCollapsed(true);
} else {
  setCollapsed(prev === '1');
}


    const saldoEl = document.getElementById('saldoInicial'); if(saldoEl) saldoEl.addEventListener('input', ()=>{ planner.saldoInicial = +(saldoEl.value||0); recalc(); });
    const nomeEl  = document.getElementById('nomePlano');    if(nomeEl)  nomeEl.addEventListener('input', ()=>{ planner.nomePlano = nomeEl.value||''; persistTemp(); });
    
    const bSave = document.getElementById('btnSalvarPlano'); if(bSave) bSave.addEventListener('click', ()=>{
      const name = (document.getElementById('nomePlano').value||'').trim() || 'Plano';
      savePlan(name);
    });
    const bNovo = document.getElementById('btnNovoPlano'); if(bNovo) bNovo.addEventListener('click', ()=>{
      planner = { saldoInicial:0, nomePlano:'', free:JSON.parse(JSON.stringify(DEFAULT_FREE)), cash:JSON.parse(JSON.stringify(DEFAULT_CASH)), banners:[] };
      document.getElementById('saldoInicial').value = 0; document.getElementById('nomePlano').value='';
      seedBannersFromSheet();
      // 1) garante dados base (JP) em memória
if (!planner.banners || !planner.banners.length) seedBannersFromSheet();


      renderFree(); renderCash(); renderBanners(); recalc(); fillSlots(''); persistTemp();
    });
    const bDel = document.getElementById('btnExcluirPlano'); if(bDel) bDel.addEventListener('click', ()=>{
      const sel = document.getElementById('slotsPlanos').value; if(sel){ delPlan(sel); fillSlots(''); }
    });
    const slots = document.getElementById('slotsPlanos'); if(slots) slots.addEventListener('change', (e)=>{ const name = e.target.value; if(name) loadPlan(name); });

    const hadDraft = loadDraft();
    if(!hadDraft || !planner.banners || planner.banners.length===0 ||
       (planner.banners.length===1 && /^Novo Banner$/i.test(planner.banners[0]?.nome||'')) ){
      seedBannersFromSheet();
    }

    fillSlots(planner?.nomePlano || '');
    initServerBanners();     // <— COLE AQUI
    bindServerButtons();
    renderFree(); renderCash(); renderBanners(); recalc();
  }
  // === BIND: + Fonte FREE / + Fonte CASH ===
const $addFree = document.getElementById('addFree');
if ($addFree) {
  $addFree.addEventListener('click', () => {
    // linha nova FREE (usar/nome/qtd/freq)
    planner.free = planner.free || [];
    planner.free.push({ usar: true, nome: 'Nova fonte FREE', qtd: 0, freq: 'Monthly' });
    renderFree && renderFree();
    recalc && recalc();
    savePlanner && savePlanner();
  });
}

const $addCash = document.getElementById('addCash');
if ($addCash) {
  $addCash.addEventListener('click', () => {
    // linha nova CASH (usar/nome/diamantes por dia/dias)
    planner.cash = planner.cash || [];
    planner.cash.push({ usar: true, nome: 'Nova fonte CASH', qtd: 0, dias: 30 });
    renderCash && renderCash();
    recalc && recalc();
    savePlanner && savePlanner();
  });
}

  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();

})();
/* ==================== STATS BONDS – infra (revamp) ==================== */

/** 3.1) Nomes dos titulares do grid principal */
/** titulares + banco: quem pode aparecer listado no modal */
function getPresentTeamNames(){
  const main  = [...document.querySelectorAll('.hex')].map(s => s.dataset?.nome).filter(Boolean);
  const bench = [...document.querySelectorAll('.bench-slot')].map(s => s.dataset?.nome).filter(Boolean);
  return new Set([...main, ...bench]);
}

/** personagens salvos na conta (localStorage) */
const OWNED_KEY = 'hqOwnedCharsV2';
function loadOwned(){ try{ return new Set(JSON.parse(localStorage.getItem(OWNED_KEY)||'[]')); }catch(e){ return new Set(); } }
function saveOwned(set){ localStorage.setItem(OWNED_KEY, JSON.stringify([...set])); }
function clearOwned(){ localStorage.removeItem(OWNED_KEY); }

/** conjunto para ATIVAÇÃO: time (quadra+banco) + conta */
function getActivationSet(){
  const present = getPresentTeamNames();
  const owned   = loadOwned();
  return new Set([...present, ...owned]);
}

/** 3.2) Fonte de dados (segue igual: window.STATS_BONDS = {...}) */
const STATS_BONDS = (typeof window !== 'undefined' && window.STATS_BONDS) ? window.STATS_BONDS : {};

/** 3.3) (fallback opcional — mantém se quiser) */
if (!Object.keys(STATS_BONDS).length){
  window.STATS_BONDS = {
    "Team's Guardians": { "Nishinoya SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Yaku SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
    "Karasuno's Setters": { "Sugawara SP": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Kageyama UR": "" }
  };
}

/** 3.4) Extrai vínculos de stats “ativos” considerando titulares + conta */
function getActiveStatBonds(){
  const presentForList = getPresentTeamNames();   // quadra + banco (para mostrar)
  const activationSet  = getActivationSet();      // time + conta (para ativar)

  const out = [];

  for (const [bondName, mapping] of Object.entries(window.STATS_BONDS || {})){
    const allMembers = Object.keys(mapping);

    // Quem ativa (time + conta)
    const activators = allMembers.filter(k => activationSet.has(k));
    if (activators.length < 2) continue;

    // Quem aparece (somente time)
    const listed   = allMembers.filter(k => presentForList.has(k));
    if (listed.length === 0) continue;

    // Quem não está aparecendo (fora do time)
    const missing  = allMembers.filter(k => !presentForList.has(k));

    const toEntry = (name)=>({
      name,
      buff: mapping[name] || '',
      img: (characters.find(p => p.nome === name) || {}).img || ''
    });

    out.push({
      bondName,
      entries: listed.map(toEntry),
      missing: missing.map(toEntry)
    });
  }

  out.sort((a,b)=> a.bondName.localeCompare(b.bondName));
  return out;
}

  
/** 3.5) Picker “Personagens da conta” (multi-seleção com busca) */
function openOwnedPicker(){
  const owned = loadOwned();
  const allChars = (Array.isArray(characters) ? characters.slice() : []).sort((a,b)=>a.nome.localeCompare(b.nome));

  const backdrop = document.createElement('div'); backdrop.className = 'item-modal-backdrop';
  const box = document.createElement('div'); box.className = 'item-modal';
  backdrop.appendChild(box);

  box.innerHTML = `
    <h3>Adicionar Personagens da conta</h3>
    <div style="display:flex;gap:8px;align-items:center;margin:6px 0;">
      <input id="ownedSearch" placeholder="Pesquisar..." style="flex:1;padding:6px;">
      <button id="ownedAll"   class="item-btn" type="button">All</button>
      <button id="ownedClear" class="item-btn" type="button">Clear</button>
    </div>
    <div id="ownedGrid" class="owned-picker"></div>
    <div class="item-actions">
      <button id="ownedCancel" class="item-btn">Cancelar</button>
      <button id="ownedSave"   class="item-btn">Salvar</button>
    </div>
  `;

  const render = (term='')=>{
    const t = term.trim().toLowerCase();
    const grid = box.querySelector('#ownedGrid');
    grid.innerHTML = allChars
      .filter(c => !t || c.nome.toLowerCase().includes(t))
      .map(c => `
        <label class="owned-card">
          <img class="stats-char-thumb" src="${c.img}" alt="">
          <span>${c.nome}</span>
          <input type="checkbox" data-name="${c.nome}" ${owned.has(c.nome)?'checked':''}>
        </label>
      `).join('');
  };
  render();

  const markAll = (state)=>{
    box.querySelectorAll('input[type="checkbox"][data-name]').forEach(cb => cb.checked = state);
  };

  box.querySelector('#ownedSearch').addEventListener('input', e=>render(e.target.value));
  box.querySelector('#ownedAll').addEventListener('click',   ()=> markAll(true));
  box.querySelector('#ownedClear').addEventListener('click', ()=> markAll(false));

  box.querySelector('#ownedCancel').addEventListener('click', ()=>backdrop.remove());
  box.querySelector('#ownedSave').addEventListener('click', ()=>{
    const picked = new Set(
      [...box.querySelectorAll('input[type="checkbox"][data-name]')]
        .filter(i=>i.checked).map(i=>i.dataset.name)
    );
    saveOwned(picked);
    backdrop.remove();
    // Reabre o modal de Stat Bonds já com o cálculo novo (time + conta)
    openStatsBondsModal();
  });

  document.body.appendChild(backdrop);
}

/** 3.6) Modal de listagem (com imagens + ações) */
function openStatsBondsModal(){
  const list = getActiveStatBonds();

  const backdrop = document.createElement('div');
  backdrop.className = 'item-modal-backdrop';

  const modal = document.createElement('div');
  modal.className  = 'item-modal';

  let html = `<h3>Active Stats Bonds (${list.length})</h3>`;

  if (list.length === 0){
    html += `<p style="opacity:.85">No stats bonds are active in main court, add characters to the account</p>`;
  } else {
    html += `<div class="stats-bond-list">`;
    list.forEach((b, i) => {
      html += `
        <div class="stats-bond-item">
          <div class="stats-bond-head">
            <h4>${b.bondName}</h4>
            ${b.missing.length ? `<button class="see-details-btn" data-bond-id="${i}">See details</button>` : ``}
          </div>
          <ul>
            ${b.entries.map(e => `
              <li>
                ${e.img ? `<img class="stats-char-thumb" src="${e.img}" alt="${e.name}">` : ''}
                <b>${e.name}</b> — ${e.buff && e.buff.trim() ? e.buff : '<em>sem buff</em>'}
              </li>
            `).join('')}
          </ul>

          ${b.missing.length ? `
            <ul class="missing-list" data-bond-id="${i}" style="display:none;">
              ${b.missing.map(e => `
                <li class="missing-char">
                  ${e.img ? `<img class="stats-char-thumb" src="${e.img}" alt="${e.name}">` : ''}
                  <b>${e.name}</b> — ${e.buff && e.buff.trim() ? e.buff : '<em>sem buff</em>'}
                </li>
              `).join('')}
            </ul>
          ` : ``}
        </div>
      `;
    });
    html += `</div>`;
  }

  html += `
    <div class="item-actions">
      <button id="addOwnedBtn" class="item-btn">Add Characters to your Account</button>
      <button id="clearOwnedBtn" class="item-btn">Clear All</button>
      <button id="closeStatsModal" class="item-btn">Close</button>
    </div>`;
  modal.innerHTML = html;

  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  document.body.classList.add('modal-open');

  const close = ()=>{ document.body.classList.remove('modal-open'); backdrop.remove(); };
  backdrop.addEventListener('click', (e)=>{ if (e.target === backdrop) close(); });
  modal.querySelector('#closeStatsModal').addEventListener('click', close);

  // “Conta”
  modal.querySelector('#addOwnedBtn').addEventListener('click', ()=>{
    close(); openOwnedPicker();
  });
  modal.querySelector('#clearOwnedBtn').addEventListener('click', ()=>{
    if (confirm('Limpar todos os personagens da conta?')){ clearOwned(); close(); openStatsBondsModal(); }
  });

  // Toggle See details / Hide details
  modal.querySelectorAll('.see-details-btn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const id = btn.dataset.bondId;
      const block = modal.querySelector(`.missing-list[data-bond-id="${id}"]`);
      const isHidden = !block || block.style.display === 'none';
      if (block){
        block.style.display = isHidden ? 'block' : 'none';
        btn.textContent = isHidden ? 'Hide details' : 'See details';
      }
    });
  });
}

/** 3.7) Liga o botão do painel (id="statsBondBtn") */
(function bindStatsBondButton(){
  const btn = document.getElementById('statsBondBtn');
  if (btn && !btn.__sbBound){
    btn.__sbBound = true;
    btn.addEventListener('click', ()=>{
      if (!window.STATS_BONDS || !Object.keys(window.STATS_BONDS).length){
        alert('Nenhum mapeamento de "stats bonds" foi carregado. Defina window.STATS_BONDS = {...} antes.');
        return;
      }
      openStatsBondsModal();
    });
  }
})();
(() => {
  const btn = document.getElementById('openPlannerBtn');
  if (btn) btn.classList.add('bond-btn','menu-link');
})();

(function bindInitials(){
  const t   = document.getElementById('ticketsInic');
  const out = document.getElementById('ticketsInicCrystals');
  if (t && out){
    const upd = ()=>{
      const v = Math.max(0, +t.value || 0);
      out.textContent = (v * 150).toLocaleString('pt-BR');
    };
    const fire = ()=>{ upd(); recalc && recalc(); };
    t.addEventListener('input',  fire);
    t.addEventListener('change', fire);   // <— garante recálculo em todos os casos
    fire();                               // <— recalc já na carga
  }
  const totalOut = document.getElementById('saldoInicialTotal');
if (totalOut && t){
  const s = document.getElementById('saldoInicial');
  const updTotal = ()=>{
    const saldo = (Math.max(0, +s?.value||0)) + (Math.max(0, +t.value||0) * 150);
    totalOut.textContent = saldo.toLocaleString('pt-BR');
  };
  t.addEventListener('input',  updTotal);
  t.addEventListener('change', updTotal);
  s?.addEventListener('input',  updTotal);
  s?.addEventListener('change', updTotal);
  updTotal();
}


  const s = document.getElementById('saldoInicial');
  if (s){
    const fire = ()=>{ recalc && recalc(); };
    s.addEventListener('input',  fire);
    s.addEventListener('change', fire);
  }
})();

// ===== Modal de Recursos (FREE/CASH) =====
(function(){
  const openBtn   = document.getElementById('openSourcesBtn');
  const modal     = document.getElementById('sourcesModal');
  const closeBtn  = document.getElementById('closeSourcesBtn');
  const bodySlot  = document.getElementById('sourcesModalBody');

  if(!openBtn || !modal || !bodySlot) return;

  let prevParent = null, prevNext = null; // onde devolver o painel ao fechar

  function openSourcesModal(){
  document.body.classList.remove('planner-collapsed');

  const panel = document.querySelector('.panel.sources');
  if(panel){
    prevParent = panel.parentNode;
    prevNext   = panel.nextSibling;
    bodySlot.appendChild(panel);
    panel.style.removeProperty('display');

    // ESCONDE o botão antigo de fechar/minimizar quando o painel está na modal
    const oldToggle = panel.querySelector('#toggleSources');
    if (oldToggle) oldToggle.style.display = 'none';
  }
  modal.classList.add('open');
  document.body.classList.add('modal-open');
  closeBtn?.focus();
}



  function closeSourcesModal(){
  const panel = document.querySelector('.modal-body .panel.sources');
  if (panel && prevParent){
    if (prevNext) prevParent.insertBefore(panel, prevNext);
    else          prevParent.appendChild(panel);
    panel.style.display = 'none';          // mantém oculto no layout base
    const oldToggle = panel.querySelector('#toggleSources');
    if (oldToggle) oldToggle.style.display = 'none'; // evita UI antiga
  }
  modal.classList.remove('open');
  document.body.classList.remove('modal-open');
}


  openBtn.addEventListener('click', openSourcesModal);
  closeBtn?.addEventListener('click', closeSourcesModal);

  // clicar fora fecha
  modal.addEventListener('click', (e)=>{
    if(e.target && e.target.getAttribute('data-close')) closeSourcesModal();
  });

  // ESC fecha
  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape' && modal.classList.contains('open')) closeSourcesModal();
  });
})();

// forma esperada dos itens (exemplo mínimo):
// { id, mes: 'September', tipo: 'Banner 1'|'Banner 2'|'Rebanner', nome: 'Oikawa UR', t150:0, m100:0, cashback:0 }

// forma esperada dos itens (exemplo mínimo):
// { id, mes: 'September', tipo: 'Banner 1'|'Banner 2'|'Rebanner', nome: 'Oikawa UR', t150:0, m100:0, cashback:0 }

(function setCNOrder(){
  const cnList = [
  { id:'cn-August-banner-1-ushijima-ur', mes:'August',   tipo:'Banner 1', nome:'Ushijima UR',    t150:0, m100:0, cashback:0 },
  { id:'cn-August-banner-2-kuro-ur',     mes:'August',   tipo:'Banner 2', nome:'Kuro UR',        t150:0, m100:0, cashback:0 },

  { id:'cn-September-banner-1-oikawa-ur', mes:'September', tipo:'Banner 1', nome:'Oikawa UR',      t150:0, m100:0, cashback:0 },
  { id:'cn-September-banner-2-bokuto-ur', mes:'September', tipo:'Banner 2', nome:'Bokuto UR',      t150:0, m100:0, cashback:0 },

  { id:'cn-October-banner-1-miya-atsumu-ur', mes:'October', tipo:'Banner 1', nome:'Miya Atsumu UR', t150:0, m100:0, cashback:0 },
  { id:'cn-October-rebanner-1-kuroo-ur',     mes:'October', tipo:'Rebanner', nome:'Kuro UR',       t150:0, m100:0, cashback:0 },
  { id:'cn-October-banner-2-miya-osamu-ur',  mes:'October', tipo:'Banner 2', nome:'Miya Osamu UR',  t150:0, m100:0, cashback:0 },

  { id:'cn-November-banner-1-Hoshiumi-ur',   mes:'November', tipo:'Banner 1', nome:'Hoshiumi UR',       t150:0, m100:0, cashback:0 },
  { id:'cn-November-banner-2-hirugami-ur',mes:'November', tipo:'Banner 2', nome:'Hirugami UR',    t150:0, m100:0, cashback:0 },

  { id:'cn-December-banner-1-kageyama-ur', mes:'December', tipo:'Banner 1', nome:'Kageyama UR',   t150:0, m100:0, cashback:0 },
  { id:'cn-December-rebanner-1-oikawa-ur', mes:'December', tipo:'Rebanner', nome:'Oikawa UR',     t150:0, m100:0, cashback:0 },
  { id:'cn-December-banner-2-hinata-sp',   mes:'December', tipo:'Banner 2', nome:'Hinata SP',     t150:0, m100:0, cashback:0 },

  { id:'cn-January-banner-1-kenma-sp',     mes:'January', tipo:'Banner 1', nome:'Kenma SP',       t150:0, m100:0, cashback:0 },
  { id:'cn-January-banner-2-nishinoya-sp', mes:'January', tipo:'Banner 2', nome:'Nishinoya SP',   t150:0, m100:0, cashback:0 },

  { id:'cn-February-banner-1-sugawara-sp', mes:'February', tipo:'Banner 1', nome:'Sugawara SP', t150:0, m100:0, cashback:0 },
  { id:'cn-February-banner-2-bokuto-sp',   mes:'February', tipo:'Banner 2', nome:'Bokuto SP',   t150:0, m100:0, cashback:0 },

  { id:'cn-March-banner-1-akaashi-sp',  mes:'March', tipo:'Banner 1', nome:'Akaashi SP',         t150:0, m100:0, cashback:0 },
  { id:'cn-March-banner-2-aone-sp',     mes:'March', tipo:'Banner 2', nome:'Aone SP',            t150:0, m100:0, cashback:0 },

  { id:'cn-April-banner-1-Sakusa-ur', mes:'April', tipo:'Banner 1', nome:'Sakusa UR',    t150:0, m100:0, cashback:0 },
  { id:'cn-April-banner-2-komori-ur',     mes:'April', tipo:'Banner 2', nome:'Komori UR',        t150:0, m100:0, cashback:0 },

  { id:'cn-May-banner-1-tsuki-sp',  mes:'May', tipo:'Banner 1', nome:'Tsuki SP',               t150:0, m100:0, cashback:0 },
  { id:'cn-May-banner-2-kuro-sp',   mes:'May', tipo:'Banner 2', nome:'Kuro SP',                t150:0, m100:0, cashback:0 },

  { id:'cn-June-banner-1-kunimi-sp',      mes:'June', tipo:'Banner 1', nome:'Kunimi SP',       t150:0, m100:0, cashback:0 },
  { id:'cn-June-banner-2-koganegawa-sp',  mes:'June', tipo:'Banner 2', nome:'Koganegawa SP',   t150:0, m100:0, cashback:0 },
];

// salvar & aplicar na UI (CN)
localStorage.setItem('banners_CN', JSON.stringify(cnList));
if (window.planner){
  planner.server = 'CN';
  planner.banners = cnList.slice();
  renderBanners && renderBanners();
  recalc && recalc();
  savePlanner && savePlanner();
}
})();



</script>
<script>
(function () {
  // === configure ===
  const ENDPOINT = 'https://script.google.com/macros/s/AKfycbwSnplPmw7Agru5gA7bU1Gk9_tAQSw8j3ma1WEFOMmlUXqXVBp-Qe4Ey-5xMxMRASS-/exec'; // ex.: https://script.google.com/macros/s/XXX/exec
  // =================

  async function updateCounters() {
    try {
      // Conta visitas repetidas: sempre incrementa a cada carregamento
      const res = await fetch(ENDPOINT + '?inc=1', { cache: 'no-store' });
      const data = await res.json();

      // Atualiza a UI se existir (não quebra se você mover/ocultar o bloco)
      const t = document.getElementById('visits-today');
      const g = document.getElementById('visits-total');
      if (data && !data.error) {
        if (t) t.textContent = data.todayCount ?? '0';
        if (g) g.textContent = data.total ?? '0';
      } else {
        console.warn('Counter API error:', data && data.error);
      }
    } catch (err) {
      console.error('View counter fetch failed:', err);
    }
  }

  // Dispara quando o DOM estiver pronto (não interfere no seu JS atual)
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', updateCounters);
  } else {
    updateCounters();
  }
})();
</script>

</body>
</html>
